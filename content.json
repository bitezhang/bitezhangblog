{"meta":{"title":"比特张的博客","subtitle":"beiying","description":"个人学习博客","author":"bitezhang","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-10-01T10:57:30.508Z","updated":"2022-10-01T10:57:30.508Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"有什么想对我说的可以在下面留言。 背景图片和头像图片"},{"title":"所有分类","date":"2022-09-10T16:18:33.643Z","updated":"2022-09-10T16:18:33.643Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-09-10T16:19:24.645Z","updated":"2022-09-10T16:19:24.645Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-09-10T16:18:45.503Z","updated":"2022-09-10T16:18:45.503Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2022-09-11T11:59:40.103Z","updated":"2022-09-11T11:59:40.103Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2022-10-10T02:24:39.334Z","updated":"2022-10-10T02:24:39.334Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 &#123;% p center bold, 很抱歉，您访问的页面不存在 %&#125; &#123;% p center small, 可能是输入地址有误或该地址已被删除 %&#125; 加我微信:beiyingzd kiss kiss!"}],"posts":[{"title":"C语言(3)","slug":"C语言-3","date":"2022-10-14T16:25:20.000Z","updated":"2022-10-14T16:29:07.408Z","comments":true,"path":"2022/10/15/C语言-3/","link":"","permalink":"http://example.com/2022/10/15/C%E8%AF%AD%E8%A8%80-3/","excerpt":"","text":"C语言高级特性前面我们了解了C语言的相关基础内容，我们来看看C语言的高级部分。这一章的学习难道会比较大，尤其是指针板块，因为需要理解计算机内存模型，所以说是很多初学者的噩梦。 函数其实函数我们在一开始就在使用了： 123int main() &#123; //这是定义函数 ...&#125; 我们程序的入口点就是main函数，我们只需要将我们的程序代码编写到主函数中就可以运行了，不够这个函数只是由我们来定义，而不是我们自己来调用。当然，除了主函数之外，我们一直在使用的printf也是一个函数，不过这个函数是标准库中已经实现好了的，现在是我们在调用这个函数： 1printf(&quot;Hello World!&quot;); //直接通过 函数名称(参数...) 的形式调用函数 那么，函数的具体定义是什么呢？ 函数是完成特定任务的独立程序代码单元。 其实简单来说，函数时为了完成某件任务而生的，可能我们要完成某个任务并不是一行代码就可以搞定的，但是现在可能会遇到这种情况： 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main() &#123; int a = 10; printf(&quot;H&quot;); //比如下面这三行代码就是我们要做的任务 printf(&quot;A&quot;); a += 10; if(a &gt; 20) &#123; printf(&quot;H&quot;); //这里我们还需要执行这个任务 printf(&quot;A&quot;); a += 10; &#125; switch (a) &#123; case 30: printf(&quot;H&quot;); //这里又要执行这个任务 printf(&quot;A&quot;); a += 10; &#125;&#125; 我们每次要做这个任务时，都要完完整整地将任务的每一行代码都写下来，如果我们的程序中多处都需要执行这个任务，每个地方都完整地写一遍，实在是太臃肿了，有没有一种更好的办法能优化我们的代码呢？ 这时我们就可以考虑使用函数了，我们可以将我们的程序逻辑代码全部编写到函数中，当我们执行函数时，实际上执行的就是函数中的全部内容，也就是按照我们制定的规则执行对应的任务，每次需要做这个任务时，只需要调用函数即可。 我们来看看，如何创建和使用函数。 创建和使用函数首先我们来看看如何创建一个函数，其实创建一个函数是很简单的，格式如下： 1返回值类型 函数名称([函数参数...]); 其中函数名称也是有要求的，并不是所有的字符都可以用作函数名称，它的命名规则与变量的命名规则基本一致，所以这里就不一一列出了。 函数不仅仅需要完成我们的任务，可能某些函数还需要告诉我们结果，比如我们之前认识的getchar函数，这个函数实际上返回了一个int值作为结果（也就是我们输入的字符）我们同样可以将函数返回的结果赋值给变量或是参与运算等等。 当然如果我们的函数只需要完成任务，不需要告诉我们结果，返回值类型可以写成void表示为空。 函数参数我们放在下一个小节中讲解，所以这里我们不使用任何参数，所以这里也将参数设定为void表示没有参数（当然为了方便，我们也可以直接什么都不写） 1234567891011#include &lt;stdio.h&gt;void test(void); //定义函数原型，因为C语言是从上往下的，所以如果要在下面的主函数中使用这个函数，一定要定义到它的上面。int main() &#123; &#125;void test(void)&#123; //函数具体定义，添加一个花括号并在其中编写程序代码，就和我们之前在main中编写一样 printf(&quot;我是测试函数!&quot;);&#125; 或是直接在上方写上函数的具体定义： 123456789#include &lt;stdio.h&gt;void test(void)&#123; //函数具体定义，添加一个花括号并在其中编写程序代码，就和我们之前在main中编写一样 printf(&quot;我是测试函数!&quot;);&#125;int main() &#123; &#125; 那么现在我们将函数定义好之后，该如何去使用呢？ 1234int main() &#123; test(); //这里我们只需要使用 函数名称(); 就可以调用函数了 printf(&quot;Hello World!&quot;); //实际上printf也是一个函数，功能是向控制台打印字符串，只不过这个函数是系统提供的，已经提前实现好了，其中的参数我们后续还会进行介绍。&#125; 这样，我们就可以很好解决上面的代码复用性的问题，我们只需要将会重复使用的逻辑代码定义到函数中，当我们需要执行时，直接调用编写好的函数就可以了，这样是不是简单多了？ 123456789101112int main() &#123; int a = 10; test(); //多次使用的情况下，函数会让我们的程序简单很多 if(a &gt; 20) test(); switch (a) &#123; case 30: test(); &#125;&#125; 当然函数除了可以实现代码的复用之外，也可以优化我们的程序，让我们的代码写得更有层次感，我们的程序可能会有很多很多的功能，需要写很多的代码，但是谁愿意去看一个几百行上千行的main函数呢？我们可以将每个功能都写到一个对应的函数中，这样就可以大大减少main函数中的代码量了。 12345int main() &#123; func1(); //直接把多行代码写到一个函数中，在main中调用对应的函数，这样能够大幅度减少代码量 func2(); func3();&#125; 而我们从一开始就在编写main函数实际上是一种比较特殊的函数，C语言规定程序一律从主函数开始执行，所以这也是为什么我们一定要写成int main()的形式。 全局变量和局部变量现在我们已经了解了如何创建和调用函数，在继续学习后续内容之前，我们需要先认识一下全局变量和局部变量这两个概念（啊这，变量就变量，还分这么细啊？） 我们首先来看看局部变量，实际上我们之前使用的都是局部变量，比如： 123int main() &#123; int i = 10; //这里定义的变量i实际上是main函数中的局部变量，它的作用域只能是main函数中，也就是说其他地方是无法使用的&#125; 局部变量只会在其作用域中生效： 可以看到在其他函数中，无法使用main函数中的变量，因为局部变量的作用域是有限的，比如位于某个函数内部的变量，那么它的作用域就是整个函数内部，而在其他位置均无法访问。又比如我们之前学习的for循环，当我们这样定义时： 可以看到，在for循环中定义的变量i，只能在for循环内部使用，而出了这个花括号之后就用不了了，当然由于作用域不同，所以下面这种写法是完全没问题的： 123456789int main() &#123; for (int i = 0; i &lt; 10; ++i) &#123; //虽然这里写了两个for都使用了i，但是由于处于两个不同的作用域，所以这两个i半毛钱关系都没有 &#125; for (int i = 0; i &lt; 20; ++i) &#123; &#125;&#125; 所以，清楚了局部变量的作用域之后，我们在编写程序的时候就很清楚了： 那么如果现在我们想要在任何位置都能使用一个变量，该怎么办呢？这时就要用到全局变量了： 123456789101112131415#include &lt;stdio.h&gt;void test();int a = 10; //我们可以直接将变量定义放在外面，这样所有的函数都可以访问了int main() &#123; a += 10; test(); //现在各位觉得，这两个操作完成后，a会是多少呢？ printf(&quot;%d&quot;, a);&#125;void test()&#123; a += 10;&#125; 因为现在所有函数都能使用全局变量，所以这个结果不难得到。 函数参数和返回我们的函数可以接受参数来完成任务，比如我们现在想要实现用一个函数计算两个数的和并输出到控制台。 这种情况我们就需要将我们需要进行加法计算的两个数，告诉函数，这样函数才能对这两个数求和，那么怎么才能告诉函数呢？我们可以通过设定参数： 1234567891011#include &lt;stdio.h&gt;void test(int, int); //函数原型中需要写上需要的参数类型，多个参数用逗号隔开，比如这里我们需要的就是两个int类型的参数int main() &#123;&#125;void test(int a, int b)&#123; //函数具体定义中也要写上，这里的a和b我们称为形式参数（形参），等价于函数中的局部变量，作用域仅限此函数 printf(&quot;%d&quot;, a + b);&#125; 那么现在定义完成了，该如何使用这个函数呢，还记得我们怎么使用printf函数的吗？我们只需要把它所需要的参数填入即可： 123int main() &#123; test(10, 20); //这里直接填写一个常量、变量或是运算表达式都是可以的，我们称实际传入的值为实际参数（实参）&#125; 可以看到，成功计算出结果： 实际上我们传入的实参在进入到函数时，会自动给函数中形参（局部变量）进行赋值，这样我们在函数中就可以得到外部传入的参数值了。 我们来看看printf函数是怎么写的： 1int printf(const char * __restrict, ...) __printflike(1, 2); //看起来比较高级 这里我们主要关心它的两个参数，一个是char *由于还没有学习指针，这里就把它当做const char[]就行了，表示一个不可修改的字符串，而第二个参数我们看到是...，这三个点是个啥？ 我们知道，如果我们想要填写具体需要打印的值时，可以一直往后写： 1printf(&quot;%d, %d&quot;, 1, 2); //参数可以一直写 正常情况下我们函数的参数列表都是固定的，怎么才能像这样写很多个呢？这就要用到可变长参数了，不过可变长参数的使用比较麻烦，这里我们就不做讲解了。 这里给大家提一个问题，如果我们修改形式参数的值，外面的实参值会跟着发生修改吗？ 12345678910111213141516#include &lt;stdio.h&gt;void swap(int, int);int main() &#123; int a = 10, b = 20; swap(a, b); printf(&quot;a = %d, b = %d&quot;, a, b); //最后会得到什么结果？&#125;void swap(int a, int b)&#123; int tmp = a; //这里对a和b的值进行交换 a = b; b = tmp;&#125; 通过结果发现，虽然调用了函数对a和b的值进行交换，但貌似并没有什么卵用。这是为什么呢？ 还记得我们前面说的吗，函数的形参实际上就是函数内的局部变量，它的作用域仅仅是这个函数，而我们外面传入的实参，仅仅知识将值赋值给了函数内的形参而已，并且外部的变量跟函数内部的变量作用域都不同，所以半毛钱关系都没有，这里交换的仅仅是函数内部的两个形参变量值，跟外部作实参的变量没有任何关系。 那么，怎么样才能实现通过函数交换两个变量的值呢？这个问题我们会在指针部分进行讨论。 不过数组却不受限制，我们在函数中修改数组的值，是直接可以生效的： 12345678910111213#include &lt;stdio.h&gt;void test(int arr[]);int main() &#123; int arr[] = &#123;4, 3, 8, 2, 1, 7, 5, 6, 9, 0&#125;; test(arr); printf(&quot;%d&quot;, arr[0]); //打印的是修改后的值了&#125;void test(int arr[]) &#123; arr[0] = 999; //数组就可以做到这边修改，外面生效&#125; 我们再来看一个例子： 123456789101112#include &lt;stdio.h&gt;void test(int a)&#123; a += 10; printf(&quot;%d\\n&quot;, a);&#125;int main() &#123; int a = 10; test(a); test(a); //连续两次调用，那么这两次的结果会是什么？&#125; 可以看到结果都是20，（如果猜对了可以直接跳过，如果你猜测的是20和30的话，需要听我解释了）注意每次调用函数都是单独进行的，并不是复用函数中的形参，不要认为第一次调用函数test就将函数的局部变量变成20了，再次调用就是20+10变成30。实际上这两次调用都是单独进行的，形参a都是在一开始的时候被赋值为实参的值的，这两次调用没有任何关系，并且函数执行完毕后就自动销毁了。 那要是我就希望每次调用函数时保留变量的值呢？我们可以使用静态变量： 1234567891011121314#include &lt;stdio.h&gt;void test();int main() &#123; test(); test();&#125;void test() &#123; static int a = 20; //静态变量并不会在函数结束时销毁其值，而是保持 a += 20; printf(&quot;%d &quot;, a);&#125; 我们接着来看函数的返回值，并不是所有的函数都是执行完毕就结束了的，可能某些时候我们需要函数告诉我们执行的结果如何，这时我们就需要用到返回值了，比如现在我们希望实现一个函数计算a+b的值： 12345678910111213#include &lt;stdio.h&gt;int sum(int ,int ); //现在我们要返回a和b的和（那么肯定也是int类型）所以这里需要将返回值类型修改为intint main() &#123; int a = 10, b = 20; //计算a和b的和 int result = sum(a, b); //函数执行后，会返回一个int类型的结果，我们可以接收它，也可以像下面一样直接打印，当然也可以参与运算等等。 printf(&quot;a+b=%d&quot;, sum(a, b));&#125;int sum(int a, int b) &#123; return a + b; //通过return关键字来返回计算的结果&#125; 我们接着来看下一个例子，现在我们希望你通过函数找到数组中第一个小于0的数字并将其返回，如果没有找到任何小于0的数，就返回0即可： 12345678910111213141516#include &lt;stdio.h&gt;int findMin(int arr[], int len); //需要两个参数，一个是数组本身，还有一个是数组的长度int main() &#123; int arr[] = &#123;1, 4, -9, 2, -4, 7&#125;; int min = findMin(arr, 6); printf(&quot;第一个小于0的数是：%d&quot;, min);&#125;int findMin(int arr[], int len) &#123; for (int i = 0; i &lt; len; ++i) &#123; if(arr[i] &lt; 0) return arr[i]; //当判断找到后，直接return返回即可，这样的话函数会直接返回结果，无论后面还有没有代码没有执行完，整个函数都会直接结束。 &#125; return 0; //如果没有找到就返回0&#125; 这里我们使用了return关键字来返回结果，注意当我们的程序走到return时，无论还有什么内容没执行完，整个函数都将结束，并返回结果。注意带返回值（非void）的函数中的所有情况都需要有一个对应的返回值： 1234567int test(int a) &#123; if (a &gt; 0) &#123; return 10; //当a大于0时有返回语句 &#125; else&#123; //但是当a不大于0时就没有返回值了，这样虽然可以编译通过，但是会有警告（黄标），运行后可能会出现一些无法预知的问题 &#125;&#125; 如果是没有返回值的函数，我们也可以调用return来返回，不过默认情况下是可以省略的： 1234void test(int a)&#123; if(a == 10) return; //因为是void，所以什么都不需要加，直接return printf(&quot;%d&quot;, a);&#125; 递归调用我们的函数除了在其他地方被调用之外，也可以自己调用自己（好家伙，套娃是吧），这种玩法我们称为递归。 12345678910#include &lt;stdio.h&gt;void test()&#123; printf(&quot;Hello World!\\n&quot;); test(); //函数自己在调用自己，这样的话下一轮又会进入到这个函数中&#125;int main() &#123; test();&#125; 我们可以尝试运行一下上面的程序，会发现程序直接无限打印Hello World!这个字符串，这是因为函数自己在调用自己，不断地重复进入到这个函数，理论情况下，它将永远都不会结束，而是无限地执行这个函数的内容。 但是到最后我们的程序还是终止了，这是因为函数调用有最大的深度限制，因为计算机不可能放任函数无限地进行下去。 （选学）我们来大致了解一下函数的调用过程，实际上在程序运行时会有一个叫做函数调用栈的东西，它用于控制函数的调用： 123456789101112131415#include &lt;stdio.h&gt; //我们以下面的调用关系为例void test2()&#123; printf(&quot;giao&quot;);&#125;void test()&#123; test2(); //main -&gt; test -&gt; test2 printf(&quot;giao&quot;);&#125;int main() &#123; test(); printf(&quot;giao&quot;);&#125; 其实我们可以很轻易地看出整个调用关系，首先是从main函数进入，然后调用test函数，在test函数中又调用了test2函数，此时我们就需要等待test2函数执行完毕，test才能继续，而main则需要等待test执行完毕才能继续。而实际上这个过程是由函数调用栈在控制的： 而当test2函数执行完毕后，每个栈帧又依次从栈中出去： 当所有的栈全部出去之后，程序结束。 所以这也就不难解释为什么无限递归会导致程序出现错误，因为栈的空间有限，而函数又一直在进行自我调用，所以会导致不断地有新的栈帧进入，最后塞满整个栈的空间，就爆炸了，这种问题我们称为栈溢出（Stack Overflow） 当然，如果我们好好地按照规范使用递归操作，是非常方便的，比如我们现在需要求某个数的阶乘： 123456789101112#include &lt;stdio.h&gt;int test(int n);int main() &#123; printf(&quot;%d&quot;, test(3));&#125;int test(int n)&#123; if(n == 1) return 1; //因为不能无限制递归下去，所以我们这里添加一个结束条件，在n = 1时返回 return test(n - 1) * n; //每次都让n乘以其下一级的计算结果，下一级就是n-1了&#125; 通过给递归调用适当地添加结束条件，这样就不会无限循环了，并且我们的程序看起来无比简洁，那么它是如何执行的呢： 它看起来就像是一个先走到底部，然后拿到问题的钥匙后逐步返回的一个过程，并在返回的途中不断进行计算最后得到结果（妙啊） 所以，合理地使用递归反而是一件很有意思的事情。 实战：斐波那契数列解法其三前面我们介绍了函数的递归调用，我们来看一个具体的实例吧，我们还是以解斐波那契数列为例。 既然每个数都是前两个数之和，那么我们是否也可以通过递归的形式不断划分进行计算呢？我们依然可以借鉴之前动态规划的思想，通过划分子问题，分而治之来完成计算。 实战：汉诺塔什么是汉诺塔？ 汉诺塔（Tower of Hanoi），又称河内塔，是一个源于印度古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始 按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。 这三根柱子我们就依次命名为A、B、C，现在请你设计一个C语言程序，计算N阶（n片圆盘）汉诺塔移动操作的每一步。 这个问题看似很难，实际上我们也可以对每一步进行推理： 当汉诺塔只有1阶的情况下：直接把A上的圆盘移动到C，搞定。 当汉诺塔只有2阶的情况下：我们的最终目标还是需要将A柱最下面的圆盘丢到C，不过现在多了圆盘，我们得先把这个圆盘给处理了，所以我们得把这上面的1个圆盘丢到B上去，这样才能把A最下面的圆盘丢给C。然后再把B上面的1个圆盘丢到C上去 当汉诺塔只有3阶的情况下：我们的最终目标还是需要将A柱最下面的圆盘丢到C，不过现在多了圆盘，我们得先把这个圆盘给处理了，所以我们得把这上面的2个圆盘丢到B上去，这样才能把A最下面的圆盘丢给C。然后再把B上面的2个圆盘丢到C上 实际上我们发现，把A移动到C是一定要进行的，而在进行之前需要先把压在上面全部的圆盘全部放到B去。而移动之后也要把B上的圆盘全部移动到C上去。其实所有的情况下最终都会有一个n&#x3D;1的情况，将A上的最后一个圆盘移动到C，只是多了一个前面的步骤和后面的步骤。 不过难点就是，怎么把A上的n-1个圆盘移动到B去呢？其实这时我们可以依靠C作为中间商，来帮助我们移动（比如n &#x3D; 3，那么先把最上面的移动到C，然后把第二大的移动到B，再从C上把最小的移动到B上，这样就借助了C完成了两个圆盘的转移），而最后又怎么把B上的圆盘全部移到C去呢，这时就可以依靠A作为中间商，方法同理；实际上大问题最后都会变成n &#x3D; 2时这样的小问题，只不过是要移动目标不同罢了。 只要想通了怎么去借助中间商进行移动，就很好写出程序了。 递归函数如下设计： 1234//a存放圆盘的初始柱子，b作为中间柱子存放使用，c作为目标柱子，n表示要从a移动到c的圆盘数void hanoi(char a, char b, char c, int n)&#123; &#125; 现在我们来实现一下吧。 12345678910111213void move(char start, char end, int n)&#123; //用于打印移动操作到控制台，start是起始柱子，end是结束柱子，n是哪一个圆盘 printf(&quot;第%d个圆盘：%c --&gt; %c\\n&quot;, n, start, end);&#125;void hanoi(char a, char b, char c, int n)&#123; //刚进来的时候，B作为中间柱子，C作为目标柱子，要移动A上的n个圆盘到C去 if(n == 1) &#123; move(a, c, n); //无论a,b,c如何变换，通过递归，最后都会变成一个n = 1的问题，直接移动就完事了 &#125; else&#123; hanoi(a, c ,b, n - 1); //首要目标是先把上面n-1个圆盘全部放到B去，这里就变换一下，让B作为目标柱子，C作为中间 move(a, c, n); //现在A上只剩下一个最大的圆盘了，接着把A最下方的一个圆盘移到C去 hanoi(b, a, c, n - 1); //最后需要把B上的全部搬到C上去，这里就可以以C为目标柱子，A为中间柱子 &#125;&#125; 简化一波： 123456void hanoi(char a, char b, char c, int n)&#123; if(n == 0) return; hanoi(a, c ,b, n - 1); printf(&quot;第%d个圆盘：%c --&gt; %c\\n&quot;, n, a, c); hanoi(b, a, c, n - 1);&#125; 看似如此复杂的问题，其实只需要4行就可以解决了。 实战：快速排序算法（选学）有一个数组： 1int arr[] = &#123;4, 3, 8, 2, 1, 7, 5, 6, 9, 0&#125;; 现在请你设计一个C语言程序，对数组按照从小到大的顺序进行排序。这里我们使用冒泡排序的进阶版本——快速排序来完成，它的核心思想是分而治之，每一轮排序都会选出一个基准，一轮排序完成后，所以比基准小的数一定在左边，比基准大的数一定在右边，在分别通过同样的方法对左右两边的数组进行排序，不断划分，最后完成整个数组的排序。它的效率相比冒泡排序的双重for循环有所提升。 12345678910111213#include &lt;stdio.h&gt;void quickSort(int arr[], int left, int right)&#123; //arr是数组，left是起始下标，right是结束下标 //请实现这一部分&#125;int main() &#123; int arr[] = &#123;4, 3, 8, 2, 1, 7, 5, 6, 9, 0&#125;; quickSort(arr, 0, 9); //10个数字下标就是0-9 for (int i = 0; i &lt; 10; ++i) &#123; printf(&quot;%d &quot;, arr[i]); &#125;&#125; 不过虽然这种排序算法很快，但是极端情况下（比如遇到了刚好倒序的数组）还是会退化成冒泡排序的。 指针指针可以说是整个C语言中最难以理解的部分了，不过其实说简单也简单，你会发现也并没有想象中的那么难，你与它的距离可能只差了那么一些基础知识，这一部分都会及时进行补充的。 什么是指针还记得我们在上一个部分谈到的通过函数交换两个变量的值吗？ 12345678910111213141516#include &lt;stdio.h&gt;void swap(int, int);int main() &#123; int a = 10, b = 20; swap(a, b); printf(&quot;a = %d, b = %d&quot;, a, b); //最后会得到什么结果？&#125;void swap(int a, int b)&#123; int tmp = a; //这里对a和b的值进行交换 a = b; b = tmp;&#125; 实际上这种写法是错误的，因为交换的并非是真正的a和b，而是函数中的局部变量。那么有没有办法能够直接对函数外部的变量进行操作呢？这就需要指针的帮助了。 我们知道，程序中使用的变量实际上都在内存中创建的，每个变量都会被保存在内存的某一个位置上（具体在哪个位置是由系统分配的），就像我们最终会在这个世界上的某个角落安家一样，所有的变量在对应的内存位置上都有一个地址（地址是独一无二的），而我们可以通过这个地址寻找到这个变量本体，比如int占据4字节，因此int类型变量的地址就是这4个字节的起始地址，后面32个bit位全部都是用于存放此变量的值的。 这里的0x是十六进制的表示形式（10-15用字母A - F表示）如果我们能够知道变量的内存地址，那么无论身在何处，都可以通过地址找到这个变量了。而指针的作用，就是专门用来保存这个内存地址的。 我们来看看如何创建一个指针变量用于保存变量的内存地址： 12345678#include &lt;stdio.h&gt;int main()&#123; int a = 10; //指针类型需要与变量的类型相同，且后面需要添加一个*符号（注意这里不是乘法运算）表示是对于类型的指针 int * p = &amp;a; //这里的&amp;并不是进行按位与运算，而是取地址操作，也就是拿到变量a的地址 printf(&quot;a在内存中的地址为：%p&quot;, p); //地址使用%p表示&#125; 可以看到，我们通过取地址操作&amp;，将变量a的地址保存到了一个地址变量p中。 拿到指针之后，我们可以很轻松地获取指针所指地址上的值： 1234567#include &lt;stdio.h&gt;int main()&#123; int a = 666; int * p = &amp;a; printf(&quot;内存%p上存储的值为：%d&quot;, p, *p); //我们可以在指针变量前添加一个*号（间接运算符，也可以叫做解引用运算符）来获取对应地址存储的值&#125; 注意这里访问指针所指向地址的值时，是根据类型来获取的，比如int类型占据4个字节，那么就读取地址后面4个字节的内容作为一个int值，如果指针是char类型的，那么就只读取地址后面1个字节作为char类型的值。 同样的，我们也可以直接像这样去修改对应地址存放的值： 12345678910#include &lt;stdio.h&gt;int main()&#123; int a = 666; int * p = &amp;a; *p = 999; //通过*来访问对应地址的值，并通过赋值运算对其进行修改 printf(&quot;a的值为：%d&quot;, a);&#125; 实际上拿到一个变量的地址之后，我们完全不需要再使用这个变量，而是可以通过它的指针来对其进行各种修改。因此，现在我们想要实现对两个变量的值进行交换的函数就很简单了： 12345678910111213141516#include &lt;stdio.h&gt;// 这里是两个指针类型的形参，其值为实参传入的地址，// 虽然依然是值传递，但是这里传递的可是地址啊，// 只要知道地址改变量还不是轻轻松松？void swap(int * a, int * b)&#123; int tmp = *a; //先暂存一下变量a地址上的值 *a = *b; //将变量b地址上的值赋值给变量a对应的位置 *b = tmp; //最后将a的值赋值给b对应位置，OK，这样就成功交换两个变量的值了&#125;int main()&#123; int a = 10, b = 20; swap(&amp;a, &amp;b); //只需要把a和b的内存地址给过去就行了，这里取一下地址 printf(&quot;a = %d, b = %d&quot;, a, b);&#125; 通过地址操作，我们就轻松实现了使用函数交换两个变量的值了。 了解了指针的相关操作之后，我们再来看看scanf函数，实际上就很好理解了： 1234567#include &lt;stdio.h&gt;int main()&#123; int a; scanf(&quot;%d&quot;, &amp;a); //这里就是取地址，我们需要告诉scanf函数变量的地址，这样它才能通过指针访问变量的内存地址，对我们变量的值进行修改，这也是为什么scanf里面的变量（除数组外）前面都要进行一个取地址操作 printf(&quot;%d&quot;, a);&#125; 当然，和变量一样，要是咱们不给指针变量赋初始值的话，就不知道指的哪里了，因为指针变量也是变量，存放的其他变量的地址值也在内存中保存，如果不给初始值，那么存放别人地址的这块内存可能在其他地方使用过，这样就不知道初始值是多少了（那么指向的地址可能是一个很危险的地址，随意使用可能导致会出现严重错误），所以一定要记得给个初始值或是将其设定为NULL，表示空指针，不指向任何内容。 12345#include &lt;stdio.h&gt;int main()&#123; int * a = NULL;&#125; 我们接着来看看const类型的指针，这种指针比较特殊： 12345678#include &lt;stdio.h&gt;int main()&#123; int a = 9, b = 10; const int * p = &amp;a; *p = 20; //这里直接报错，因为被const标记的指针，所指地址上的值不允许发生修改 p = &amp;b; //但是指针指向的地址是可以发生改变的&#125; 我们再来看另一种情况： 12345678#include &lt;stdio.h&gt;int main()&#123; int a = 9, b = 10; int * const p = &amp;a; //const关键字被放在了类型后面 *p = 20; //允许修改所指地址上的值 p = &amp;b; //但是不允许修改指针存储的地址值，其实就是反过来了。&#125; 当然也可以双管齐下： 12345678#include &lt;stdio.h&gt;int main()&#123; int a = 9, b = 10; const int * const p = &amp;a; *p = 20; //两个都直接报错，都不让改了 p = &amp;b;&#125; 指针与数组前面我们介绍了指针的基本使用，我们来回顾一个问题，为什么数组可以以原身在函数之间进行传递呢？先说结论，数组表示法实际上是在变相地使用指针，你甚至可以将其理解为数组变量其实就是一个指针变量，它存放的就是数组中第一个元素的起始地址。 为什么这么说？ 12345678#include &lt;stdio.h&gt;int main()&#123; char str[] = &quot;Hello World!&quot;; char * p = str; //？？？啥情况，为什么能直接把数组作为地址赋值给指针变量p？？？ printf(&quot;%c&quot;, *p); //还能正常使用，打印出第一个字符？？？&#125; 你以为这就完了？还能这样玩呢： 123456int main()&#123; char str[] = &quot;Hello World!&quot;; char * p = str; printf(&quot;%c&quot;, p[1]); //？？？怎么像在使用数组一样用指针？？？&#125; 太迷了吧，怎么数组和指针还能这样混着用呢？我们先来看看数组在内存中是如何存放的： 数组在内存中是一块连续的空间，所以为什么声明数组一定要明确类型和大小，因为这一块连续的内存空间生成后就固定了。 而我们的数组变量实际上存放的就是首元素的地址，而实际上我们之前一直使用的都是数组表示法来操作数组，这样可以很方便地让我们对内存中的各个元素值进行操作： 1234int main()&#123; char str[] = &quot;Hello World!&quot;; printf(&quot;%c&quot;, str[0]); //直接在中括号中输入对应的下标就能访问对应位置上的数组了&#125; 而我们知道实际上str表示的就是数组的首地址，所以我们完全可以将其赋值给一个指针变量，因为指针变量也是存放的地址： 12char str[] = &quot;Hello World!&quot;;char * p = str; //直接把str代表的首元素地址给到p 而使用指针后，实际上我们可以使用另一种表示法来操作数组，这种表示法叫做指针表示法： 12345int main()&#123; char str[] = &quot;Hello World!&quot;; char * p = str; printf(&quot;第一个元素值为：%c，第二个元素值为：%c&quot;, *p, *(p+1)); //通过指针也可以表示对应位置上的值&#125; 比如我们现在需要表示数组中的第二个元素： 数组表示法：str[1] 指针表示法：*(p+1) 虽然写法不同，但是他们表示的意义是完全相同的，都代表了数组中的第二个元素，其中指针表示法使用了p+1的形式表示第二个元素，这里的+1操作并不是让地址+1，而是让地址+ 一倍的对应类型大小，也就是说地址后移一个char的长度，所以正好指向了第二个元素，然后通过*取到对应的值（注意这种操作仅对数组是有意义的，如果是普通的变量，虽然也可以通过这种方式获得后一个char的长度的数据，但是毫无意义） 1*(p+i) &lt;=&gt; str[i] //实际上就是可以相互转换的 这两种表示法都可以对内存中存放的数组内容进行操作，只是写法不同罢了，所以你会看到数组和指针混用也就不奇怪了。了解了这些东西之后，我们来看看下面的各个表达式分别代表什么： 12345678*p //数组的第一个元素p //数组的第一个元素的地址p == str //肯定是真，因为都是数组首元素地址*str //因为str就是首元素的地址，所以这里对地址加*就代表第一个元素，使用的是指针表示法&amp;str[0] //这里得到的实际上还是首元素的地址*(p + 1) //代表第二个元素p + 1 //第二个元素的内存地址*p + 1 //注意*的优先级比+要高，所以这里代表的是首元素的值+1，得到字符&#x27;K&#x27; 所以不难理解，为什么printf函数的参数是一个const char * 了，实际上就是需要我们传入一个字符串而已，只不过这里采用的是指针表示法而已。 当然指针也可以进行自增和自减操作，比如： 12345678910#include &lt;stdio.h&gt;int main()&#123; char str[] = &quot;Hello World!&quot;; char * p = str; p++; //自增后相当于指针指向了第二个元素的地址 printf(&quot;%c&quot;, *p); //所以这里打印的就是第二个元素的值了&#125; 一维数组看完了，我们来看看二维数组，那么二维数组在内存中是如何表示的呢？ 1int arr[2][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;; 这是一个2x3的二维数组，其中存放了两个能够容纳三个元素的数组，在内存中，是这样的： 所以虽然我们可以使用二维数组的语法来访问这些元素，但其实我们也可以使用指针来进行访问： 12345678#include &lt;stdio.h&gt;int main()&#123; int arr[][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;; int * p = arr[0]; //因为是二维数组，注意这里要指向第一个元素，来降一个维度才能正确给到指针 //同理如果这里是arr[1]的话那么就表示指向二维数组中第二个数组的首元素 printf(&quot;%d = %d&quot;, *(p + 4), arr[1][1]); //实际上这两种访问形式都是一样的&#125; 多级指针我们知道，实际上指针本身也是一个变量，它存放的是目标的地址，但是它本身作为一个变量，它也要将地址信息保存到内存中，所以，实际上当我们有指针之后： 实际上，我们我们还可以继续创建一个指向指针变量地址的指针，甚至可以创建更多级（比如指向指针的指针的指针）比如现在我们要创建一个指向指针的指针： 落实到咱们的代码中： 123456789#include &lt;stdio.h&gt;int main()&#123; int a = 20; int * p = &amp;a; //指向普通变量的指针 //因为现在要指向一个int *类型的变量，所以类型为int* 再加一个* int ** pp = &amp;p; //指向指针的指针（二级指针） int *** ppp = &amp;pp; //指向指针的指针的指针（三级指针）&#125; 那么我们如何访问对应地址上的值呢？ 123456789#include &lt;stdio.h&gt;int main()&#123; int a = 20; int * p = &amp;a; int ** pp = &amp;p; printf(&quot;p = %p, a = %d&quot;, *pp, **pp); //使用一次*表示二级指针指向的指针变量，继续使用一次*会继续解析成指针变量所指的普通变量&#125; 本质其实就是一个套娃而已，只要把各个层次分清楚，实际上还是很好理解的。 特别提醒：一级指针可以操作一维数组，那么二级指针是否可以操作二维数组呢？不能！因为二级指针的含义都不一样了，它是表示指针的指针，而不是表示某个元素的指针了。下面我们会认识数组指针，准确的说它才更贴近于二维数组的形式。 指针数组与数组指针前面我们了解了指针的一些基本操作，包括它与数组的一些关系。我们接着来看指针数组和数组指针，这两词语看着就容易搞混，不过哪个词在后面就哪个，我们先来看指针数组，虽然名字很像数组指针，但是它本质上是一个数组，不过这个数组是用于存放指针的数组。 123456#include &lt;stdio.h&gt;int main()&#123; int a, b, c; int * arr[3] = &#123;&amp;a, &amp;b, &amp;c&#125;; //可以看到，实际上本质还是数组，只不过存的都是地址&#125; 因为这个数组中全都是指针，比如现在我们想要访问数组中第一个指针指向的地址： 123456789#include &lt;stdio.h&gt;int main()&#123; int a, b, c; int * arr[3] = &#123;&amp;a, &amp;b, &amp;c&#125;; *arr[0] = 999; //[]运算符的优先级更高，所以这里先通过[0]取出地址，然后再使用*将值赋值到对应的地址上 printf(&quot;%d&quot;, a);&#125; 当然我们也可以用二级指针变量来得到指针数组的首元素地址： 123456#include &lt;stdio.h&gt;int main()&#123; int * p[3]; //因为数组内全是指针 int ** pp = p; //所以可以直接使用指向指针的指针来指向数组中的第一个指针元素&#125; 实际上指针数组还是很好理解的，那么数组指针呢？可以看到指针在后，说明本质是一个指针，不过这个指针比较特殊，它是一个指向数组的指针（注意它的目标是整个数组，和我们之前认识的指针不同，之前认识的指针是指向某种类型变量的指针） 比如： 1int * p; //指向int类型的指针 而数组指针则表示指向整个数组： 1int (*p)[3]; //注意这里需要将*p括起来，因为[]的优先级更高 注意它的目标是整个数组，而不是普通的指针那样指向的是数组的首个元素： 12int arr[3] = &#123;111, 222, 333&#125;;int (*p)[3] = &amp;arr; //直接对整个数组再取一次地址（因为数组指针代表的是整个数组的地址，虽然和普通指针都是指向首元素地址，但是意义不同） 那么现在已经取到了指向整个数组的指针，该怎么去使用呢？ 12345678#include &lt;stdio.h&gt;int main()&#123; int arr[3] = &#123;111, 222, 333&#125;; int (*p)[3] = &amp;arr; //直接对整个数组再取一次地址 printf(&quot;%d, %d, %d&quot;, *(*p+0), *(*p+1), *(*p+2)); //要获取数组中的每个元素，稍微有点麻烦&#125; 注意此时： p代表整个数组的地址 *p表示所指向数组中首元素的地址 *p+i表示所指向数组中第i个（0开始）元素的地址（实际上这里的*p就是指向首元素的指针） *(*p + i)就是取对应地址上的值了 虽然在处理一维数组上感觉有点麻烦，但是它同样也可以处理二维数组： 12int arr[][3] = &#123;&#123;111, 222, 333&#125;, &#123;444, 555, 666&#125;&#125;;int (*p)[3] = arr; //二维数组不需要再取地址了，因为现在维度提升，数组指针指向的是二维数组中的其中一个元素（因为元素本身就是一个数组） 比如现在我们想要访问第一个数组的第二个元素，根据上面p各种情况下的意义： 1printf(&quot;%d&quot;, *(*p+1)); //因为上面直接指向的就是第一个数组，所以想要获取第一个元素和之前是一模一样的 那么要是我们现在想要获取第二个数组中的最后一个元素呢？ 1printf(&quot;%d&quot;, *(*(p+1)+2); //首先*(p+1)为一个整体，表示第二个数组（因为是数组指针，所以这里+1一次性跳一个数组的长度），然后再到外层+2表示数组中的第三个元素，最后再取地址，就是第二个数组的第三个元素了 当然也可以使用数组表示法： 1printf(&quot;%d&quot;, p[1][2]); //好家伙，这不就是二维数组的用法吗，没错，看似很难，你甚至可以认为这两用着是同一个东西 指针函数与函数指针我们的函数可以返回一个指针类型的结果，这种函数我们就称为指针函数。 123456789101112#include &lt;stdio.h&gt;int * test(int * a)&#123; //函数的返回值类型是int *指针类型的 return a;&#125;int main()&#123; int a = 10; int * p = test(&amp;a); //使用指针去接受函数的返回值 printf(&quot;%d&quot;, *p); printf(&quot;%d&quot;, *test(&amp;a)); //当然也可以直接把间接运算符在函数调用前面表示直接对返回的地址取地址上的值&#125; 不过要注意指针函数不要尝试去返回一个局部变量的地址： 12345678910111213#include &lt;stdio.h&gt;int * test(int a)&#123; int i = a; return &amp;i; //返回局部变量i的地址&#125;int main()&#123; int * p = test(20); //连续调用两次test函数 test(30); printf(&quot;%d&quot;, *p); //最后结果可能并不是我们想的那样&#125; 为什么会这样呢？还记得我们前面说的吗？函数一旦返回，那么其中的局部变量就会全部销毁了，至于这段内存之后又会被怎么去使用，我们也就不得而知了。 局部变量其实是存放在栈帧中的，如果前面的选学部分听了之后，你就知道为什么这里得到的是第二次的30了，因为第二次调用的栈帧入栈后就覆盖了这段内存，又因为是同一个函数所以栈帧结构是一样的，最后在同样的位置就存放了新的30这个值。 我们接着来看函数指针，实际上指针除了指向一个变量之外，也可以指向一个函数，当然函数指针本身还是一个指针，所以依然是用变量表示，但是它代表的是一个函数的地址（编译时系统会为函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址） 我们来看看如何定义： 1234567891011#include &lt;stdio.h&gt;int sum(int a, int b) &#123; return a + b;&#125;int main()&#123; //类型 (*指针变量名称)(函数参数...) //注意一定要把*和指针变量名称括起来，不然优先级不够 int (*p)(int, int) = sum; printf(&quot;%p&quot;, p);&#125; 这样我们就拿到了函数的地址，既然拿到函数的地址，那么我们就可以通过函数的指针调用这个函数了： 12345678910111213#include &lt;stdio.h&gt;int sum(int a, int b) &#123; return a + b;&#125;int main()&#123; int (*p)(int, int) = sum; int result = (*p)(1, 2); //就像我们正常使用函数那样，(*p)表示这个函数，后面依然是在小括号里面填上实参 int result = p(1, 2); //当然也可以直接写函数指针变量名称，效果一样（咋感觉就是给函数换了个名呢） printf(&quot;%d&quot;, result);&#125; 有了函数指针，我们就可以编写函数回调了（所谓回调就让别人去调用我们提供的函数，而不是我们主动来调别人的函数），比如现在我们定义了一个函数，不过这个函数需要参数通过一个处理的逻辑才能正常运行： 1234int sum(int (*p)(int, int), int a, int b)&#123; //将函数指针作为参数传入 //函数回调 return p(a, b); //就像你进了公司然后花钱请别人帮你写代码，工资咱们五五开，属于是直接让别人帮你实现&#125; 于是我们就还要给他一个其他函数的地址： 1234567891011121314#include &lt;stdio.h&gt;int sum(int (*p)(int, int), int a, int b)&#123; return p(a, b);&#125;int sumImpl(int a, int b)&#123; //这个函数实现了a + b return a + b;&#125;int main()&#123; int (*p)(int, int) = sumImpl; //拿到实现那个函数的地址 printf(&quot;%d&quot;, sum(p, 10, 20)); &#125; 当然，函数指针也可以保存一组函数的地址，成为函数指针数组，但是这里就不多说了，相信各位已经快顶不住了吧。 实战：合并两个有序数组来源：力扣 No.88 合并两个有序数组：https://leetcode.cn/problems/merge-sorted-array/ 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2： 输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0输出：[1]解释：需要合并 [1] 和 [] 。合并结果是 [1] 。 示例 3： 输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1输出：[1]解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 现在请你设计一个C语言程序，实现下面的函数（要求全程使用指针，不允许出现数组用法）： 123void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)&#123;&#125; 实战：二维数组中的查找来源：剑指Offer 04. 二维数组中的查找：https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/ 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [[1, 4, 7, 11, 15],[2, 5, 8, 12, 19],[3, 6, 9, 16, 22],[10, 13, 14, 17, 24],[18, 21, 23, 26, 30]] 给定 target &#x3D; 5，返回 true。 给定 target &#x3D; 20，返回 false。 现在请你设计一个C语言程序，实现下面的函数（要求全程使用指针，不允许出现数组用法）： 1234567/* * 输入 **matrix 是长度为 matrixSize 的数组指针的数组，其中每个元素（也是一个数组） * 的长度组成 *matrixColSize 数组作为另一输入，*matrixColSize 数组的长度也为 matrixSize */bool findNumberIn2DArray(int** matrix, int matrixSize, int* matrixColSize, int target)&#123;&#125; 结构体、联合体和枚举终于熬过了最难的一个部分，后面的内容就相对简单多了，我们接着来看结构体。 我们之前认识过很多种数据类型，包括整数、小数、字符、数组等，通过使用对应的数据类型，我们就可以很轻松地将我们的数据进行保存了，但是有些时候，这种简单类型很难去表示一些复杂结构。 创建和使用结构体比如现在我们要保存100个学生的信息（学生信息包括学号、姓名、年龄）我们发现似乎找不到一种数据类型能够同时保存这三种数据（数组虽然能保存一些列的元素，但是只能保存同种类型的）。但是如果把它们拆开单独存在，就可以使用对应的类型存放了，不过这样也太不方便了吧，这些数据应该是捆绑在一起的，而不是单独地去存放。所以，为了解决这种问题，C语言提供了结构体类型，它能够将多种类型的数据集结到一起，让他们形成一个整体。 12345struct Student &#123; //使用 (struct关键字 + 结构体类型名称) 来声明结构体类型，这种类型是我们自己创建的（同样也可以作为函数的参数、返回值之类的） int id; //结构体中可以包含多个不同类型的数据，这些数据共同组成了整个结构体类型（当然结构体内部也能包含结构体类型的变量） int age; char * name; //用户名可以用指针指向一个字符串，也可以用char数组来存，如果是指针的话，那么数据不会存在结构体中，只会存放字符串的地址，但是如果是数组的话，数据会存放在结构体中&#125;; 12345int main() &#123; struct Student &#123; //也可以以局部形式存在 &#125;;&#125; 定义好结构体后，我们只需要使用结构体名称作为类型就可以创建一个结构体变量了： 123456789101112#include &lt;stdio.h&gt;struct Student &#123; int id; int age; char * name;&#125;;int main() &#123; //类型需要写为struct Student，后面就是变量名称 struct Student s = &#123;1, 18, &quot;小明&quot;&#125;; //结构体包含多种类型的数据（它们是一个整体），只需要把这些数据依次写好放在花括号里面就行了&#125; 12345struct Student &#123; int id; int age; char * name;&#125; s; //也可以直接在花括号后面写上变量名称（多个用逗号隔开），声明一个全局变量 这样我们就创建好了一个结构体变量，而这个结构体表示的就是学号为1、年龄18、名称为小明的结构体数据了。 当然，结构体的初始化需要注意： 12struct Student s = &#123;1, 18&#125;; //如果只写一半，那么只会初始化其中一部分数据，剩余的内容相当于没有初始值，跟数组是一样的struct Student s = &#123;1, .name = &quot;小红&quot;&#125;; //也可以指定去初始化哪一个属性 .变量名称 = 初始值 那么现在我们拿到结构体变量之后，怎么去访问结构体内部存储的各种数据呢？ 1printf(&quot;id = %d, age = %d, name = %s&quot;, s.id, s.age, s.name); //结构体变量.数据名称 (这里.也是一种运算符) 就可以访问结构体中存放的对应的数据了 是不是很简单？当然我们也可以通过同样的方式对结构体中的数据进行修改： 12345678int main() &#123; struct Student s = &#123;1, 18, &quot;小明&quot;&#125;; s.name = &quot;小红&quot;; s.age = 17; printf(&quot;id = %d, age = %d, name = %s&quot;, s.id, s.age, s.name);&#125; 那么结构体在内存中占据的大小是如何计算的呢？比如下面的这个结构体 12345struct Object &#123; int a; short b; char c;&#125;; 这里我们可以借助sizeof关键字来帮助我们计算： 123int main() &#123; printf(&quot;int类型的大小是：%lu&quot;, sizeof(int)); //sizeof能够计算数据在内存中所占据的空间大小（字节为单位）&#125; 当然也可以计算变量的值占据的大小： 1234int main() &#123; int arr[10]; printf(&quot;int arr[10]占据的大小是：%lu&quot;, sizeof (arr)); //在判断非类型时，sizeof 括号可省&#125; 同样的，它也能计算我们的结构体类型会占用多少的空间： 1234567891011#include &lt;stdio.h&gt;struct Object &#123; char a; int b; short c;&#125;;int main() &#123; printf(&quot;%lu&quot;, sizeof(struct Object)); //直接填入struct Object作为类型&#125; 可以看到结果是8，那么，这个8字节是咋算出来的呢？ int（4字节）+ short（2字节）+ char（1字节） &#x3D; 7字节（这咋看都算不出来12啊？） 实际上结构体的大小是遵循下面的规则来进行计算的： 结构体中的各个数据要求字节对齐，规则如下： 规则一：结构体中元素按照定义顺序依次置于内存中，但并不是紧密排列的。从结构体首地址开始依次将元素放入内存时，元素会被放置在其自身对齐大小的整数倍地址上（0默认是所有大小的整数倍） 规则二：如果结构体大小不是所有元素中最大对齐大小的整数倍，则结构体对齐到最大元素对齐大小的整数倍，填充空间放置到结构体末尾。 规则三：基本数据类型的对齐大小为其自身的大小，结构体数据类型的对齐大小为其元素中最大对齐大小元素的对齐大小。 这里我们以下面的为例： 12345struct Object &#123; char a; //char占据1个字节 int b; //int占据4个字节，因为前面存了一个char，按理说应该从第2个字节开始存放，但是根据规则一，必须在自己的整数倍位置上存放，所以2不是4的整数倍位置，这时离1最近的下一个整数倍地址就是4了，所以前面空3个字节的位置出来，然后再放置 short c; //前面存完int之后，就是从8开始了，刚好满足short（2字节）的整数倍，但是根据规则二，整个结构体大小必须是最大对齐大小的整数倍（这里最大对齐大小是int，所以是4），存完short之后，只有10个字节，所以屁股后面再补两个空字节，这样就可以了&#125;; 这样，就不难得出为什么结构体的大小是12了。 结构体数组和指针前面我们介绍了结构体，现在我们可以将各种类型的数据全部安排到结构体中一起存放了。 不过仅仅只是使用结构体，还不够，我们可能需要保存很多个学生的信息，所以我们需要使用结构体类型的数组来进行保存： 12345678910111213#include &lt;stdio.h&gt;struct Student &#123; int id; int age; char * name;&#125;;int main() &#123; struct Student arr[3] = &#123;&#123;1, 18, &quot;小明&quot;&#125;, //声明一个结构体类型的数组，其实和基本类型声明数组是一样的 &#123;2, 17, &quot;小红&quot;&#125;, //多个结构体数据用逗号隔开 &#123;3, 18, &quot;小刚&quot;&#125;&#125;;&#125; 那么现在如果我们想要访问数组中第二个结构体的名称属性，该怎么做呢？ 1234567int main() &#123; struct Student arr[3] = &#123;&#123;1, 18, &quot;小明&quot;&#125;, &#123;2, 17, &quot;小红&quot;&#125;, &#123;3, 18, &quot;小刚&quot;&#125;&#125;; printf(&quot;%s&quot;, arr[1].name); //先通过arr[1]拿到第二个结构体，然后再通过同样的方式 .数据名称 就可以拿到对应的值了&#125; 当然，除了数组之外，我们可以创建一个指向结构体的指针。 1234int main() &#123; struct Student student = &#123;1, 18, &quot;小明&quot;&#125;; struct Student * p = &amp;student; //同样的，类型后面加上*就是一个结构体类型的指针了&#125; 我们拿到结构体类型的指针后，实际上指向的就是结构体对应的内存地址，和之前一样，我们也可以通过地址去访问结构体中的数据： 123456int main() &#123; struct Student student = &#123;1, 18, &quot;小明&quot;&#125;; struct Student * p = &amp;student; printf(&quot;%s&quot;, (*p).name); //由于.运算符优先级更高，所以需要先使用*p得到地址上的值，然后再去访问对应数据&#125; 不过这样写起来太累了，我们可以使用简便写法： 1printf(&quot;%s&quot;, p-&gt;name); //使用 -&gt; 运算符来快速将指针所指结构体的对应数据取出 我们来看看结构体作为参数在函数之间进行传递时会经历什么： 123456789void test(struct Student student)&#123; student.age = 19; //我们对传入的结构体中的年龄进行修改&#125;int main() &#123; struct Student student = &#123;1, 18, &quot;小明&quot;&#125;; test(student); printf(&quot;%d&quot;, student.age); //最后会是修改后的值吗？&#125; 可以看到在其他函数中对结构体内容的修改并没有对外面的结构体生效，因此，实际上结构体也是值传递。我们修改的只是另一个函数中的局部变量而已。 所以如果我们需要再另一个函数中处理外部的结构体，需要传递指针： 123456789void test(struct Student * student)&#123; //这里使用指针，那么现在就可以指向外部的结构体了 student-&gt;age = 19; //别忘了指针怎么访问结构体内部数据的&#125;int main() &#123; struct Student student = &#123;1, 18, &quot;小明&quot;&#125;; test(&amp;student); //传递结构体的地址过去 printf(&quot;%d&quot;, student.age);&#125; 当然一般情况下推荐传递结构体的指针，而不是直接进行值传递，因为如果结构体非常大的话，光是数据拷贝就需要花费很大的精力，并且某些情况下我们可能根本用不到结构体中的所有数据，所以完全没必要浪费空间，使用指针反而是一种更好的方式。 联合体联合体也可以在内部定义很多种类型的变量，但是它与结构体不同的是，所以的变量共用同一个空间。？？？？啥意思？ 12345union Object &#123; //定义一个联合体类型唯一不同的就是前面的union了 int a; char b; float c;&#125;; 我们来看看一个神奇的现象： 12345678910111213#include &lt;stdio.h&gt;union Object &#123; int a; char b; float c;&#125;;int main() &#123; union Object object; object.a = 66; //先给a赋值66 printf(&quot;%d&quot;, object.b); //访问b&#125; ？？？？ 我修改的是a啊，怎么b也变成66了？这是因为它们共用了内存空间，实际上我们先将a修改为66，那么就将这段内存空间上的值修改为了66，因为内存空间共用，所以当读取b时，也会从这段内存空间中读取一个char长度的数据出来，所以得到的也是66。 12345int main() &#123; union Object object; object.a = 128; printf(&quot;%d&quot;, object.b);&#125; 因为：128 &#x3D; 10000000，所以用char读取后，由于第一位是符号位，于是就变成了-128。 那么联合体的大小又是如何决定的呢？ 123456789union Object &#123; int a; char b; float c;&#125;;int main() &#123; printf(&quot;%lu&quot;, sizeof(union Object));&#125; 实际上，联合体的大小至少是其内部最大类型的大小，这里是int所以就是4，当然，当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。 当然联合体的其他使用基本与结构体差不多，这里就不提了。 枚举最后我们来看一下枚举类型，枚举类型一般用于表示一些预设好的整数常量，比如我们风扇有低、中、高三个档位，我们总是希望别人使用我们预设好的这三个档位，而不希望使用其他的档位，因为我们风扇就只设计了这三个档位。 这时我们就可以告诉别人，我们的风扇有哪几个档位，这种情况使用枚举就非常适合。在我们的程序中，只能使用基本数据类型对这三种档位进行区分，这样显然可读性不够，别人怎么知道哪个代表哪个档位呢？而使用枚举就没有这些问题了： 1234567/** * 比如现在我们设计： * 1 = 低档位 * 2 = 中档位 * 3 = 高档位 */enum status &#123;low = 1, middle = 2, high = 3&#125;; //enum 枚举类型名称 &#123;枚举 = 初始值, 枚举...&#125; 我们可以创建多个自定义名称的枚举，命名规则和变量差不多。我们可以当每一个枚举对应一个整数值，这样的话，我们就不需要去记忆每个数值代表的是什么档位了，我们可以直接根据枚举的名称来进行分辨，是不是很方便？ 使用枚举也非常地方便： 123456enum status &#123;low = 1, middle = 2, high = 3&#125;;int main() &#123; enum status a = low; //和之前一样，直接定义即可，类型为enum + 枚举名称，后面是变量名称，值可以直接写对应的枚举 printf(&quot;%d&quot;, a);&#125; 12345678910int main() &#123; enum status a = high; if(a == low) &#123; //判断起来就方便多了 printf(&quot;低档位&quot;); &#125; else if (a == high)&#123; printf(&quot;高档位&quot;); &#125; else &#123; printf(&quot;中档位&quot;); &#125;&#125; 当然也可以直接加入到switch语句中： 123456789int main() &#123; enum status a = high; switch (a) &#123; case low: case high: case middle: default: ; &#125;&#125; 不过在枚举变量定义时需要注意： 1enum status &#123;low, middle, high&#125;; //如果不给初始值的话，那么会从第一个枚举开始，默认值为0，后续依次+1 所以这里的low就是0，middle就是1，high就是2了。 如果中途设定呢？ 1enum status &#123;low, middle = 6, high&#125;; //这里我们给middle设定为6 这时low由于是第一个，所以还是从0开始，不过middle这里已经指定为6了，所以紧跟着的high初始值就是middle的值+1了，因此low现在是0，middle就是6，high就是7了。 typedef关键字这里最后还要提一下typedef关键字，这个关键字用于给指定的类型起别名。怎么个玩法呢？ 1typedef int lbwnb; //食用方式：typedef 类型名称 自定义类型别名 比如这里我们给int起了一个别名，那么现在我们不仅可以使用int来表示一个int整数，而且也可以使用别名作为类型名称了： 12345678#include &lt;stdio.h&gt;typedef int lbwnb;int main() &#123; lbwnb i = 666; //类型名称直接写成别名，实际上本质还是int printf(&quot;%d&quot;, i);&#125; 123456typedef const char * String; //const char * 我们就起个名称为String表示字符串int main() &#123; String str = &quot;Hello World!&quot;; //是不是有Java那味了 printf(str);&#125; 当然除了这种基本类型之外，包括指针、结构体、联合体、枚举等等都可以使用这个关键字来完全起别名操作： 12345678910#include &lt;stdio.h&gt;typedef struct test &#123; int age; char name[10];&#125; Student; //为了方便可以直接写到后面，当然也可以像上面一样单独声明int main() &#123; Student student = &#123;18, &quot;小明&quot;&#125;; //直接使用别名，甚至struct关键字都不用加了&#125; 在数据结构的学习总，typedef使用会更加地频繁。 预处理虽然我们的C语言学习已经快要接近尾声了，但是有一个东西迟迟还没有介绍，就是我们一直在写的： 1#include &lt;stdio.h&gt; 这到底是个什么东西，为什么每次都要加上呢？这一部分，我们将详细讨论它缘由。 #include实际上是一种预处理指令，在我们的程序运行之前，会有一个叫做”C预处理器”的东西，根据我们程序中的预处理指令，预处理器能把对应的指令替换为指令想要表示的内容。我们先来看看#include做了什么。 文件包含当预处理器发现#include指令时，会查看后面的文件名并把文件的内容包含到当前文件中，来替换掉#include指令。比如： 123int main() &#123; printf(&quot;Hello World!&quot;); //一个很普通的printf打印函数&#125; 我们说了，这个函数是由系统为我们提供的函数，实际上这个函数实在其他源文件中定义好的，而定义这个函数的源文件，就是stdio.h，我们可以点进去看看： 除了printf之外，我们看到还有很多很多的函数原型定义，他们都写到这个源文件中，而这个文件并不是以.c结尾的，而是以.h结尾的，这种文件我们称为头文件。头文件一般仅包含定义一类的简单信息，只要能让编译器认识就行了。 而#include则是将这些头文件中提供的信息包含到我们的C语言源文件中，这样我们才能使用定义好的printf函数，如果我们不添加这个指令的话，那么会： 直接不认识了，printf是啥，好吃吗？说白了就是，我们如果不告诉编译器我们的这个函数是从哪来的，它怎么知道这个函数的具体定义什么是，程序又该怎么执行呢？ #include的具体使用格式如下： 1#include &lt;文件名称&gt; 当然也可以写成： 1#include &quot;文件名称&quot; 这两种写法虽然都能引入头文件，但是区别还是有的： 尖括号：引用的是编译器的库路径里面的头文件。 双引号：引用的是程序目录中相对路径中的头文件，如果找不到再去上面的库里面找。 可以看到系统已经为我们提供好了多种多样的头文件了，通过这些系统提供的库，我们就可以做很多的事情了。 当然我们也可以自己编写一个头文件，直接在项目根目录下创建一个新的C&#x2F;C++头文件： 12345678//// Created by Nago Coler on 2023/6/26.//#ifndef UNTITLED_TEST_H#define UNTITLED_TEST_H#endif //UNTITLED_TEST_H 可以看到系统自动为我们生成好了这些内容，只不过现在还没学到（后面会介绍），现在直接删掉： 1int test(int a, int b); 我们直接在头文件中随便声明一个函数原型，接着我们就可以引入这个头文件了： 123456#include &lt;stdio.h&gt;#include &quot;test.h&quot; //因为是我们自己项目目录中的，所以需要使用双引号int main() &#123; int c = test(1, 2); //这样就可以使用头文件中声明的函数了&#125; 通过导入头文件，我们就可以使用定义好的各种内容了，当然，不仅仅局限于函数。 不过现在还没办法执行，因为我们这里只是引入了头文件中定义的函数原型，具体的函数实现我们一般还是使用.c源代码文件去进行编写，这里我们创建一个同名的C源文件（不强制要求同名，但是这样看着整齐一点）去实现一下： 12345#include &quot;test.h&quot; //这里也需要把定义引入int test(int a, int b) &#123; //编写函数具体实现 return a + b;&#125; 这样，我们再次运行程序就可以正确得到结果了： 实际上预处理器正是通过头文件得到编译代码时所需的一些信息，然后才能把我们程序需要的内容（比如这里要用到的test函数）替换到我们的源文件中，最后才能正确编译为可执行程序。 比如现在我们要做一个学生管理库，这个库中提供了学生结构体的定义，以及对学生信息相关操作： 123456789struct stu &#123; //学生结构体定义 int id; int age; char name[20];&#125; typedef Student;void print(Student * student); //打印学生信息void modifyAge(Student * student, int newAge); //修改年龄 void modifyId(Student * student, int newId); //修改学号 1234567891011121314#include &lt;stdio.h&gt; //函数具体实现源文件#include &quot;student.h&quot;void print(Student * student) &#123; printf(&quot;ID: %d, 姓名: %s, 年龄: %d岁\\n&quot;, student-&gt;id, student-&gt;name, student-&gt;age);&#125;void modifyAge(Student * student, int newAge) &#123; student-&gt;age = newAge;&#125;void modifyId(Student * student, int newId) &#123; student-&gt;id = newId;&#125; 最后我们就可以愉快地使用了： 1234567#include &quot;student.h&quot;int main() &#123; Student student = &#123;1, 18, &quot;小明&quot;&#125;; modifyAge(&amp;student, 19); print(&amp;student); //打印&#125; 通过使用#include我们就可以将我们的项目拆分成多个模块去进行编写了。 系统库介绍前面我们了解了如何使用#include引入其他文件，我们接着来了解一下系统为我们提供的一些常用库。实际上我们已经用过不少官方库提供的内容了： 12345678910#include &lt;stdio.h&gt;int main() &#123; int a; scanf(&quot;%d&quot;, &amp;a); printf(&quot;%d&quot;, a); getchar(); putchar(&#x27;A&#x27;); ...&#125; 包括前面我们在实战中用到了一次string.h中提供的计算字符串长度的函数： 1234567#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; char * c = &quot;Hello World!&quot;; printf(&quot;%lu&quot;, strlen(c)); //使用strlen计算长度，注意返回值类型是size_t（别名而已，本质上就是unsigned long）&#125; 当然除了这个函数之外，实际上还有很多实用的字符串处理函数，都在这里定义了： 12345678910#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; char a[20] = &quot;Hello&quot;,* b = &quot;World!&quot;; //现在有两个字符串，但是我们希望把他们拼接到一起 //注意不能这样写 char * a = &quot;Hello&quot;,* b = &quot;World!&quot;; 如果直接用指针指向字符串常量，是无法进行拼接的，因为大小已经固定了 //这里需要两个参数，第一个是目标字符串，一会会将第二个参数的字符串拼接到第一个字符串中（注意要装得下才行） strcat(a, b); printf(&quot;%s&quot;, a);&#125; 12345int main() &#123; char str[10], * c = &quot;Hello&quot;; strcpy(str, c); //使用cpy会直接将后面的字符串拷贝到前面的字符串数组中（同样需要前面装得下才行） printf(&quot;%s&quot;, str);&#125; 12345int main() &#123; char * a = &quot;AAA&quot;, * b = &quot;AAB&quot;; int value = strcmp(a, b); //strcmp会比较两个字符串，并返回结果 printf(&quot;%d&quot;, value);&#125; 这里需要说一下的比较规则：把字符串str1和str2从首字符开始逐个字符的进行比较，直到某个字符不相同或者其中一个字符串比较完毕才停止比较，字符的比较按照ASCII码的大小进行判断。 比较完成后，会返回不匹配的两个字符的ASCII码之差： 我们接着来看用于处理数学问题的相关库： 1#include &lt;math.h&gt; 这里要用到math.h，它提供了我们场景的数学计算函数，比如求算术平方根、三角函数、对数等。 12345678#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main() &#123; int a = 2; double d = sqrt(a); //使用sqrt可以求出非负数的算术平方根（底层采用牛顿逼近法计算） printf(&quot;%lf&quot;, d);&#125; 当然能够开根，也可以做乘方： 12345int main() &#123; int a = 2; double d = pow(a, 3); //使用pow可以快速计算乘方，这里求的是a的3次方 printf(&quot;%lf&quot;, d);&#125; 有了这个函数，写个水仙花数更简单了： 12345678int main() &#123; for (int i = 0; i &lt; 1000; ++i) &#123; int a = i % 10, b = i / 10 % 10, c = i / 10 / 10; if(pow(a, 3) + pow(b, 3) + pow(c, 3) == i) &#123; printf(&quot;%d 是水仙花数！\\n&quot;, i); &#125; &#125;&#125; 当然也可以计算三角函数： 1234int main() &#123; printf(&quot;%f&quot;, tan(M_PI)); //这里我们使用正切函数计算tan180度的值，注意要填入的是弧度值 //M_PI也是预先定义好的π的值，非常精确&#125; 当然某些没有不存在的数可能算出来会得到一个比较奇怪的结果： 123int main() &#123; printf(&quot;%f&quot;, tan(M_PI / 2)); //这里计算tan90°，我们知道tan90° = sin90°/cos90° = 1/0 不存在&#125; 当然还有两个比较常用的函数： 12345int main() &#123; double x = 3.14; printf(&quot;不小于x的最小整数：%f\\n&quot;, ceil(x)); printf(&quot;不大于x的最大整数：%f\\n&quot;, floor(x));&#125; 当然也有快速求绝对值的函数： 1234int main() &#123; double x = -3.14; printf(&quot;x的绝对值是：%f&quot;, fabs(x));&#125; 我们最后再来介绍一下通用工具库stdlib，这个库里面为我们提供了大量的工具函数： 123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[] = &#123;5, 2, 4, 0, 7, 3, 8, 1, 9, 6&#125;; //工具库已经为我们提供好了快速排序的实现函数，直接用就完事 //参数有点多，第一个是待排序数组，第二个是待排序的数量（一开始就是数组长度），第三个是元素大小，第四个是排序规则（我们提供函数实现） qsort();&#125; 当然在开始使用之前我们还要先补充一点知识，我们发现qsort的原型定义，使用的是void类型的指针。 怎么void还有指针呢？void不是空吗？ void 指针是一种特殊的指针，表示为“无类型指针”，由于 void 指针没有特定的类型，因此它可以指向任何类型的数据。也就是说，任何类型的指针都可以直接赋值给 void 指针，而无需进行其他相关的强制类型转换。 所以这里之所以需要void指针，其实就是为了可以填入任何类型的数组，而我们发现第三个参数实际上就是因为是void指针不知道具体给进来的类型是什么，所以需要我们来告诉函数我们使用的类型所占大小是多少。 而最后一个参数实际上就是我们前面介绍的函数回调了，因为函数不知道你的比较规则是什么，是从小到大还是从大到小呢？所以我们需要编写一个函数来对两个待比较的元素进行大小判断。 好了，现在了解了之后，我们就可以开始填入参数了： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int compare(const void * a, const void * b) &#123; //参数为两个待比较的元素，返回值负数表示a比b小，正数表示a比b大，0表示相等 int * x = (int *) a, * y = (int *) b; //这里因为判断的是int所以需要先强制类型转换为int *指针 return *x - *y; //其实直接返回a - b就完事了，因为如果a比b大的话算出来一定是正数，反之同理&#125;int main() &#123; int arr[] = &#123;5, 2, 4, 0, 7, 3, 8, 1, 9, 6&#125;; //工具库已经为我们提供好了快速排序的实现函数，直接用就完事 //参数有点多，第一个是待排序数组，第二个是待排序的数量（一开始就是数组长度），第三个是元素大小，第四个是排序规则（我们提供函数实现） qsort(arr, 10, sizeof(int), compare); for (int i = 0; i &lt; 10; ++i) &#123; printf(&quot;%d &quot;, arr[i]); &#125;&#125; 这样，我们就可以对数组进行快速排序了。 当然工具库中还提供了exit函数用于终止程序： 12345#include &lt;stdlib.h&gt;int main() &#123; exit(EXIT_SUCCESS); //直接终止程序，其中参数是传递给父进程的（但是现在我们只是简单程序）&#125; 不过乍一看，貌似和我直接在main里面return没啥区别，反正都会结束。 当然还有两个我们会在后续学习数据结构中用的较多的函数： 123456int main() &#123; int * p = (int *) malloc(sizeof(int)); //我们可以使用malloc函数来动态申请一段内存空间 //申请后会返回申请到的内存空间的首地址 *p = 128; printf(&quot;%d&quot;, *p);&#125; malloc用于向系统申请分配指定size个字节的内存空间，返回类型是 void * 类型，如果申请成功返回首地址，如果失败返回NULL空地址（比如系统内存不足了就可能会申请失败） 申请到一段内存空间后，这段内存空间我们就可以往上面随便读写数据了，实际上就是和变量一样，只不过这个内存空间是我们自主申请的，并不是通过创建变量得到的，但是使用上其实没啥大的区别。 不过要注意，这段内存使用完之后记得清理，就像函数执行完会自动销毁其中的局部变量一样，如果不清理那么这段内存会被一直占用： 12345678int main() &#123; int * p = (int *)malloc(sizeof(int)); *p = 128; printf(&quot;%d&quot;, *p); free(p); //使用free函数对内存空间进行释放，归还给系统，这样这段内存又可以被系统分配给别人用了 p = NULL; //指针也不能再指向那个地址了，因为它已经被释放了&#125; 内存资源是很宝贵的（不像硬盘几个T随便用，我们的电脑可能32G的内存都算高配了），不能随便浪费，所以一般情况下malloc和free都是一一对应的，这样才能安全合理地使用内存。 宏定义我们前面认识了#include指令，我们接着来看#define指令，它可以实现宏定义。我语文不好，宏是啥意思？ 把参数批量替换到文本中，这种实现通常称为宏（macro）或定义宏 (define macro) 我们可以通过#define来定义宏，规则如下： 1#define 宏名(记号) 内容 比如现在我们想通过宏定义一个PI： 1#define PI 3.1415926 这样就可以了，那么怎么去使用它呢？ 1234567#include &lt;stdio.h&gt;#define PI 3.1415926int main() &#123; printf(&quot;π的值为：%f&quot;, PI); //就像使用变量一样，我们可以直接将PI放到这个位置&#125; 在编译时，预处理程序会进行宏替换操作，也就是将程序中所有的PI全部替换为3.1415926，注意这个跟类型无关，是赤裸裸的纯文本替换，也就是相当于把我们的代码修改了，PI那里直接变成3.1415926，当然如果你定义为其他任意的内容，同样会替换到那个位置，但是至于替换之后程序还正不正常就不知道了。 我们通过下面这个例子来加深对文本替换这句话的理解： 12345678#include &lt;stdio.h&gt;#define M a + bint main() &#123; int a = 10, b = 20; printf(&quot;%d&quot;, M * a); //各位觉得计算结果会是多少呢？&#125; 如果按照我们的正常思维，M是a+b，那么替换上去之后应该就是30了吧？然后30 x 10最后得到的应该是300才对。 不过最后貌似并不是这样的，怎么会算出来是210的呢？ 实际上还是那句话，在编译时仅仅是做了文本替换，相当于最后我们的代码是： 1printf(&quot;%d&quot;, a + b * a); 所以先计算的是a x b然后再加a，最后结果就是210了。 当然任何地方都可以使用宏替换，包括类型，反正最后都会变成被替换的内容： 12345#define lbwnb longint main() &#123; lbwnb a = 10L;&#125; 当然除了这种简单的替换之外我们还可以添加参数，就像函数那样： 1234567#include &lt;stdio.h&gt;#define MUL(x) x * xint main() &#123; printf(&quot;%d&quot;, MUL(9));&#125; 虽然这里搞得像函数一样，但是最后还是会被替换为x * x，而这个x就是我们填写的参数，所以最后会变成 9 * 9 替换上去，程序运行出来的结果就是81了。 直接调函数肯定也是没问题的，反正就纯替换： 1234567#include &lt;stdio.h&gt;#define bb(i) printf(&quot;我是宏替换的：%d&quot;, i);int main() &#123; bb(666);&#125; 那要是我想在字符串里面加一个宏定义中的参数呢？ 1234567#include &lt;stdio.h&gt;#define bb(str) printf(&quot;我是宏替换的：&quot;#str&quot; &lt;&quot;); //使用#直接在字符串中进行宏替换，否则默认情况下会被当做一个字符int main() &#123; bb(&quot;你看这不就替换了吗&quot;);&#125; 当然还可以替换宏中的部分： 123456#define TEST(n) x ##n //##会使用参数进行拼接int main() &#123; int TEST(1) = 10; //这里传入1，那么实际上就是被替换为x1 x1 = 20; //所以上面其实是int x1 = 10&#125; 宏既然可以定义出来，那么也可以取消定义，我们可以使用#undef来取消已有的宏定义： 可以看到在使用#undef之后，直接不认识了。 当然除了我们自己可以去定义之外，系统也为我们提供了一些预定义的宏： 宏名称 含义 _ _ DATE _ _ 当前的日期，格式为类似 Jun 27 2023 的字符串 _ _ TIME _ _ 当前的时间，格式为类似 10:23:12 的字符串 _ _ FILE _ _ 当前源代码文件的名称（含路径）的字符串 _ _ LINE _ _ 当前所处的行号是多少就替换为多少，整数 这里只列出了一部分。 条件编译我们来看看条件编译，我们还可以根据条件，选择性地对某些内容进行忽略。 收我们我们来认识一下#ifdef、#else、#endif这三种条件编译指令： 1234567891011#include &lt;stdio.h&gt;#ifdef PI //ifdef用于判断是否定义了符号PI，如果没有的话则处理以下的指令 #define M 666#else //如果定义了符号PI，那么就处理这个分支的语句 #define M 777#endif //最后需要以endif指令结束整个判断int main() &#123; printf(&quot;%d&quot;, M); //最后打印M&#125; 可以看到，在我们没有定义PI的情况下，执行的是#define M 777，那要是现在定义了呢？我们编写一个新的头文件： 1#define PI 3.1415 现在我们引入这个头文件，那么对应的预编译指令也会跟着包含进来： 123456789101112#include &lt;stdio.h&gt;#include &quot;test.h&quot;#ifdef PI #define M 666#else #define M 777#endifint main() &#123; printf(&quot;%d&quot;, M);&#125; 可以看到此时得到的结果就是666了，因为现在PI在引入的头文件中已经定义了（当然直接在当前源文件中定义也是一样的） 那如果我现在希望判断某个符号没定义呢？没错，还有#ifndef表示判断是否未定义某个符号： 1234567891011#include &lt;stdio.h&gt;#ifndef PI //ifndef 就是 if not define，跟ifdef反着的 #define M 666#else #define M 777#endifint main() &#123; printf(&quot;%d&quot;, M);&#125; 当然，除了判断某个符号是否存在之外，我们也可以像条件语句那样直接进行逻辑判断，这里需要使用到#if和#elif指令： 123456789#define M 666#if M == 666 //若M等于666那么定义K = 999 #define K 999#elif M == 777 //等同于else if语句 #define K 888#else //else语句 #define K 000#endif 并且这些分支还支持嵌套使用： 1234567891011#define M 666#if M == 666 #ifdef L #include &quot;test.h&quot; #endif#elif M == 777 #define K = 888#else #define K = 000#endif 文件输入&#x2F;输出（选学）注意：本小节作为选学内容，不强制要求。 我们的电脑上其实存放了多种多样的文件，比如我们办公经常需要打交道的Word文档、PPT幻灯片、Excel表格等，包括我们的C程序源文件，图片、视频等等，这些都是文件，由于文件需要被长期保存，所以它们被统一存放到我们电脑上的硬盘中。硬盘不像内存，虽然它们都可以存放数据，但是内存中的数据断电即失（在学习完数字电路中的锁存器后，你就知道为什么了）而硬盘却支持长期保存数据，当然也是以二进制的形式进行保存的。 文本读写操作现代计算机使用的硬盘大致分为固态硬盘和机械硬盘两种，其中固态硬盘的读写速度远超机械硬盘，但是寿命（硬盘是有读写次数限制的，如果读写次数超标，那么就无法使用了）不如机械硬盘，所以一般重要数据都是在机械硬盘中存放，而系统文件一般是在固态硬盘中存放，这样电脑的启动速度会很快。 不过文件并不是随便在硬盘中进行保存的，而是根据不同的文件系统按规则进行存放的，比如Windows下采用的就是NTFS文件系统，而MacOS采用的是APFS文件系统。 文件系统是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。 其中某些文件是以文本格式存储的，比如我们的C语言源文件、普通的文本文档等；而有些文件是二进制格式，比如图片、视频、应用程序等，但是他们最终都是以二进制的形式存储到硬盘上的。当然，普通的文本文件我们直接打开记事本都可以直接进行编辑，而图片这类二进制文件，需要使用专门读取图片的软件来查看，根据格式的不同（图片有png、jpg等格式）对文件的解读方式也不一样，但是最后都会被专门的图片查看软件展示出来。 通过使用C语言，我们也可以读取硬盘上的文件，这里我们先创建一个简单的文本文件： 接着我们可以使用stdio.h中为我们提供的函数打开一个文件： 12345#include &lt;stdio.h&gt;int main() &#123; FILE * file = fopen(&quot;hello.txt&quot;, &quot;rw&quot;); //使用fopen函数来打开一个文件&#125; 这里我们先来介绍一下参数： 第一个参数：文件的名称，这里我填写的是相对路径，也可以写成绝对路径 第二个参数：打开文件的模式，其中模式有以下这些： 模式字符串 含义 “r” 以读模式打开文件 “w” 以写模式打开文件，把现有文件的长度截为0，如果文件不存在，则创建一个新文件 “a” 以写模式打开文件，在现有文件末尾添加内容，如果文件不存在，则创建一个新文件 “r+” 以更新模式打开文件（即可以读写文件）该文件必须存在 “w+” 以更新模式打开文件（即可以读写文件），如果文件存在，则将其长度截为0；如果文件不存在，则创建一个新文件 “a+” 以更新模式打开文件（即，读写），在现有文件的末尾添加内容，如果文件不存在则创建一个新文件；可以读整个文件，但是只能从末尾添加内容 “rb”,“wb”,“ab”,“ab+”,“a+b”,“wb+”,“w+b” 与“a+”模式类似，但是以二进制模式打开文件而不是以文本模式打开文件 具体的不同打开模式会影响到后续的操作，我们后面再说。这里我们使用r表示可读。 然后这个函数返回的是一个FILE结构体指针： 12345typedef struct __sFILE &#123; unsigned char *_p; /* current position in (some) buffer */ int _r; /* read space left for getc() */ ...&#125; FILE; 定义非常复杂，这里我们就不详细介绍了，这样我们就成功打开了这个文件，那么如何对文件进行读取操作呢？ 我们可以使用getc来快速读取文件中的字符： 123456789#include &lt;stdio.h&gt;int main() &#123; FILE * file = fopen(&quot;hello.txt&quot;, &quot;r&quot;); int c; while ((c = getc(file)) != EOF) &#123; //通过一个while循环来不断读取文件，使用getc从文件中读取一个字符，如果到末尾了，那么会返回一个特殊值EOF putchar(c); //使用putchar来快速打印字符到控制台 &#125;&#125; 可以看到成功输出： 当然如果没有这个文件或是文件打开失败的话，可能会返回一个空指针，所以我们需要进一步判断： 12345678910111213#include &lt;stdio.h&gt;int main() &#123; FILE * file = fopen(&quot;hello.txt&quot;, &quot;r&quot;); if(file != NULL) &#123; //如果打开失败会返回NULL int c; while ((c = getc(file)) != EOF) &#123; putchar(c); &#125; &#125; else&#123; puts(&quot;文件打开失败！&quot;); &#125;&#125; 最后我们在使用完文件后，记得关闭文件来释放资源，不然一直会被占用： 1fclose(file); //fclose用于关闭文件 那么读取文件我们知道了，写入呢？写入我们同样可以使用putc来完成： 123456789101112#include &lt;stdio.h&gt;int main() &#123; FILE * file = fopen(&quot;hello.txt&quot;, &quot;w&quot;); //注意这里需要修改为写模式 if(file != NULL) &#123; for (int i = 0; i &lt; 10; ++i) putc(&#x27;A&#x27; + i, file); //从A开始依次写入10个字符 fclose(file); &#125; else&#123; puts(&quot;文件打开失败！&quot;); &#125;&#125; 可以看到最后我们的文件变成了： 原来的文本被覆盖为了我们输入的新文本，那要是我们现在不想覆盖原来的，而是希望在后面追加输入呢？ 1FILE * file = fopen(&quot;hello.txt&quot;, &quot;a&quot;); //我们可以将其修改为a表示append追加输入 这样就不会覆盖原有内容而是追加填写了： 不过这里要补充一下，文件的读写实际上并不是直接对文件进行操作的，在这之间还有一个缓冲区： 我们所有的读操作，首先是从文件读取到缓冲区中，再从缓冲区中读取到程序中的；写操作就是先写入到缓冲区，然后再从缓冲区中写入到文件中。这样做的目的是，因为内存和硬盘的速度差距有点大，为了解决这种速度差异导致的性能问题，所以设定一个缓冲区，这样就算速度不一样，但是内容被放在缓冲区中慢慢消化就没问题了。 虽然缓冲区能够解决这些问题，但是也会带来一些不便之处，比如下面的例子： 12345678910111213#include &lt;stdio.h&gt;int main() &#123; FILE * file = fopen(&quot;hello.txt&quot;, &quot;a+&quot;); //注意这里需要修改为写模式 if(file != NULL) &#123; while (1) &#123; int c = getchar(); //不断从控制台读取字符 if(c == &#x27;q&#x27;) break; putc(c, file); //写入到文件中 &#125; fclose(file); &#125;&#125; 我们发现当我们敲了一个字符之后，可能并不会马上更新到文件中，这就是由于缓冲区没有及时同步到文件中，所以我们需要调用一个函数来刷新缓冲区，将那些缓冲区的没有同步的数据全部同步到文件中： 1234567891011121314#include &lt;stdio.h&gt;int main() &#123; FILE * file = fopen(&quot;hello.txt&quot;, &quot;a+&quot;); if(file != NULL) &#123; while (1) &#123; int c = getchar(); if(c == &#x27;q&#x27;) break; putc(c, file); fflush(file); //使用fflush来刷新缓冲区 &#125; fclose(file); &#125;&#125; 这样我们就可以看到输入一个字符马上就能同步更新了。当然我们也可以手动设定缓冲区的大小： 12char buf[3];setvbuf(file, buf, _IOFBF, 3); 其中： _IONBF：表示不使用缓冲区 _IOFBF：表示只有缓冲区填满了才会更新到文件 _IOLBF：表示遇到换行就更新到文件 除了使用getc之外，标准库中还提供了fprintf和fgets系列函数： 123456789#include &lt;stdio.h&gt;int main() &#123; FILE * file = fopen(&quot;hello.txt&quot;, &quot;a+&quot;); if(file != NULL) &#123; fprintf(file, &quot;树脂%d&quot;, 666); //fprintf就像普通的打印一样，但是它并不是打印到控制台，而是文件中 fclose(file); &#125;&#125; 123456789#include &lt;stdio.h&gt;int main() &#123; FILE * file = fopen(&quot;hello.txt&quot;, &quot;w&quot;); if(file != NULL) &#123; fputs(&quot;小黑子苏珊&quot;, file); //就像使用puts一样，同样是输出到文件中 fclose(file); &#125;&#125; 这样，对于文本文件的基础读写操作就讲解到这里。 随机访问前面我们介绍了文本文件的基础读写操作，我们接着来看随机访问。首先什么是随机访问？ 我们在前面读取文件时，实际上是按照顺序，每次读取都会往后移动一个字符继续读取，那么如果现在我希望直接跳到某个位置进行读取是否可以实现呢？ 我们可以使用fseek来跳转到指定位置： 12345678910#include &lt;stdio.h&gt;int main() &#123; FILE * file = fopen(&quot;hello.txt&quot;, &quot;r&quot;); if(file != NULL) &#123; fseek(file, -2L, SEEK_SET); //第二个参数为偏移量，根据后面的参数而定 putchar(getc(file)); fclose(file); &#125;&#125; 这里介绍一下起始点： SEEK_SET：从文件开始处开始 SEEK_CUR：从当前位置开始（就是已经读到哪个位置就是哪个位置） SEEK_END：从文件末尾开始 而上面的使用的是SEEK_SET，那么就是从文件开始，往后偏移2个字符的位置，也就是字符l。 那么我们怎么知道当前已经读取到文件第几个字符了呢？ 12345678910#include &lt;stdio.h&gt;int main() &#123; FILE * file = fopen(&quot;hello.txt&quot;, &quot;r&quot;); if(file != NULL) &#123; fseek(file, 2L, SEEK_SET); printf(&quot;%ld&quot;, ftell(file)); //可以使用ftell来直接返回当前位置，返回类型为long fclose(file); &#125;&#125; 当然除了fseek和ftell之外，还有fgetpos和fsetpos这两个函数，它们也可以获取位置和设定位置： 12345678910111213#include &lt;stdio.h&gt;int main() &#123; FILE * file = fopen(&quot;hello.txt&quot;, &quot;r&quot;); if(file != NULL) &#123; fpos_t pos; //位置需要使用fpos_t进行存储（主要用于处理大文件） fgetpos(file, &amp;pos); //获取位置，并设定给pos，此时位置为0 fseek(file, -2L, SEEK_END); //通过fseek移动到倒数第二个位置 fsetpos(file, &amp;pos); //设定位置为pos位置 printf(&quot;%ld&quot;, ftell(file)); //最后得到的就是经过fsetpos设定的新位置了 fclose(file); &#125;&#125; 了解了这些函数，这样我们就可以实现对文件的随机读写了。 前面我都是对文本文件进行操作，我们接着来看如何直接读写二进制文件，比如现在我们想要复制一个文件： 1234567891011121314#include &lt;stdio.h&gt;int main() &#123; FILE * file = fopen(&quot;hello.txt&quot;, &quot;r&quot;); FILE * target = fopen(&quot;hello2.txt&quot;, &quot;w&quot;); if(file != NULL) &#123; char buf[1024]; //这里我们使用char类型的数组作为暂存 size_t s; while ((s = fread(buf, sizeof(char), 1024, file)) &gt; 0) &#123; //使用fread函数进行读取，每次都会从文件中读取指定大小的数据到暂存数组中，返回值为实际读取的值，如果读取的值小于0表示读完了 fwrite(buf, sizeof(char), s, target); //使用fwrite将数据写入到指定文件中 &#125; fclose(file); &#125;&#125; 可以看到我们成功将hello.txt中的内容复制到另一个文本文件中了。当然我们也可以用来拷贝大型文件： 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main() &#123; FILE * file = fopen(&quot;22000.318.211104-1236.co_release_svc_refresh_CLIENTCONSUMER_RET_A64FRE_zh-cn.iso&quot;, &quot;r&quot;); FILE * target = fopen(&quot;22000.318.211104-1236.co_release_svc_refresh_CLIENTCONSUMER_RET_A64FRE_zh-cn-2.iso&quot;, &quot;w&quot;); if(file != NULL) &#123; //计算文件的大小 fseek(file, 0L, SEEK_END); long size = ftell(file); fseek(file, 0L, SEEK_SET); char buf[1024 * 1024]; size_t s, all = 0; while ((s = fread(buf, sizeof(char), 1024, file)) &gt; 0) &#123; fwrite(buf, sizeof(char), s, target); all += s; printf(&quot;当前进度 %.1f%%\\n&quot;, (double) all / (double) size * 100); &#125; fclose(file); &#125;&#125; 是不是感觉有内味了： 这样我们就实现了文件的拷贝。 程序编译和调试（选学）注意：本小节作为选学内容，不强制要求。 有关C语言语言层面的教学基本就结束了，最后让我们来了解一下如何不借助IDE，通过最原始的方式手动完成程序的编译。 C语言程序的编译在开始之前，我们需要介绍一个编译器： GCC原名为GNU C语言编译器（GNU C Compiler），只能处理C语言。但其很快扩展，变得可处理C++，后来又扩展为能够支持更多编程语言，如Fortran、Pascal、Objective -C、Java、Ada、Go以及各类处理器架构上的汇编语言等，所以改名GNU编译器套件（GNU Compiler Collection） 那么gcc编译器是如何将我们的程序一步步编译为可执行文件的呢？ 预处理（Pre-Processing）：首先会经过预处理器将程序中的预编译指令进行处理，然后把源文件中的注释这些没用的东西都给扬了。 编译（Compiling）：处理好之后，就可以正式开始编译，首先会编译为汇编代码。 汇编（Assembling）：接着就该将汇编代码编译为机器可以执行的二进制机器指令了，会得到一个二进制目标文件。 链接（Linking）：最后需要将这个二进制目标文件与系统库和其他库的OBJ文件、库文件链接起来，最终生成了可以在特定平台运行的可执行文件。 比如在Windows操作系统下完成这四步，就会生成一个Windows的.exe可执行文件。 我们来一步一步尝试一下，首先我们把CLion自带的GCC工具目录配置到环境变量中（Mac系统直接自带，不需要任何配置）： 位置在你的CLion安装目录/bin/mingw/bin，打开高级系统设置，添加环境变量： 配置完成后，打开CLion，我们随便编写一点内容： 123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello, World!\\n&quot;); return 0;&#125; 然后我们点击IDE下方的终端面板： 可以看到这里打开的是Windows自带的PowerShell终端，如果不是的可以在设置中修改： 现在我们就可以手动开始对我们的C源文件进行编译了，首先是第一步，我们需要对源文件进行预处理： 1gcc -E main.c -o main.i 其中 -E 后面的是我们的源文件名称，-o 是我们预处理后生成的文件名称： 生成后，我们可以直接查看这个文件（因为此时依然是普通文本）可以看到，我们的代码在经过预处理之后，#include &lt;stdio.h&gt;中的内容都替换过来了。最下面大约1000行左右的位置就是我们的代码了： 现在我们已经完成了预处理，接着就可以将其编译为汇编程序了： 1gcc -S main.i -o main.s 这里的-S就是预处理之后的文件，我们可以直接将其编译为汇编代码： 可以看到这里都是汇编代码，各种各样的汇编指令。接着我们就可以将这个汇编代码继续编译为二进制文件了： 1gcc -c main.s -o main.o 这里-c后的就是我们的汇编程序，直接生成为二进制文件： 不过现在我们还没办法直接运行它，因为还需要进一步链接，变成Windows操作系统可以执行的程序： 1gcc main.o -o main 这里直接将刚刚生成的目标文件编译为可执行文件，我们就可以直接运行了： 成功生成.exe文件，我们直接在控制台输入它的名字就可以运行了： 这样我们就实现了手动编译一个C语言程序。当然如果我们要更快速一点地完成编译，可以直接将源文件进行编译： 1gcc main.c -o main 当然这种只是简单的单源文件下的编译，要是遇到多文件的情况下呢？ 1void swap(int * a, int * b); 1234567#include &quot;test.h&quot;void swap(int * a, int * b) &#123; int tmp = *a; *a = *b; *b = tmp;&#125; 12345678910111213141516#include &lt;stdio.h&gt;#include &quot;test.h&quot;int main() &#123; int arr[] = &#123;4, 2, 1, 9, 5, 0, 3, 8, 7, 6&#125;; for (int i = 0; i &lt; 9; ++i) &#123; for (int j = 0; j &lt; 9 - i; ++j) &#123; if(arr[j] &gt; arr[j + 1]) swap(&amp;arr[j], &amp;arr[j + 1]); &#125; &#125; for (int i = 0; i &lt; 10; ++i) &#123; printf(&quot;%d &quot;, arr[i]); &#125;&#125; 我们还是按照刚刚的方式直接进行编译： 可以看到，编译错误，无法识别到swap这个函数，说明肯定还需要把引入的其他文件也给一起带上，所以： 1gcc main.c test.c -o main 或是将两个文件单独编译为对应的二进制文件，最后再放到一起编译也是可以的： 1gcc main.o test.o -o main OK，现在多个文件就可以在一起编译了，最后同样生成了一个可执行文件： 使用Make和CMake进行构建我们的项目可能会有很多很多的内容需要去进行编译，如何去进行组织成了一个大问题，比如让谁先编译，谁后编译，这时，我们就需要一个构建工具来帮助我们对程序的构建流程进行组织。 Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。 要使用Make对我们的项目进行构建，我们需要先告诉Make我们的程序应该如何去进行构建，这时我们就要编写一下Makefile了： 我们只需要把需要执行的命令按照我们想要的顺序全部写到里面就可以了，但是需要遵循以下格式： 12targets : prerequisites command 一个Makefile中可以有很多个目标，比如我们现在要分别编译main.c和test.c，那么就需要创建两个目标： targets：构建的目标，可以是一个普通的标签、文件名称等 prerequisites：前置条件，可以设定要求完成其他目标才能开始构建当前目标 command：构建需要执行的命令 比如现在我们想要分别先编译test.c和main.c，最后将他们变成一个可执行文件，那么makefile可以这样编写： 123456789101112main.exe: test.o main.o #目标1：构建最终的程序，要求完成下面两个目标（注意最终目标需要写在第一个） gcc test.o main.o -o mainmain.o: main.c #目标2：构建目标为main.o，前置要求必须有main.c文件 gcc -E main.c -o main.i gcc -S main.i -o main.s gcc -c main.s -o main.otest.o: test.c #目标3：同样的，要求必须有test.c文件才能开始 gcc -E test.c -o test.i gcc -S test.i -o test.s gcc -c test.s -o test.o 接着我们只需要在控制台输入make命令（CLion自带环境需要输入mingw32-make命令，Mac下直接输入make）就可以进行编译了： 命令执行的每一步都会详细打印出来，我们可以看到构建确实是按照我们的顺序在进行，并且成功编译出最终目标： 当然，如果我们没有做任何的修改，那么再次执行make命令不会做任何事情： 但是如果我们修改一下源文件的话，执行make将会重新构建目标： 再次执行： 通过使用Make，即使没有如此高级的IDE，哪怕我们纯靠记事本写C代码，都可以很方便地完成对一个项目的构建了。当然这只是Make的简单使用，它还支持使用变量、逻辑判断等高级玩法，这里我们就不多做介绍了。 虽然使用Make可以很方便地对项目构建流程进行配置，但是貌似CLion并没有采用这种方式来组织我们的项目进行构建，而是使用了CMake，我们来看看它又是做什么的。 CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件，能测试编译器所支持的C++特性,类似UNIX下的automake。 简而言之， CMake是一个跨平台的Makefile生成工具! 实际上当我们创建一个项目后，CLion会自动为我们配置CMake，而具体的配置都是写在CMakeList.txt中的： 123456cmake_minimum_required(VERSION 3.22)project(untitled C)set(CMAKE_C_STANDARD 99)add_executable(untitled main.c test.c test.h) 我们逐行来进行解读： 第一行使用cmake_minimum_required来指定当前项目使用的CMake最低版本，如果使用的CMake程序低于此版本是无法构建的。 第二行project指定项目名称，名称随意，后面的是项目使用的语言，这里是C。 第三行set用于设定一些环境变量等，这里设定的是C 99标准。 第四行add_executable用于指定一个编译出来的可执行文件，这里名称为untitled，后面的都是需要编译的源文件（头文件可以不写） 当然除了这些语法之外，还有各种各样的设定，比如设定库目录或是外部动态连接库等，这里就不多说了，感兴趣的可以自行了解。 这里我们来手动执行一下cmake： 首先还是添加环境变量，添加完成后重启CLion，我们输入cmake命令进行生成： 1cmake -S . -B test -G &quot;MinGW Makefiles&quot; 其中-S后面的是源文件目录，这里.表示当前目录，-B后面是构建目录，一会构建的文件都在这里面存放，最后-G是选择生成器（生成器有很多，甚至可以直接生成一个VS项目，我们可以直接使用Visual Studio打开），这里我们需要生成Makefile，所以填写”MinGW Makefiles”： 可以看到已经成功在我们的构建目录中生成了： 只不过它这个自动生成的Makefile写的就比较复杂了，我们也不需要去关心，接着我们像之前一样直接使用make就可以编译了： 这里要先进入一下test目录，使用cd test命令修改当前工作目录： 可以看到它生成的Makefile还是挺高级的，还能输出进度，现在我们的程序就构建好了，直接启动把： 当然CLion并没有使用Makefile的编译方式，而是Ninja，并且生成的构建文件默认存放在cmake-build-debug中，跟make比较类似，但是速度会更快一些，不过最后都会成功构建出我们的可执行程序。 这下，我们就清楚整个项目中个个文件是干嘛的了。 使用LLDB调试工具最后我们来说一下LLDB调试工具（与之类似的还有GDB），首先还是配置一下环境变量： LLDB调试工具用于对我们的程序进行逐步调试使用，实际上我们之前也使用调试，只不过是在IDE中的图形化界面中操作的，那么如果没有IDE呢，我们可以使用LLDB调试工具来进行调试： 1lldb .\\untitled.exe 注意在编译时需要需要添加-g参数来附带调试信息，这样才可以使用gdb进行调试，否则不能（CLion默认生成的是可以调试的程序，所以直接使用就行了） 进入后，可以看到是这样的一个界面，我们需要输入命令来进行逐步调试，输入r就可以开始运行了： 成功运行出结果，那么具体怎么进行断点调试呢？我们可以使用b 行号的形式在对应的行号打上断点，比如这里对第9行进行断点： 接着我们再输入r之后，程序会暂时卡在断点位置，此时我们可以通过输入v来查看当前所有的局部变量信息： 可以看到现在是冒泡排序的第一轮，所以i和j都还是0，并且数组是乱序的，我们输入c可以继续运行： 继续运行一轮后，此时j就变成1了，因为内层循环执行了一次，我们可以通过p来打印变量的值： 当我们不需要再调试时，可以直接结束掉程序： 当然这仅仅是展示lldb的简单使用，通过使用lldb我们就可以很轻松地在控制台进行调试了。 至此，包括编译、构建、调试的所有操作，我们完全可以脱离IDE纯靠命令行进行操作了（其实在没有图形化界面的年代基本上都是这样写代码的）","categories":[{"name":"C语言基础知识","slug":"C语言基础知识","permalink":"http://example.com/categories/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C语言基础-3","slug":"C语言基础-3","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-3/"}]},{"title":"C语言(2)","slug":"C语言-2","date":"2022-10-14T16:24:58.000Z","updated":"2022-10-14T16:28:42.117Z","comments":true,"path":"2022/10/15/C语言-2/","link":"","permalink":"http://example.com/2022/10/15/C%E8%AF%AD%E8%A8%80-2/","excerpt":"","text":"C语言基础前面我们已经搭建好了基本的学习环境，现在就让我们开始C语言的学习吧！ C语言的语法层面内容相比其他语言来说，其实算少的了，但是它的难点在于很多概念上的理解，这也是为什么上一章一直在说一些计算机基础相关内容（包括这一章还会继续补一点），这样会有助于各位对于语言的理解，C语言可以说是步入编程领域的分水岭，跨过了这道坎，后续其他编程语言的学习都会无比轻松。 学习编程的过程可能会很枯燥，但是请各位一定不要心急，一步一个脚印，相信大家一定能通关。 C程序基本格式前面我们在创建项目之后自动生成了一个.c文件，这个就是我们编写的程序代码文件： 123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello World!&quot;); return 0;&#125; 操作系统需要执行我们的程序，但是我们的程序中可能写了很多很多的代码，那么肯定需要知道从哪里开始执行才可以，也就是程序的入口，所以我们需要提供一个入口点，我们的C语言程序入口点就是main函数（不过现在还没有讲到函数，所以各位就理解为固定模式即可）它的写法是： 123int main() &#123; //所有的符号一律采用英文的，别用中文 程序代码...&#125; 注意是int后面空格跟上main()，我们的程序代码使用花括号&#123;&#125;进行囊括（有的人为了方便查阅，会把前半个花括号写在下面） 然后我们看到，如果我们需要打印一段话到控制台，那么就需要使用printf(内容)来完成，这其实就是一种函数调用，但是现在我们还没有接触到，我们注意到括号里面的内容就是我们要打印到控制台的内容： 1printf(&quot;Hello World!&quot;); //注意最后需要添加;来结束这一行，注意是英文的分号，不是中文的！ 我们要打印的内容需要采用双引号进行囊括，被双引号囊括的这一端话，我们称为字符串，当然我们现在还没有学到，所以各位也是记固定模式就好，当我们需要向控制台打印一段话时，就要用双引号囊括这段话，然后放入printf即可。我们会在后续的学习中逐渐认识printf函数。 最顶上还有一句： 1#include &lt;stdio.h&gt; 这个是引入系统库为我们提供的函数，包括printf在内，所以我们以后编写一个C语言程序，就按照固定模式： 12345#include &lt;stdio.h&gt;int main() &#123; 程序代码&#125; 除了程序代码部分我们会进行编写之外，其他的地方采用固定模式就好。 我们在写代码的过程中可以添加一些注释文本，这些文本内容在编译时自动忽略，所以比如我们想边写边记点笔记，就可以添加注释，注释的格式为： 12345#include &lt;stdio.h&gt; //引入标准库头文件int main() &#123; //主函数，程序的入口点 printf(&quot;Hello World!&quot;); //向控制台打印字符串&#125; 当然我们也可以添加多行注释： 12345678910#include &lt;stdio.h&gt;/* * 这是由IDE自动生成的测试代码 * 还是可以的 */int main() &#123; printf(&quot;Hello World!&quot;); //最后还有一句 return 0; 但是我们可以不用写，编译器会自动添加，所以后面讲到之后我们再来说说这玩意。&#125; OK，基本的一些内容就讲解完毕了。 基本数据类型我们的程序离不开数据，比如我们需要保存一个数字或是字母，这时候这些东西就是作为数据进行保存，不过不同的数据他们的类型可能不同，比如1就是一个整数，0.5就是一个小数，A就是一个字符，C语言提供了多种数据类型供我们使用，我们就可以很轻松的使用这些数据了。 不同的数据类型占据的空间也会不同，这里我们需要先提一个概念，就是字、字节是什么？ 我们知道，计算机底层实际上只有0和1能够表示，这时如果我们要存储一个数据，比如十进制的3，那么就需要使用2个二进制位来保存，二进制格式为11，占用两个位置，再比如我们要表示十进制的15，这时转换为二进制就是1111占用四个位置（4个bit位）来保存。一般占用8个bit位表示一个字节（B），2个字节等于1个字，所以一个字表示16个bit位，它们是计量单位。 我们常说的内存大小1G、2G等，实际上就是按照下面的进制进行计算的： 8 bit &#x3D; 1 B ，1024 B &#x3D; 1KB，1024 KB &#x3D; 1 MB，1024 MB &#x3D; 1GB，1024 GB &#x3D; 1TB，1024TB &#x3D; 1PB（基本上是1024一个大进位，但是有些硬盘生产厂商是按照1000来计算的，所以我们买电脑的硬盘容量可能是512G的但是实际容量可能会缩水） 在不同位数的系统下基本数据类型的大小可能会不同，因为现在主流已经是64位系统，本教程统一按照64位系统进行讲解。 原码、反码和补码原码上面我们说了实际上所有的数字都是使用0和1这样的二进制数来进行表示的，但是这样仅仅只能保存正数，那么负数怎么办呢？ 比如现在一共有4个bit位来保存我们的数据，为了表示正负，我们可以让第一个bit位专门来保存符号，这样，我们这4个bit位能够表示的数据范围就是： 最小：1111 &#x3D;&gt; - (2^2+2^1+2^0) &#x3D;&gt; -7 最大：0111 &#x3D;&gt; + (2^2+2^1+2^0) &#x3D;&gt; +7 &#x3D;&gt; 7 虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例： 1+(-1) &#x3D; 0001 + 1001 &#x3D; 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道，计算机顶多知道1+1需要进位！） 我们得创造一种更好的表示方式！于是我们引入了反码： 反码正数的反码是其本身负数的反码是在其原码的基础上, 符号位不变，其余各个位取反经过上面的定义，我们再来进行加减法： 1+(-1) &#x3D; 0001 + 1110 &#x3D; 1111 &#x3D;&gt; -0 （直接相加，这样就简单多了！） 思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？ 0既不是正数也不是负数，那么显然这样的表示依然不够合理！ 补码根据上面的问题，我们引入了最终的解决方案，那就是补码，定义如下： 正数的补码就是其本身 （不变！）负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)其实现在就已经能够想通了，-0其实已经被消除了！我们再来看上面的运算： 1+(-1) &#x3D; 0001 + 1111 &#x3D; (1)0000 &#x3D;&gt; +0 （现在无论你怎么算，也不会有-0了！） 所以现在，4bit位能够表示的范围是：-8~+7（C使用的就是补码！） 整数类型我们首先来看看整数类型，整数就是不包含小数点的数据，比如1，99，666等数字，整数包含以下几种类型： int - 占用 4 个字节，32个bit位，能够表示 -2,147,483,648 到 2,147,483,647 之间的数字，默认一般都是使用这种类型 long - 占用 8 个字节，64个bit位。 short - 占用2个字节，16个bit位。 浮点类型浮点类一般用于保存小数，不过为啥不叫小数类型而是浮点类型呢？因为我们的一个小数分为整数部分和小数部分，我们需要用一部分的bit位去表示整数部分，而另一部分去表示小数部分，至于整数部分和小数部分各自占多少并不是固定的，而是浮动决定的（在计算机组成原理中会深入学习，这里就不多介绍了） float - 单精度浮点，占用4个字节，32个bit位。 double - 双精度浮点，占用8个字节，64个bit位。 字符类型除了保存数字之外，C语言还支持字符类型，我们的每一个字符都可以使用字符类型来保存： char - 占用1个字节（-128~127），可以表示所有的ASCII码字符，每一个数字对应的是编码表中的一个字符： 编码表中包含了所有我们常见的字符，包括运算符号、数字、大小写字母等（注意只有英文相关的，没有中文和其他语言字符，包括中文的标点符号也没有） 某些无法直接显示的字符（比如换行，换行也算一个字符）需要使用转义字符来进行表示： 有关基本类型的具体使用我们放到下一节进行讲解。 变量前面我们了解了C语言中的基本类型，那么我们如何使用呢？这时我们就可以创建不同类型的变量了。 变量的使用变量就像我们在数学中学习的x，y一样，我们可以直接声明一个变量，并利用这些变量进行基本的运算，声明变量的格式为： 12数据类型 变量名称 = 初始值; //其中初始值可以不用在定义变量时设定// = 是赋值操作，可以将等号后面的值赋值给前面的变量，等号后面可以直接写一个数字（常量）、变量名称、算式 比如我们现在想要声明一个整数类型的变量： 1int a = 10; //变量类型为int（常用），变量名称为a，变量的初始值为10 1int a = 10, b = 20; //多个变量可以另起一行编写，也可以像这样用逗号隔开，注意类型必须是一样的 其中，变量的名称并不是随便什么都可以的，它有以下规则： 不能重复使用其他变量使用过的名字。 只能包含英文字母或是下划线、数字，并且严格区分大小写，比如a和A不算同一个变量。 虽然可以包含数字，但是不能以数字开头。 不能是关键字（比如我们上面提到的所有基本数据类型，当然还有一些关键字我们会在后面认识） （建议）使用英文单词，不要使用拼音，多个词可以使用驼峰命名法或是通过下划线连接。 初始值可以是一个常量数据（比如直接写10、0.5这样的数字）也可以是其他变量，或是运算表达式的结果，这样会将其他变量的值作为初始值。 我们可以使用变量来做一些基本的运算： 1234567#include &lt;stdio.h&gt;int main() &#123; int a = 10; //将10作为a的值 int b = 20; int c = a + b; //注意变量一定要先声明再使用，这里是计算a + b的结果（算式），并作为c的初始值&#125; 这里使用到了+运算符（之后我们还会介绍其他类型的运算符）这个运算符其实就是我们数学中学习的加法运算，会将左右两边的变量值加起来，得到结果，我们可以将运算结果作为其他变量的初始值，还是很好理解的。 但是现在虽然做了运算，我们还不知道运算的具体结果是什么，所以这里我们通过前面认识的printf函数来将结果打印到控制台： 123456789#include &lt;stdio.h&gt;int main() &#123; int a = 10; int b = 20; int c = a + b; printf(c); //直接打印变量c&#125; 但是我们发现这样似乎运行不出来结果，不对啊，前面你不是说把要打印到控制台的内容写到printf中吗，怎么这里不行呢？实际上printf是用于格式化打印的，我们来看看如何进行格式化打印，输出我们的变量值： 1printf(&quot;c的结果是：%d&quot;, ); //使用%d来代表一个整数类型的数据（占位符），在打印时会自动将c的值替换上去 我们来看看效果： 这样，我们就知道该如何打印我们变量的值了，当然，除了使用%d打印有符号整数之外，还有其他的： 格式控制符 说明 %c 输出一个单一的字符 %hd、%d、%ld 以十进制、有符号的形式输出 short、int、long 类型的整数 %hu、%u、%lu 以十进制、无符号的形式输出 short、int、long 类型的整数 %ho、%o、%lo 以八进制、不带前缀、无符号的形式输出 short、int、long 类型的整数 %#ho、%#o、%#lo 以八进制、带前缀、无符号的形式输出 short、int、long 类型的整数 %hx、%x、%lx %hX、%X、%lX 以十六进制、不带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字也小写；如果 X 大写，那么输出的十六进制数字也大写。 %#hx、%#x、%#lx %#hX、%#X、%#lX 以十六进制、带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字和前缀都小写；如果 X 大写，那么输出的十六进制数字和前缀都大写。 %f、%lf 以十进制的形式输出 float、double 类型的小数 %e、%le %E、%lE 以指数的形式输出 float、double 类型的小数。如果 e 小写，那么输出结果中的 e 也小写；如果 E 大写，那么输出结果中的 E 也大写。 %g、%lg %G、%lG 以十进制和指数中较短的形式输出 float、double 类型的小数，并且小数部分的最后不会添加多余的 0。如果 g 小写，那么当以指数形式输出时 e 也小写；如果 G 大写，那么当以指数形式输出时 E 也大写。 %s 输出一个字符串 比如现在我们要进行小数的运算，还记得我们前面介绍的小数类型有哪些吗？ 12345678#include &lt;stdio.h&gt;int main() &#123; double a = 0.5; float b = 2.5f; //注意直接写2.5默认表示的是一个double类型的值，我们需要再后面加一个f或是F表示是flaot类型值 printf(&quot;a + b的结果是：%f&quot;, a + b); //根据上表得到，小数类型需要使用%f表示，这里我们可以直接将a + b放入其中&#125; 可以看到，结果也是正确的： 当然，我们也可以一次性打印多个，只需要填写多个占位符表示即可： 12345678#include &lt;stdio.h&gt;int main() &#123; double a = 0.5; float b = 2.5f; //整数类型默认是int，如果要表示为long类型的值，也是需要在最后添加一个l或L printf(&quot;a = %f, b = %f&quot;, a, b); //后面可以一直添加（逗号隔开），但是注意要和前面的占位符对应&#125; 结果也是正常的： 我们再来看看字符类型： 12char c = &#x27;A&#x27;; //字符需要使用单引号囊括，且只能有一个字符，不能写成&#x27;AA&#x27;，这就不是单个字符了//注意这里的A代表的是A这个字符，对应的ASCII码是65，实际上c存储的是65这个数字 我们也可以通过格式化打印来查看它的值： 123456#include &lt;stdio.h&gt;int main() &#123; char c = &#x27;A&#x27;; printf(&quot;变量c的值为：%c 对应的ASCII码为：%d&quot;, c, c); //这里我们使用%c来以字符形式输出，%d输出的是变量数据的整数形式，其实就是对应的ASCII码&#125; 当然，我们也可以直接让char存储一个数字（ASCII码），同样也可以打印出对应的字符： 123456#include &lt;stdio.h&gt;int main() &#123; char c = 66; printf(&quot;变量c的值为：%c 对应的ASCII码为：%d&quot;, c, c);&#125; 那么现在请各位小伙伴看看下面这段代码会输出什么： 1234567#include &lt;stdio.h&gt;int main() &#123; int a = 10; char c = &#x27;a&#x27;; printf(&quot;变量c的ASCII码为：%d&quot;, c);&#125; 没错，这里得到的结果就是字符a的ASCII码值，注意千万不要认为c得到的是变量a的值，这里使用的是字符a，跟上面的变量a半毛钱关系都没有： 但是如果我们去掉引号，就相当于把变量a的值给了c，c现在的ASCII码就是10了，所以这里一定要分清楚。 对于某些无法表示的字符，比如换行这类字符，我们没办法直接敲出来，只能使用转义字符进行表示： 1char c = &#x27;\\n&#x27;; 详细的转义字符表参见前面的基本数据类型章节。 变量除了有初始值之外，也可以在后续的过程中得到新的值： 1234567#include &lt;stdio.h&gt;int main() &#123; short s = 10; s = 20; //重新赋值为20，注意这里就不要再指定类型了，指定类型只有在声明变量时才需要 printf(&quot;%d&quot;, s); //打印结果&#125; 可以看到，得到的是我们最后一次对变量修改的结果： 那要是我们不对变量设定初始值呢？那么变量会不会有默认值： 123456#include &lt;stdio.h&gt;int main() &#123; int a, b, c, d; printf(&quot;%d,%d,%d,%d&quot;, a, b, c, d);&#125; 可以看到，虽然定义变量但是我们没有为其设定初始值，那么它的值就是不确定的了（千万注意并不是不设定值默认就是0）： 所以各位小伙伴以后在使用时一定要注意这个问题，至于为什么不是0，这是因为内存分配机制，我们在下一章高级篇再进行讲解。 我们再来看一个例子： 1234567#include &lt;stdio.h&gt;int main() &#123; char c = 127; //已经到达c的最大值了 c = c + 1; //我不管，我就要再加 printf(&quot;%d&quot;, c); //这时会得到什么结果？&#125; 怎么127加上1还变成-128了呢？这是由于位数不够，导致运算结果值溢出： 127 + 1&#x3D; 01111111 + 1 由于现在是二进制，满2进1，所以最后变成 10000000 &#x3D; 补码形式的 -128 所以，了解上面这些计算机底层原理是很重要的，我们能够很轻松地知道为什么会这样。 在我们的运算中，可能也会存在一些一成不变的值，比如π的值永远都是3.1415....，在我们的程序中，也可以使用这样不可变的变量，我们成为常量。 定义常量和变量比较类似，但是需要在前面添加一个const关键字，表示这是一个常量： 可以看到，常量在一开始设定初始值后，后续是不允许进行修改的。 无符号数我们知道，所有的数据底层都是采用二进制来进行保存的，而第一位则是用于保存符号位，但是如果我们不考虑这个符号位，那么所有的数都是按照正数来表示，比如考虑了符号位的char类型： 考虑符号表示范围：-128~127 不考虑符号：0~255 我们也可以直接使用这些不带符号位的数据类型： 1234int main() &#123; unsigned char c = -65; //数据类型前面添加unsigned关键字表示采用无符号形式 printf(&quot;%u&quot;, c); //%u以无符号形式输出十进制数据&#125; 可以看到这里给了无符号char类型c一个-65的值，但是现在很明显符号位也是作为数值的表示部分，所以结果肯定不是-65： 结合我们前面学习的基础知识，我们来看看为什么得到的是191这个数字。首先char类型占据一个字节，8个bit位： 00000000 -&gt; 现在赋值-65 -&gt; -65的补码形式 -&gt; 10111111 由于现在没有符号位，一律都是正数，所以，10111111 &#x3D; 128 + 32 + 16 + 8 + 4 + 2 + 1 &#x3D; 191 我们也可以直接以无符号数形式打印： 123456#include &lt;stdio.h&gt;int main() &#123; int i = -1; printf(&quot;%u&quot;, i); //%u以无符号形式输出十进制数据&#125; 得到无符号int的最大值。 类型转换一种类型的数据可以转换为其他类型的数据，这种操作我们称为类型转换，类型转换分为自动类型转换和强制类型转换，比如我们现在希望将一个short类型的数据转换为int类型的数据： 123456#include &lt;stdio.h&gt;int main() &#123; short s = 10; int i = s; //直接将s的值传递给i即可，但是注意此时s和i的类型不同&#125; 这里其实就是一种自动类型转换，自动类型转换就是编译器隐式地进行的数据类型转换，这种转换不需要我们做什么，我们直接写就行，会自动进行转换操作。 1float a = 3; //包括这里我们给的明明是一个int整数3但是却可以赋值给float类型，说明也是进行了自动类型转换 如果我们使用一个比转换的类型最大值都还要大的值进行类型转换，比如： 1234567#include &lt;stdio.h&gt;int main() &#123; int a = 511; char b = a; //最大127 printf(&quot;%d&quot;, b);&#125; 很明显char类型是无法容纳大于127的数据的，因为只占一个字节，而int占4个字节，如果需要进行转换，那么就只能丢掉前面的就只保留char所需要的那几位了，所以这里得到的就是-1： 511 &#x3D; int -&gt; 00000000 00000000 00000001 11111111 char -&gt; 11111111 -&gt; -1 我们也可以将整数和小数类型的数据进行互相转换： 1234567#include &lt;stdio.h&gt;int main() &#123; int a = 99; double d = a; printf(&quot;%f&quot;, d);&#125; 不过这里需要注意的是，小数类型在转换回整数类型时，会丢失小数部分（注意，不是四舍五入，是直接丢失小数！）： 1234567#include &lt;stdio.h&gt;int main() &#123; double a = 3.14; int b = a; //这里编译器还提示了黄标，我们可以通过之后讲到的强制类型转换来处理 printf(&quot;%d&quot;, b);&#125; 除了赋值操作可以进行自动类型转换之外，在运算中也会进行自动类型转换，比如： 12345678#include &lt;stdio.h&gt;int main() &#123; float a = 2; int b = 3; double c = b / a; // &quot;/&quot; 是除以的意思，也就是我们数学中的除法运算，这里表示a除以b printf(&quot;%f&quot;, c);&#125; 可以看到，这里得到的结果是小数1.5，但是参与运算的既有整数类型，又有浮点类型，结果为什么就确定为浮点类型了呢？这显然是由于类型转换导致的。那么规则是什么呢？ 不同的类型优先级不同（根据长度而定） char和short类型在参与运算时一律转换为int再进行运算。 浮点类型默认按双精度进行计算，所以就算有float类型，也会转换为double类型参与计算。 当有一个更高优先级的类型和一个低优先级的类型同时参与运算时，统一转换为高优先级运算，比如int和long参与运算，那么int转换为long再算，所以结果也是long类型，int和double参与运算，那么先把int转换为double再算。 我们接着来看看强制类型转换，我们可以为手动去指定类型，强制类型转换格式如下： 1(强制转换类型) 变量、常量或表达式; 比如： 123456#include &lt;stdio.h&gt;int main() &#123; int a = (int) 2.5; //2.5是一个double类型的值，但是我们可以强制转换为int类型赋值给a，强制转换之后小数部分丢失 printf(&quot;%d&quot;, a);&#125; 我们也可以对一个算式的结果进行类型转换： 1234567#include &lt;stdio.h&gt;int main() &#123; double a = 3.14; int b = (int) (a + 2.8); //注意得括起来表示对整个算式的结果进行类型转换（括号跟数学中的挺像，也是提升优先级使用的，我们会在运算符部分详细讲解），不然强制类型转换只对其之后紧跟着的变量生效 printf(&quot;%d&quot;, b);&#125; 在我们需要得到两个int相除之后带小数的结果时，强制类型转换就显得很有用： 12345678#include &lt;stdio.h&gt;int main() &#123; int a = 10, b = 4; double c = a / b; //不进行任何的类型转换，int除以int结果仍然是int，导致小数丢失 double d = (double) a / b; //对a进行强制类型转换，现在是double和int计算，根据上面自动类型转换规则，后面的int自动转换为double，结果也是double了，这样就是正确的结果了 printf(&quot;不进行类型转换: %f, 进行类型转换: %f&quot;, c, d);&#125; 合理地使用强制类型转换，能够解决我们很多情况下的计算问题。 运算符前面我们了解了如何声明变量以及变量的类型转换，那么我们如何去使用这些变量来参与计算呢？这是我们本小节的重点。 基本运算符基本运算符包含我们在数学中常用的一些操作，比如加减乘除，分别对应： 加法运算符：+ 减法运算符：- 乘法运算符：* 除法运算符：&#x2F;（注意不是“\\”，看清楚一点） 当然，还有我们之前使用的赋值运算符=，我们先来看看赋值运算符的使用，其实在之前我们已经学习过了： 1变量 = 值 //其中，值可以直接是一个数字、一个变量、表达式的结果等 实际上等号左边的内容准确的说应该是一个左值，不过大部分情况下都是变量，这里就不展开左值和右值的话题了（感兴趣的小伙伴可以去详细了解，有助于后面学习C++理解右值引用） 最简单的用法就是我们前面所说的，对一个变量进行赋值操作： 1int a = 10; 也可以连续地使用赋值操作，让一连串的变量都等于后面的值： 12int a, b;a = b = 20; //从右往左依次给b和a赋值20 可以看出，实际上=运算除了赋值之外，和加减乘除运算一样也是有结果的，比如上面的 a &#x3D; 就是b &#x3D; 20 运算的结果（可以看着一个整体），只不过运算的结果就是b被赋值的值，也就是20。 我们接着来看加减法，这个就和我们数学中的是一样的了： 123456#include &lt;stdio.h&gt;int main() &#123; int a = 10, b = 5; printf(&quot;%d&quot;, a + b); //打印 a + b 的结果&#125; 当然也可以像数学中那样写在一个数或是变量的最前面，表示是正数： 1int a = +10, b = +5; 不过默认情况下就是正数，所以没必要去写一个+号。减法运算符其实也是一样的： 123456#include &lt;stdio.h&gt;int main() &#123; int a = 10, b = 5; printf(&quot;%d&quot;, a - b); //打印 a - b 的结果&#125; 123456#include &lt;stdio.h&gt;int main() &#123; int a = -10; //等于 -10 printf(&quot;%d&quot;, -a); //输出 -a 的值，就反着来嘛&#125; 接着我们来看看乘法和除法运算： 123456#include &lt;stdio.h&gt;int main() &#123; int a = 20, b = 10; printf(&quot;%d, %d&quot;, a * b, a / b); //使用方式和上面的加减法是差不多的&#125; 还有一个比较有意思的取模运算： 123456#include &lt;stdio.h&gt;int main() &#123; int a = 20, b = 8; printf(&quot;%d&quot;, a % b); //取模运算实际上就是计算a除以b的余数&#125; 不过很遗憾，在C中没有指数相关的运算符（比如要计算5的10次方），在后面学习了循环语句之后，我们可以尝试来自己实现一个指数运算。 运算符优先级和数学中一样，运算符是有优先级的： 123456#include &lt;stdio.h&gt;int main() &#123; int a = 20, b = 10; printf(&quot;%d&quot;, a + a * b); //如果没有优先级，那么结果应该是400&#125; 很明显这里的结果是考虑了优先级的： 在数学中，加减运算的优先级是没有乘除运算优先级高的，所以我们需要先计算那些乘除法，最后再来进行加减法的计算，而C语言中也是这样，运算符之间存在优先级概念。我们在数学中，如果需要优先计算加减法再计算乘除法，那么就需要使用括号来提升加减法的优先级，C语言也可以： 123456#include &lt;stdio.h&gt;int main() &#123; int a = 20, b = 10; printf(&quot;%d&quot;, (a + a) * b); //优先计算 a + a 的结果，再乘以 b&#125; 那要是遇到多重的呢？类似于下面的这种： 1数学上的写法：[1 - (3 + 4)] x (-2 ÷ 1) = ? 那么我们在C中就可以这样编写： 12345#include &lt;stdio.h&gt;int main() &#123; printf(&quot;%d&quot;, (1 - (3 + 4)) * (-2 / 1)); //其实写法基本差不多，只需要一律使用小括号即可&#125; 这样，我们就可以通过()运算符，来提升运算优先级了。 我们来总结一下，上面运算符优先级如下，从左往右依次递减： () &gt; + - (做符号表示，比如-9) &gt; * / % &gt; + - (做加减运算) &gt; = 根据上面的优先级，我们来看看下面a的结果是什么： 12int c;int a = (3 + (c = 2)) * 6; 12int b, c;int a = (b = 5, c = b + 8); //逗号运算符从前往后依次执行，赋值结果是最后边的结果 自增自减运算符我们可以快速使用自增运算符来将变量的值+1，正常情况下我们想要让一个变量值自增需要： 12int a = 10;a = a + 1; 现在我们只需要替换为： 12int a = 10;++a; //使用自增运算符，效果等价于 a = a + 1 并且它也是有结果的，除了做自增运算之外，它的结果是自增之后的值： 12345678#include &lt;stdio.h&gt;int main() &#123; int a = 10; //int b = a = a + 1; 下面效果完全一致 int b = ++a; printf(&quot;%d&quot;, b);&#125; 当然我们也可以将自增运算符写到后面，和写在前面的区别是，它是先返回当前变量的结果，再进行自增的，顺序是完全相反的： 1234567#include &lt;stdio.h&gt;int main() &#123; int a = 10; int b = a++; //写在后面和写在前面是有区别的 printf(&quot;a = %d, b = %d&quot;, a, b);&#125; 重点内容：自增运算符++在前，那么先自增再出结果；自增运算符++在后，那么先出结果再自增。各位小伙伴可以直接记运算符的位置，来方便记忆。 那要是现在我们不想自增1而是自增2或是其他的数字呢？我们可以使用复合赋值运算符，正常情况下依然是使用普通的赋值运算符： 12int a = 10;a = a + 5; 但是现在我们可以简写： 12int a = 10;a += 5; 效果和上面是完全一样的，并且得到的结果也是在自增之后的： 1234567#include &lt;stdio.h&gt;int main() &#123; int a = 10; int b = a += 5; printf(&quot;a = %d&quot;, b);&#125; 复合赋值运算符不仅仅支持加法，还支持各种各样的运算： 1234567#include &lt;stdio.h&gt;int main() &#123; int a = 10; a %= 3; //可以复合各种运算，比如加减乘除、模运算、包括我们我们还要讲到的位运算等 printf(&quot;a = %d&quot;, a);&#125; 当然，除了自增操作之外，还有自减操作： 1234567#include &lt;stdio.h&gt;int main() &#123; int a = 10; a--; //--是自减操作，相当于a = a - 1，也可以在前后写，规则和上面的自增是一样的 printf(&quot;a = %d&quot;, a);&#125; 注意自增自减运算符和+、-做符号是的优先级一样，仅次于()运算符，所以在编写时一定要注意： 1234567#include &lt;stdio.h&gt;int main() &#123; int a = 10; int b = 5 * --a; printf(&quot;b = %d&quot;, b);&#125; 位运算符前面我们学习了乘法运算符*，当我们想要让一个变量的值变成2倍，只需要做一次乘法运算即可： 12int a = 10;a *= 2; //很明显算完之后a就是20了 但是我们现在可以利用位运算来快速进行计算： 12int a = 10;a = a &lt;&lt; 1; //也可以写成复合形式 a &lt;&lt;= 1 我们会发现这样运算之后得到的结果居然也是20，这是咋算出来的呢？实际上&lt;&lt;是让所有的bit位进行左移操作，上面就是左移1位，我们可以来看看： 10 &#x3D; 00001010 现在所以bit位上的数据左移一位 00010100 &#x3D; 20 是不是感觉特别神奇？就像我们在十进制中，做乘以10的操作一样：22乘以10那么就直接左移了一位变成220，而二进制也是一样的，如果让这些二进制数据左移的话，那么相当于在进行乘2的操作。 比如： 1234567#include &lt;stdio.h&gt;int main() &#123; int a = 6; a = a &lt;&lt; 2; //让a左移2位，实际上就是 a * 2 * 2，a * 2的平方（类比十进制，其实还是很好理解的） printf(&quot;a = %d&quot;, a);&#125; 当然能左移那肯定也可以右移： 1234567#include &lt;stdio.h&gt;int main() &#123; int a = 6; a = a &gt;&gt; 1; //右移其实就是除以2的操作 printf(&quot;a = %d&quot;, a);&#125; 当然除了移动操作之外，我们也可以进行按位比较操作，先来看看按位与操作： 1234567#include &lt;stdio.h&gt;int main() &#123; int a = 6, b = 4; int c = a &amp; b; //按位与操作 printf(&quot;c = %d&quot;, c);&#125; 按位与实际上也是根据每个bit位来进行计算的： 4 &#x3D; 00000100 6 &#x3D; 00000110 按位与实际上就是让两个数的每一位都进行比较，如果两个数对应的bit位都是1，那么结果的对应bit位上就是1，其他情况一律为0 所以计算结果为：00000100 &#x3D; 4 除了按位与之外，还有按位或运算： 12int a = 6, b = 4;int c = a | b; 4 &#x3D; 00000100 6 &#x3D; 00000110 按位与实际上也是让两个数的每一位都进行比较，如果两个数对应bit位上其中一个是1，那么结果的对应bit位上就是1，其他情况为0。 所以计算结果为：00000110 &#x3D; 6 还有异或和按位非（按位否定）： 123int a = 6, b = 4;int c = a ^ b; //注意^不是指数运算，表示按位异或运算，让两个数的每一位都进行比较，如果两个数对应bit位上不同时为1或是同时为0，那么结果就是1，否则结果就是0，所以这里的结果就是2a = ~a; //按位否定针对某个数进行操作，它会将这个数的每一个bit位都置反，0变成1，1变成0，猜猜会变成几 按位运算都是操作数据底层的二进制位来进行的。 逻辑运算符最后我们来看一下逻辑运算符，逻辑运算符主要用到下一节的流程控制语句中。 逻辑运算符用于计算真和假，比如今天要么下雨要么不下雨，现在我们想要在程序中判断一下是否下雨了，这时就需要用到逻辑运算符，我们来举个例子： 12345678#include &lt;stdio.h&gt;int main() &#123; int a = 10; _Bool c = a &lt; 0; //我们现在想要判断a的值是否小于0，我们可以直接使用小于符号进行判断，最后得到的结果只能是1或0 //虽然结果是一个整数，但是这里推荐使用_Bool类型进行接收，它只能表示0和1（更加专业一些） printf(&quot;c = %d&quot;, c); &#125; 实际上在C语言中，0一般都表示为假，而非0的所有值（包括正数和负数）都表示为真，上面得到1表示真，0表示假。 除了小于符号可以判断大小之外，还有：&lt;、 &lt;=、&gt;=、&gt; 比如我们现在想要判断字符C是否为大写字母： 123456#include &lt;stdio.h&gt;int main() &#123; char c = &#x27;D&#x27;; printf(&quot;c是否为大写字母：%d&quot;, c &gt;= &#x27;A&#x27;); //由于底层存储的就是ASCII码，这里可以比较ASCII码，也可以写成字符的形式&#125; 但是我们发现，现在我们的判断只能判断一个条件，也就是说只能判断c是否是大于等于’A’的，但是不能同时判断c的值是否是小于等于’Z’的，所以这时，我们就需要利用逻辑与和逻辑或来连接两个条件了： 123456#include &lt;stdio.h&gt;int main() &#123; char c = &#x27;D&#x27;; printf(&quot;c是否为大写字母：%d&quot;, c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;); //使用&amp;&amp;表示逻辑与，逻辑与要求两边都是真，结果才是真&#125; 又比如现在我们希望判断c是否不是大写字母： 123456#include &lt;stdio.h&gt;int main() &#123; char c = &#x27;D&#x27;; printf(&quot;c是否不为大写字母：%d&quot;, c &lt; &#x27;A&#x27; || c &gt; &#x27;Z&#x27;); //使用||表示逻辑或，只要两边其中一个为真或是都为真，结果就是真&#125; 当然我们也可以判断c是否为某个字母： 123456#include &lt;stdio.h&gt;int main() &#123; char c = &#x27;D&#x27;; printf(&quot;c是否为字母A：%d&quot;, c == &#x27;A&#x27;); //注意判断相等时使用==双等号&#125; 判断不相等也可以使用： 1printf(&quot;c是否不为字母A：%d&quot;, c != &#x27;A&#x27;); 我们也可以对某个结果取反： 123456#include &lt;stdio.h&gt;int main() &#123; int i = 20; printf(&quot;i是否不小于20：%d&quot;, !(i &lt; 20)); //使用!来对结果取反，注意!优先级很高，一定要括起来，不然会直接对i生效&#125; 这里要注意一下!如果直接作用于某个变量或是常量，那么会直接按照上面的规则（0表示假，非0表示真）非0一律转换为0，0一律转换为1。 这里我们可以结合三目运算符来使用这些逻辑运算符： 12345678#include &lt;stdio.h&gt;int main() &#123; int i = 0; char c = i &gt; 10 ? &#x27;A&#x27; : &#x27;B&#x27;; //三目运算符格式为：expression ? 值1 : 值2，返回的结果会根据前面判断的结果来的 //这里是判断i是否大于10，如果大于那么c的值就是A，否则就是B printf(&quot;%d&quot;, c);&#125; 最后，我们来总结一下前面认识的所有运算符的优先级，从上往下依次降低： 运算符 解释 结合方式 () 同数学中的括号，直接提升到最高优先级 由左向右 ! ~ ++ – + - 否定，按位否定，增量，减量，正负号 由右向左 * &#x2F; % 乘，除，取模 由左向右 + - 加，减 由左向右 &lt;&lt; &gt;&gt; 左移，右移 由左向右 &lt; &lt;&#x3D; &gt;&#x3D; &gt; 小于，小于等于，大于等于，大于 由左向右 &#x3D;&#x3D; !&#x3D; 等于，不等于 由左向右 &amp; 按位与 由左向右 ^ 按位异或 由左向右 | 按位或 由左向右 &amp;&amp; 逻辑与 由左向右 || 逻辑或 由左向右 ? : 条件 由右向左 &#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; 各种赋值 由右向左 , 逗号（顺序） 由左向右 流程控制前面我们学习了运算符，知道该如何使用运算符来计算我们想要的内容，但是仅仅依靠计算我们的程序还没办法实现丰富多样的功能，我们还得加点额外的控制操作。 分支语句 - if我们可能会有这样的一个需求，就是判断某个条件，当满足此条件时，才执行某些代码，那这个时候该怎么办呢？我们可以使用if语句来实现： 123456789#include &lt;stdio.h&gt;int main() &#123; int i = 0; if(i &gt; 20) &#123; //我们只希望i大于20的时候才执行下面的打印语句 printf(&quot;Hello World!&quot;); &#125; printf(&quot;Hello World?&quot;); //后面的代码在if之外，无论是否满足if条件，都跟后面的代码无关，所以这里的代码任何情况下都会执行&#125; if语句的标准格式如下： 123if(判断条件) &#123; 执行的代码&#125; 当然如果只需要执行一行代码的话，可以省略花括号： 12if(判断条件) 一行执行的代码 //注意这样只有后一行代码生效，其他的算作if之外的代码了 现在我们需求升级了，我们需要判断某个条件，当满足此条件时，执行某些代码，而不满足时，我们想要执行另一段代码，我们就可以结合else语句来实现： 12345678910#include &lt;stdio.h&gt;int main() &#123; int i = 0; if(i &gt; 20) &#123; printf(&quot;Hello World!&quot;); //满足if条件才执行 &#125; else &#123; printf(&quot;LBWNB&quot;); //不满足if条件才执行 &#125;&#125; 但是这样可能还是不够用，比如我们现在希望判断学生的成绩，不同分数段打印的等级不一样，比如90以上就是优秀，70以上就是良好，60以上是及格，其他的都是不及格，那么这种我们又该如何判断呢？要像这样进行连续判断，我们需要使用else-if来完成： 1234567891011121314#include &lt;stdio.h&gt;int main() &#123; int score = 2; if(score &gt;= 90) &#123; printf(&quot;优秀&quot;); &#125; else if (score &gt;= 70) &#123; printf(&quot;良好&quot;); &#125; else if (score &gt;= 60)&#123; printf(&quot;及格&quot;); &#125; else&#123; printf(&quot;不及格&quot;); &#125;&#125; if这类的语句（包括我们下面还要介绍的三种）都是支持嵌套使用的，比如我们现在希望低于60分的同学需要补习，0-30分需要补Java，30-60分需要补C++，这时我们就需要用到嵌套： 123456789101112#include &lt;stdio.h&gt;int main() &#123; int score = 2; if(score &lt; 60) &#123; //先判断不及格 if(score &gt; 30) &#123; //在内层再嵌套一个if语句进行进一步的判断 printf(&quot;学习C++&quot;); &#125; else&#123; printf(&quot;学习Java&quot;); &#125; &#125;&#125; 分支语句 - switch前面我们介绍了if语句，我们可以通过一个if语句轻松地进行条件判断，然后根据对应的条件，来执行不同的逻辑，当然除了这种方式之外，我们也可以使用switch语句来实现，它更适用于多分支的情况： 12345switch (目标) &#123; //我们需要传入一个目标，比如变量，或是计算表达式等 case 匹配值: //如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码 代码... break; //代码执行结束后需要使用break来结束，否则会继续溜到下一个case继续执行代码&#125; 比如现在我们要根据学生的等级进行分班，学生有ABC三个等级： 12345678910111213141516#include &lt;stdio.h&gt;int main() &#123; char c = &#x27;A&#x27;; switch (c) &#123; //这里目标就是变量c case &#x27;A&#x27;: //分别指定ABC三个匹配值，并且执行不同的代码 printf(&quot;去尖子班！准备冲刺985大学！&quot;); break; //执行完之后一定记得break，否则会继续向下执行下一个case中的代码 case &#x27;B&#x27;: printf(&quot;去平行班！准备冲刺一本！&quot;); break; case &#x27;C&#x27;: printf(&quot;去职高深造。&quot;); break; &#125;&#125; switch可以精准匹配某个值，但是它不能进行范围判断，比如我们要判断分数段，这时用switch就很鸡肋了。 当然除了精准匹配之外，其他的情况我们可以用default来表示： 12345switch (目标) &#123; case: ... default: 其他情况下执行的代码&#125; 比如： 123456789101112131415161718#include &lt;stdio.h&gt;int main() &#123; char c = &#x27;A&#x27;; switch (c) &#123; case &#x27;A&#x27;: printf(&quot;去尖子班！&quot;); break; case &#x27;B&#x27;: printf(&quot;去平行班！&quot;); break; case &#x27;C&#x27;: printf(&quot;去差生班！&quot;); break; default: //其他情况一律就是下面的代码了 printf(&quot;去读职高，分流&quot;); &#125;&#125; 当然switch中可以继续嵌套其他的流程控制语句，比如if： 123456789101112131415#include &lt;stdio.h&gt;int main() &#123; char c = &#x27;A&#x27;; switch (c) &#123; case &#x27;A&#x27;: if(c == &#x27;A&#x27;) &#123; //嵌套一个if语句 printf(&quot;去尖子班！&quot;); &#125; break; case &#x27;B&#x27;: printf(&quot;去平行班！&quot;); break; &#125;&#125; 循环语句 - for通过前面的学习，我们了解了如何使用分支语句来根据不同的条件执行不同的代码，我们接着来看第二种重要的流程控制语句，循环语句。 我们在某些时候，可能需要批量执行某些代码： 1234567#include &lt;stdio.h&gt;int main() &#123; printf(&quot;伞兵一号卢本伟准备就绪！&quot;); //把这句话给我打印三遍 printf(&quot;伞兵一号卢本伟准备就绪！&quot;); printf(&quot;伞兵一号卢本伟准备就绪！&quot;);&#125; 遇到这种情况，我们由于还没学习循环语句，那么就只能写N次来实现这样的多次执行。现在我们可以使用for循环语句来多次执行： 123for (表达式1表达式2;表达式3) &#123; 循环体&#125; 我们来介绍一下： 表达式1：在循环开始时仅执行一次。 表达式2：每次循环开始前会执行一次，要求为判断语句，用于判断是否可以结束循环，若结果为真，那么继续循环，否则结束循环。 表达式3：每次循环完成后会执行一次。 循环体：每次循环都会执行循环体里面的内容，直到循环结束。 一个标准的for循环语句写法如下： 123456//比如现在我们希望循环4次for (int i = 0; i &lt; 4; ++i) &#123; //首先定义一个变量i用于控制循环结束 //表达式2在循环开始之前判断是否小于4 //表达式3每次循环结束都让i自增一次，这样当自增4次之后不再满足条件，循环就会结束，正好4次循环&#125; 我们来看看按顺序打印的结果： 12345678#include &lt;stdio.h&gt;int main() &#123; //比如现在我们希望循环4次 for (int i = 0; i &lt; 4; ++i) &#123; printf(&quot;%d, &quot;, i); &#125;&#125; 这样，利用循环我们就可以批量执行各种操作了。 注意，如果表达式2我们什么都不写，那么会默认判定为真： 1234567#include &lt;stdio.h&gt;int main() &#123; for (int i = 0; ; ++i) &#123; //表达式2不编写任何内容，默认为真，这样的话循环永远都不会结束 printf(&quot;%d, &quot;, i); &#125;&#125; 所以，如果我们想要编写一个无限循环，其实什么都不用写就行了： 1234567#include &lt;stdio.h&gt;int main() &#123; for (;;) &#123; //什么都不写直接无限循环，但是注意，两个分号还是要写的 printf(&quot;Hello World!\\n&quot;); //这里用到了\\n表示换行 &#125;&#125; 当然，我们也可以在循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字： 1234for (int i = 0; i &lt; 10; ++i) &#123; if(i == 5) break; //比如现在我们希望在满足某个条件下提前终止循环，可以使用break关键字来跳出循环 printf(&quot;%d&quot;, i);&#125; 可以看到，当满足条件时，会直接通过break跳出循环，循环不再继续下去，直接结束掉。 我们也可以加速循环： 1234for (int i = 0; i &lt; 10; ++i) &#123; if(i == 5) continue; //使用continue关键字会加速循环，无论后面有没有未执行完的代码，都会直接开启下一轮循环 printf(&quot;%d&quot;, i);&#125; 虽然使用break和continue关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（就近原则）： 123456for (int i = 1; i &lt; 4; ++i) &#123; for (int j = 1; j &lt; 4; ++j) &#123; if(i == j) continue; //当i == j时加速循环 printf(&quot;%d, %d\\n&quot;, i, j); &#125;&#125; 可以看到，continue仅仅加速的是内层循环，而对外层循环没有任何效果，同样的，break也只会终结离它最近的： 123456for (int i = 1; i &lt; 4; ++i) &#123; for (int j = 1; j &lt; 4; ++j) &#123; if(i == j) break; //当i == j时终止循环 printf(&quot;%d, %d\\n&quot;, i, j); &#125;&#125; 循环语句 - while前面我们介绍了for循环语句，我们接着来看第二种while循环，for循环要求我们填写三个表达式，而while相当于是一个简化版本，它只需要我们填写循环的维持条件即可，比如： 1234567#include &lt;stdio.h&gt;int main() &#123; while (1) &#123; //每次循环开始之前都会判断括号内的内容是否为真，如果是就继续循环 printf(&quot;Hello World!\\n&quot;); //这里会无限循环 &#125;&#125; 相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当i大于10时需要结束循环，但是i在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。 123456789#include &lt;stdio.h&gt;int main() &#123; int i = 100; //比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确 while (i &gt; 0) &#123; //现在唯一知道的是循环条件，只要大于0那么就可以继续除 printf(&quot;%d, &quot;, i); i /= 2; //每次循环都除以2 &#125;&#125; while也支持使用break和continue来进行循环的控制： 123456int i = 100;while (i &gt; 0) &#123; if(i &lt; 30) break; printf(&quot;%d, &quot;, i); i /= 2;&#125; 我们可以反转循环判断的位置，可以先执行循环内容，然后再做循环条件判断，这里要用到do-while语句： 1234567#include &lt;stdio.h&gt;int main() &#123; do &#123; //无论满不满足循环条件，先执行循环体里面的内容 printf(&quot;Hello World!&quot;); &#125; while (0); //再做判断，如果判断成功，开启下一轮循环，否则结束&#125; 实战：寻找水仙花数 “水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身。例如：1^3 + 5^3+ 3^3 &#x3D; 153。” 现在请你设计一个C语言程序，打印出所有1000以内的水仙花数。 实战：打印九九乘法表 现在我们要做的是在我们的程序中，也打印出这样的一个乘法表出来，请你设计一个C语言程序来实现它。 实战：斐波那契数列解法其一 斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(0)&#x3D;0，F(1)&#x3D;1, F(n)&#x3D;F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从 1963 年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。 斐波那契数列：1，1，2，3，5，8，13，21，34，55，89…，不难发现一个规律，实际上从第三个数开始，每个数字的值都是前两个数字的和，现在请你设计一个C语言程序，可以获取斐波那契数列上任意一位的数字，比如获取第5个数，那么就是5。 123456789#include &lt;stdio.h&gt;int main() &#123; int target = 7, result; //target是要获取的数，result是结果 //请在这里实现算法 printf(&quot;%d&quot;, result);&#125; 数组现在我们有一个新的需求，我们需要存储2022年每个月都天数，那么此时，为了保存这12个月的天数，我们就得创建12个变量： 12345#include &lt;stdio.h&gt;int main() &#123; int january = 31, february = 28, march = 31 ...&#125; 这样是不是太累了点？万一我们想保存100个商品的售价，那岂不是得创建100个变量？这肯定不行啊。 数组的创建和使用为了解决这种问题，我们可以使用数组，什么是数组呢？简单来说，就是存放数据的一个组，所有的数据都统一存放在这一个组中，一个数组可以同时存放多个数据。比如现在我们想保存12个月的天数，那么我们只需要创建一个int类型的数组就可以了，它可以保存很多个int类型的数据，这些保存在数组中的数据，称为“元素”： 1int arr[12] = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; //12个月的数据全部保存在了一起 可以看到，数组的定义方式也比较简单： 1类型 数组名称[数组大小] = &#123;数据1, 数据2...&#125;; //后面的数据可以在一开始的时候不赋值，并且数组大小必须是整数 注意数组只能存放指定类型的数据，一旦确定是不能更改的，因为数组声明后，会在内存中开辟一块连续的区域，来存放这些数据，所以类型和长度必须在一开始就明确。 创建数组的方式有很多种： 1234567int a[10]; //直接声明int类型数组，容量为10int b[10] = &#123;1, 2, 4&#125;; //声明后，可以赋值初始值，使用&#123;&#125;囊括，不一定需要让10个位置都有初始值，比如这里仅仅是为前三个设定了初始值，注意，跟变量一样，如果不设定初始值，数组内的数据并不一定都是0int c[10] = &#123;1, 2, [4] = 777, [9] = 666&#125;; //我们也可以通过 [下标] = 的形式来指定某一位的初始值，注意下标是从0开始的，第一个元素就是第0个下标位置，比如这里数组容量为10，那么最多到9int c[] = &#123;1, 2, 3&#125;; //也可以根据后面的赋值来决定数组长度 基本类型都可以声明数组： 1234567#include &lt;stdio.h&gt;int main() &#123; char str[] = &#123;&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;&#125;; //多个字符 char str2[] = &quot;ABC&quot;; //实际上字符串就是多个字符的数组形式，有关字符串我们会在下一节进行讲解&#125; 那么数组定义好了，如何去使用它呢？比如我们现在需要打印12个月的天数： 123456789#include &lt;stdio.h&gt;int main() &#123; int arr[12] = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; for (int i = 0; i &lt; 12; ++i) &#123; int days = arr[i]; //直接通过数组 名称[下标] 来访问对应的元素值，再次提醒，下标是从0开始的，不是1 printf(&quot;2022年 %d 月的天数是：%d 天\\n&quot;, (i + 1), days); &#125;&#125; 当然我们也可以对数组中的值进行修改： 1234567#include &lt;stdio.h&gt;int main() &#123; int arr[] = &#123;666, 777, 888&#125;; arr[1] = 999; //比如我们现在想要让第二个元素的值变成999 printf(&quot;%d&quot;, arr[1]); //打印一下看看是不是变成了999&#125; 注意，和变量一样，如果只是创建数组但是不赋初始值的话，因为是在内存中随机申请的一块空间，有可能之前其他地方使用过，保存了一些数据，所以数组内部的元素值并不一定都是0： 12345678#include &lt;stdio.h&gt;int main() &#123; int arr[10]; for (int i = 0; i &lt; 10; ++i) &#123; printf(&quot;%d, &quot;, arr[i]); &#125;&#125; 不要尝试去访问超出数组长度位置的数据，虽然可以编译通过，但是会给警告，这些数据是毫无意义的： 123456#include &lt;stdio.h&gt;int main() &#123; int arr[] = &#123;111, 222, 333&#125;; printf(&quot;%d&quot;, arr[3]); //不能去访问超出数组长度的元素，很明显这里根本就没有第四个元素&#125; 多维数组数组不仅仅只可以有一个维度，我们可以创建二维甚至多维的数组，简单来说就是，存放数组的数组（套娃了属于是）： 12int arr[][2] = &#123;&#123;20, 10&#125;, &#123;18, 9&#125;&#125;; //可以看到，数组里面存放的居然是数组//存放的内层数组的长度是需要确定的，存放数组的数组和之前一样，可以根据后面的值决定 比如现在我们要存放2020-2022年每个月的天数，那么此时用一维数组肯定是不方便了，我们就可以使用二维数组来处理： 123int arr[3][12] = &#123;&#123;31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;, //2020年是闰年，2月有29天 &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;, &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;&#125;; 这样，我们就通过二维数组将这三年每个月的天数都保存下来了。 那么二维数组又该如何去访问呢？ 12345678#include &lt;stdio.h&gt;int main() &#123; int arr[3][12] = &#123;&#123;31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;, //2020年是闰年，2月有29天 &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;, &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;&#125;; printf(&quot;%d&quot;, arr[0][1]); //比如现在我们想要获取2020年2月的天数，首先第一个是[0]表示存放的第一个数组，第二个[1]表示数组中的第二个元素&#125; 当然除了二维还可以上升到三维、四维： 1int arr[2][2][2] = &#123;&#123;&#123;1, 2&#125;, &#123;1, 2&#125;&#125;, &#123;&#123;1, 2&#125;, &#123;1, 2&#125;&#125;&#125;; 有关多维数组，暂时先介绍到这里。 实战：冒泡排序算法现在有一个int数组，但是数组内的数据是打乱的，现在请你通过C语言，实现将数组中的数据按从小到大的顺序进行排列： 123456#include &lt;stdio.h&gt;int main() &#123; int arr[10] = &#123;3, 5, 7, 2, 9, 0, 6, 1, 8, 4&#125;; //乱序的 //请编写代码对以上数组进行排序&#125; 这里我们使用冒泡排序算法来实现，此算法的核心思想是： 假设数组长度为N 进行N轮循环，每轮循环都选出一个最大的数放到后面。 每次循环中，从第一个数开始，让其与后面的数两两比较，如果更大，就交换位置，如果更小，就不动。 动画演示：https://visualgo.net/zh/sorting?slide=2-2 实战：斐波那契数列解法其二学习了数组，我们来看看如何利用数组来计算斐波那契数列，这里采用动态规划的思想。 动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 我们可以在一开始创建一个数组，然后从最开始的条件不断向后推导，从斐波那契数列的规律我们可以得知： fib[i] = fib[i - 1] + fib[i - 2]（这里fib代表斐波那契数列） 得到这样的一个关系（递推方程）就好办了，我们要求解数列第i个位置上的数，只需要知道i - 1和i - 2的值即可，这样，一个大问题，就分成了两个小问题，比如现在我们要求解斐波那契数列的第5个元素： fib[4] = fib[3] + fib[2]现在我们只需要知道fib[3]和fib[2]即可，那么我们接着来看： fib[3] = fib[2] + fib[1]以及fib[2] = fib[1] + fib[0] 由于fib[0]和fib[1]我们已经明确知道是1了，那么现在问题其实已经有结果了，把这些小问题的结果组合起来不就能得到原来大问题的结果了吗？ 现在请你设计一个C语言程序，利用动态规划的思想解决斐波那契数列问题。 实战：打家劫舍我们继续通过一道简单的算法题来强化动态规划思想。 来源：力扣（LeetCode）No.198 打家劫舍：https://leetcode.cn/problems/house-robber/ 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 示例 2： 输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。 偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。 这道题我们也可以很轻松地按照上面的动态规划思路来处理，首先我们可以将问题分为子问题，比如现在有[2,7,9,3,1]五个房屋，这个问题看起来比较复杂，我们不妨先将大问题先简化成小问题，我们来看看只有N个房屋的情况： 假设现在只有[2]这一个房屋，那么很明显，我可以直接去偷一号房，得到2块钱，所以当有一个房子时最大能偷到2块钱。 假设现在有[2, 7]这两个房屋，那么很明显，我可以直接去偷二号房，得到7块钱，所以当有两个房子时最大能偷到7块钱。 假设现在只有[2, 7, 9]这三个房屋，我们就要来看看了，是先偷一号房再偷三号房好，还是只偷二号房好，根据前面的结论，如果我们偷了一号房，那么就可以继续偷三号房，并且得到的钱就是从一号房过来的钱+三号房的钱，也就是2+9块钱，但是如果只偷二号房的话，那么就只能得到7块钱，所以，三号房能够偷到的最大金额有以下关系（dp是我们求出的第i个房屋的最大偷钱数量，value表示房屋价值，max表示取括号中取最大的一个）： dp[i] = max(dp[i - 1], dp[i - 2] + value[i]) -&gt; 递推方程已得到 这样就不难求出：dp[2] = max(dp[1], dp[0] + value[i]) &#x3D; dp[2] = max(7, 2 + 9) &#x3D; dp[2] = 11，所以有三个房屋时最大的金额是11块钱。 所以，实际上我们只需要关心前面计算出来的盗窃最大值即可，而不需要关心前面到底是怎么在偷。 我们以同样的方式来计算四个房屋[2, 7, 9, 3]的情况： dp[3] = max(dp[2], dp[1] + value[3]) &#x3D; dp[3] = max(11, 7 + 3) &#x3D; dp[3] = 11 所以，当有四个房屋时，我们依然采用先偷一后偷三的方案，不去偷四号，得到最大价值11块钱。 好了，现在思路已经出来了，我们直接上算法吧，现在请你实现下面的C语言程序： 123456789#include &lt;stdio.h&gt;int main() &#123; int arr[] = &#123;2,7,9,3,1&#125;, size = 5, result; //请补充程序 printf(&quot;%d&quot;, result);&#125; 力扣提交，建议各位小伙伴学习了函数和指针之后再回来看看，这里暂时可以跳过。 12345678910111213141516171819int max(int a, int b) &#123; return a &gt; b ? a : b;&#125;int rob(int* nums, int numsSize)&#123; if(numsSize == 0) return 0; if(numsSize == 1) return nums[0]; if(numsSize == 2) return max(nums[1], nums[0]); int dp[numsSize]; dp[0] = nums[0]; dp[1] = max(nums[1], nums[0]); for (int i = 2; i &lt; numsSize; ++i) &#123; dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]); &#125; return dp[numsSize - 1];&#125; 字符串前面我们学习了数组，而对于字符类型的数组，比较特殊，它实际上可以作为一个字符串（String）表示，字符串就是一个或多个字符的序列，比如我们在一开始认识的&quot;Hello World!&quot;，像这样的多个字符形成的一连串数据，就是一个字符串，而printf函数接受的第一个参数也是字符串。 那么，我们就来认识一下字符串。 字符串的创建和使用在C语言中并没有直接提供存储字符串的类型，我们熟知的能够存储字符的只有char类型，但是它只能存储单个字符，而一连串的字符想要通过变量进行保存，那么就只能依靠数组了，char类型的数组允许我们存放多个字符，这样的话就可以表示字符串了。 比如我们现在想要存储Hello这一连串字符： 12char str[] = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;\\0&#x27;&#125;; //直接保存单个字符，但是注意，无论内容是什么，字符串末尾必须添加一个‘\\0’字符（ASCII码为0）表示结束。printf(&quot;%s&quot;, str); //用%s来作为一个字符串输出 不过这样写起来实在是太麻烦了，我们可以使用更加简便的写法： 123char str[] = &quot;Hello&quot;; //直接使用双引号将所有的内容囊括起来，并且也不需要补充\\0（但是本质上是和上面一样的字符数组）//也可以添加 const char str[] = &quot;Hello World!&quot;; 双引号囊括的字符串实际上就是一个const char数组类型的值printf(&quot;%s&quot;, str); 这下终于明白了，原来我们一直在写的双引号，其实表示的就是一个字符串。 那么现在请各位小伙伴看看下面的写法有什么不同： 12&quot;c&quot;&#x27;c&#x27; 我们发现一个问题，char类型只能保存ASCII编码表中的字符，但是我们发现实际上中文也是可以正常打印的： 1printf(&quot;你这瓜保熟吗&quot;); 这是什么情况？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文。这时，我们就需要扩展字符集了。 我们可以使用两个甚至多个字节来表示一个中文字符，这样我们能够表示的数量就大大增加了，GB2132方案规定当连续出现两个大于127的字节时（注意不考虑符号位，此时相当于是第一个bit位一直为1了），表示这是一个中文字符（所以为什么常常有人说一个英文字符占一字节，一个中文字符占两个字节），这样我们就可以表示出超过7000种字符了，不仅仅是中文，甚至中文标点、数学符号等，都可以被正确的表示出来。 110000011 10000110 //这就是一个连续出现都大于127的字节（注意这里是不考虑符号位的） 不过这样能够表示的内容还是不太够，除了那些常见的汉字之外，还有很多的生僻字，比如龘、錕、釿、拷这类的汉字，后来干脆直接只要第一个字节大于127，就表示这是一个汉字的开始，无论下一个字节是什么内容（甚至原来的128个字符也被编到新的表中），这就是Windows至今一直在使用的默认GBK编码格式。 虽然这种编码方式能够很好的解决中文无法表示的问题，但是由于全球还有很多很多的国家以及很多很多种语言，所以我们的最终目标是能够创造一种可以表示全球所有字符的编码方式，整个世界都使用同一种编码格式，这样就可以同时表示全球的语言了。所以这时就出现了一个叫做ISO的（国际标准化组织）组织，来定义一套编码方案来解决所有国家的编码问题，这个新的编码方案就叫做Unicode，规定每个字符必须使用俩个字节，即用16个bit位来表示所有的字符（也就是说原来的那128个字符也要强行用两位来表示） 但是这样的话实际上是很浪费资源的，因为这样很多字符都不会用到两字节来保存，但是又得这样去表示，这就导致某些字符浪费了很多空间。所以最后就有了UTF-8编码格式，区分每个字符的开始是根据字符的高位字节来区分的，比如用一个字节表示的字符，第一个字节高位以“0”开头；用两个字节表示的字符，第一个字节的高位为以“110”开头，后面一个字节以“10开头”；用三个字节表示的字符，第一个字节以“1110”开头，后面俩字节以“10”开头；用四个字节表示的字符，第一个字节以“11110”开头，后面的三个字节以“10”开头： Unicode符号范围（十六进制） UTF-8编码方式(二进制) 0000 0000 ~ 0000 007F 0xxxxxxx 0000 0080 ~ 0000 07FF 110xxxxx 10xxxxxx 0000 0800 ~ 0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000 ~ 0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 所以如果我们的程序需要表示多种语言，最好采用UTF-8编码格式。 简而言之，我们的中文实际上是依靠多个char来进行表示的。 这样，我们就了解了字符串的使用。 scanf、gets、puts函数函数我们会在下一章详细介绍，不过这里还是要再提到一个比较重要的函数。 前面我们认识了printf函数，实际上这个函数就是用于打印字符串到控制台，我们只需要填入一个字符串和后续的参数即可。 123456#include &lt;stdio.h&gt;int main() &#123; const char str[] = &quot;Hello World!&quot;; //注意printf需要填写一个const char数组进去，也就是字符串 printf(str);&#125; 现在我们知道该如何输出，那么输入该如何实现呢，比如我们现在希望将我们想要说的话告诉程序，让程序从控制台读取我们输入的内容，这时我们就需要使用到scanf函数了： 12345678#include &lt;stdio.h&gt;int main() &#123; char str[10]; scanf(&quot;%s&quot;, str); //使用scanf函数来接受控制台输入，并将输入的结果按照格式，分配给后续的变量 //比如这里我们想要输入一个字符串，那么依然是使用%s（和输出是一样的占位符），后面跟上我们要赋值的数组（存放输入的内容） printf(&quot;输入的内容为：%s&quot;, str);&#125; 可以看到，成功接收到用户输入： 当然除了能够扫描成字符串之外，我们也可以直接扫描为一个数字： 123456789#include &lt;stdio.h&gt;int main() &#123; int a, b; scanf(&quot;%d&quot;, &amp;a); //连续扫描两个int数字 scanf(&quot;%d&quot;, &amp;b); //注意，如果不是数组类型，那么这里在填写变量时一定要在前面添加一个&amp;符号（至于为什么，下一章在指针小节中会详细介绍）这里的&amp;不是做与运算，而是取地址操作。 printf(&quot;a + b = %d&quot;, a + b); //扫描成功后，我们来计算a + b的结果&#125; 除了使用scanf之外，我们也可以使用字符串专用的函数来接受字符串类型的输入和输出： 1234567#include &lt;stdio.h&gt;int main() &#123; char str[10]; gets(str); //gets也是接收控制台输入，然后将结果丢给str数组中 puts(str); //puts其实就是直接打印字符串到控制台&#125; 当然也有专门用于字符输入输出的函数： 123456#include &lt;stdio.h&gt;int main() &#123; int c = getchar(); putchar(c);&#125; 由于我们目前还没有学习函数，所以这里稍微提及一下即可。 实战：回文串判断“回文串”是一个正读和反读都一样的字符串，请你实现一个C语言程序，判断用户输入的字符串（仅出现英文字符）是否为“回文”串。 ABCBA 就是一个回文串，因为正读反读都是一样的 ABCA 就不是一个回文串，因为反着读不一样 实战：字符串匹配KMP算法现在有两个字符串： str1 &#x3D; “abcdabbc” str2 &#x3D; “cda” 现在请你设计一个C语言程序，判断第一个字符串中是否包含了第二个字符串，比如上面的例子中，很明显第一个字符串包含了第二个字符串。 暴力解法 KMP算法 我们着重来看一下KMP算法，实际上我们发现，暴力解法虽然很好理解，但是可能会做一些毫无意义的比较： 当发生不匹配时，又会重新开始比较下一个： 但是我们不难发现，因为不匹配的位置发生在第三个字符，而前面是a,b两个字符都匹配，显然完全没有必要再继续挨着去比较a和b了，因为很明显不可能匹配。 实际上我们可以直接跳过b，因为我们一眼就能看出肯定不匹配，所以直接跳过从后面继续判断，能节省不少的时间。我相信如果让你通过自己的人脑去进行匹配，也是按照这样的方式去比较的吧？ 不过关键点就在于怎么在程序中得知该不该跳过呢，又该跳过多少个字符不判断呢？所以我们在拿到子串的时候，就需要根据子串来计算一个叫做next的数组，与子串的长度相同，它存储了当不匹配发生在对应的位置上时，应该在哪一个位置开始继续比较。 这里说一下怎么去求（计算机领域大佬总结出来的算法）： 从第一位开始依次推导。 next数组的第一位一定是0。 从第二位开始（用i表示），将第i-1个字符（也就是前一个）与其对应的next[i - 1] - 1位上的字符进行比较。 如果相等，那么next[i]位置的值就是next[i - 1] + 1 如果不相等，则继续向前计算一次next[next[i-1] - 1] - 1位置上的字符和第i-1个字符是否相同，直到找到相等的为止，并且这个位置对应的值加上1就是next[i]的值了，要是都已经到头了都没遇到相等的，那么next[i]直接等于1。 比如： 首先一二位明确是0和1，这里我们从第三位开始计算，根据我们前面的规则： 首先判断str[next[1] - 1] == str[1]，显然不相等。 此时无法继续向前走了，next[2]直接等于1即可。 我们接着来看第四位： 首先判断str[next[2] - 1] == str[2]，发现相等。 此时next[2]直接等于next[2 - 1] + 1即可。 最后一位也是一样的判断方式： 首先判断str[next[3] - 1] == str[3]，发现相等。 此时next[3]直接等于next[3 - 1] + 1即可。 至此，next数组求解完毕，之后比较只需要多考虑一下next数组即可： 当不匹配发生在第三位时，此时next[2] = 1， 所以我们将第一个元素移动到c的位置重新开始比较： 发现不匹配，直接继续向后比较，重复上述操作，像这样这样跳着去比较就大大节省了时间。 OK，理论差不多结束了，上代码。 有关C语言的基础部分内容，我们就讲解到这里，从下一章开始，难度将会有一定的提升，所以请各位小伙伴务必将本章知识点梳理清楚，牢记心中。","categories":[{"name":"C语言基础知识","slug":"C语言基础知识","permalink":"http://example.com/categories/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C语言基础-2","slug":"C语言基础-2","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2/"}]},{"title":"C语言(1)","slug":"C语言-1","date":"2022-10-14T16:23:29.000Z","updated":"2022-10-14T16:28:28.542Z","comments":true,"path":"2022/10/15/C语言-1/","link":"","permalink":"http://example.com/2022/10/15/C%E8%AF%AD%E8%A8%80-1/","excerpt":"","text":"温馨提示：所有的笔记（需要使用Typora软件打开）在视频下方简介中直接获取，纯个人录制，不用加什么公众号这些，各位小伙伴直接网盘自取吧。 计算机思维导论计算机自1946年问世以来，几乎改变了整个世界。 现在我们可以通过电脑来做很多事情，比如我们常常听到的什么人工智能、电子竞技、大数据等等，都和计算机息息相关，包括我们现在的手机、平板等智能设备，也是计算机转变而来的。各位可以看看最顶上的这张图片，如果你在小时候接触过计算机，那么一定对这张图片（照片拍摄于1996年，在美国加利福尼亚州加利福尼亚州的锁诺玛县）印象深刻，这张壁纸作为WindowsXP系统的默认壁纸，曾经展示在千家万户的电脑屏幕上。 也许你没有接触过计算机，也许你唯一接触计算机就是用来打游戏，也有可能你曾经捣鼓过计算机，在学习C语言之前，先让我们来了解一下计算机的世界。 计算机的世界计算机虽然名字听着很高级，不过它也是由一个个简单电路组成的。 这是我们在初中就学习过的电路图，不过这种电路太过简单，只能完成一些很基础的的操作，比如点亮小灯泡等。 很明显想要实现计算机怎么高级的运算机器，肯定是做不到的，这时我们就需要引入更加强大的数字电路了。 用数字信号完成对数字量进行算术运算和逻辑运算的电路称为数字电路，或数字系统。由于它具有逻辑运算和逻辑处理功能，所以又称数字逻辑电路。现代的数字电路由半导体工艺制成的若干数字集成器件构造而成。逻辑门是数字逻辑电路的基本单元。 计算机专业一般会在大一开放《数字电路》这门课程，会对计算机底层的数字电路实现原理进行详细介绍。 数字电路引入了逻辑判断，我们来看看简单的数字电路： 数字电路中，用电压的高低来区分出两种信号，低电压表示0，高电压表示1，由于只能通过这种方式表示出两种类型的信号，所以计算机采用的是二进制。 二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”。 比如我们一般采用的都是十进制表示，比如9再继续加1的话，就需要进位了，变成10，在二进制中，因为只有0和1，所以当1继续加1时，就需要进位了，就变成10了（注意这不是十，读成一零就行了） 当然，仅仅有两种信号还不够，我们还需要逻辑门来辅助我们完成更多的计算，最基本的逻辑关系是与、或、非，而逻辑门就有相应的是与门、或门和非门，可以用电阻、电容、二极管、三极管等分立原件构成（具体咋构成的咱这里就不说了） 比如与操作，因为只有两种类型，我们一般将1表示为真，0表示为假，与操作（用&amp;表示）要求两个数参与进来，比如： 1 &amp; 1 &#x3D; 1 必须两边都是真，结果才为真。 1 &amp; 0 &#x3D; 0 两边任意一个或者都不是真，结果为假。 或运算（用 | 表示）： 1 | 0 &#x3D; 1 两边只要有一个为真，结果就为真 0 | 0 &#x3D; 0 两边同时为假，结果才是假 非运算实际上就是取反操作（可以是 ! 表示） !1 &#x3D; 0 !0 &#x3D; 1 非运算会将真变成假，假变成真 有了这些运算之后，我们的电路不仅仅可以实现计算，也可以实现各种各样的逻辑判断，最终才能发展成我们的计算机。 前面我们大概介绍一下计算机的底层操作原理，接着我们来看看计算机的基本组成。 相信各位熟知的计算机都是一个屏幕+一个主机的形式，然后配上我们的键盘鼠标，就可以开始使用了，但是实际上标准的计算机结构并没有这么简单，我们来看看： 我们电脑最核心的部件，当属CPU，因为几乎所有的运算都是依靠CPU进行（各种各样的计算电路已经在CPU中安排好了，我们只需要发送对应的指令就可以进行对应的运算），它就像我们人的大脑一样，有了大脑才能进行思考。不过光有大脑还不行，还要有一些其他的部分来辅助工作，比如我们想向电脑里面打字，那么就需要连接一个键盘才能输入，我们想要点击桌面上的图标，那么就需要一个鼠标来操作光标，这些都是输入设备。我们的电脑开机之后显示器上会显示出画面，实际上显示器就是输出设备。 当然除了这些内容之外，我们的电脑还需要内存来保存运行时的一些数据，以及外存来保存文件（比如硬盘）等。我们常说的iPhone13 512G，这个512G并不是指的内存，而是指的外存，准确的说是用于存放文件硬盘大小，而真正的内存是我们常说的4G&#x2F;6G&#x2F;8G运行内存，内存的速度远高于外存的速度，所以1G内存的价格远超1G硬盘的价格。 计算机包括五大部件：运算器、控制器、存储器、输入和输出设备。有了这一套完整的硬件环境，我们的电脑才算是有了一个完整的身体。 问题：我们上面提到的这些硬件设备哪些是属于外设？ 操作系统概述前面我们了解了一下计算机的大致原理和组成结构，但是光有这一套硬件可不行，如何让这一套硬件按照我们想要的方式运作起来，也是非常重要的，这时我们就需要介绍操作系统了。 操作系统（operating system，简称OS）是管理计算机硬件与软件资源的计算机程序。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互操作的界面。 一般在计算机专业大二，会开放《操作系统》课程，会详细讲解操作系统的底层运作机制和调度。 一般我们电脑上都安装了Windows操作系统（苹果笔记本安装的是MacOS操作系统），现在主流的电脑都已经预装Windows11了： 有了操作系统，我们的电脑才能真正运行起来，我们就可以轻松地通过键盘和鼠标来操作电脑了。 不过操作系统最开始并不是图形化界面，它类似于Windows中的命令提示符： 没有什么图标这些概念，只有一个简简单单的黑框让我们进行操作，通过输入命令来进行一些简单的使用，程序的运行结果也会在黑框框（命令行）中打印出来，不过虽然仅仅是一个黑框，但是能运行的程序可是非常非常多的，只需要运行我们编写好的程序，就能完成各种各样复杂的计算任务，并且计算机的计算速度远超我们的人脑。 中国超级计算机系统天河二号，计算速度达到每秒5.49亿亿次。 当然，除了我们常见的Windows和MacOS系统之外，还有我们以后需要经常打交道的Linux操作系统，这种操作系统是开源的，意思是所有的人都可以拿到源代码进行修改，于是就出现了很多发行版： 这些发行版有带图形化界面的，也有不带图形化界面的，不带图形化界面的Linux将是我们以后学习的重点。 不同操作系统之间的软件并不是通用的，比如Windows下我们的软件一般是.exe后缀名称，而MacOS下则不是，并且也无法直接运行.exe文件，这是因为不同操作系统的具体实现会存在一些不同，程序编译（我们之后会介绍到）之后的格式也会不同，所以是无法做到软件通用的。 正是因为有了操作系统，才能够组织我们计算机的底层硬件（包括CPU、内存、输入输出设备等）进行有序工作，没有操作系统电脑就如同一堆废铁，只有躯壳没有灵魂。 计算机编程语言现在我们大致了解了我们的电脑的运作原理，实际上是一套完整的硬件+一个成形的操作系统共同存在的。接着我们就可以开始了解一下计算机的编程语言了。我们前面介绍的操作系统也是由编程语言写出来的，操作系统本身也算是一个软件。 那么操作系统是如何让底层硬件进行工作的呢？实际上就是通过向CPU发送指令来完成的。 计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。而指令集的先进与否，也关系到CPU的性能发挥，它也是CPU性能体现的一个重要标志。 我们电脑中的CPU有多种多样的，不同的CPU之间可能也会存在不同的架构，比如现在最常用的是x86架构，还有我们手机平板这样的移动设备使用的arm架构，不同的架构指令集也会有不同。 我们知道，计算机底层硬件都是采用的0和1这样的二进制表示，所以指令也是一样的，比如（这里随便写的）： 000001 - 代表开机 000010 - 代表关机 000011 - 代表进行加法运算 当我们通过电路发送给CPU这样的二进制指令，CPU就能够根据我们的指令执行对应的任务，而我们编写的程序保存在硬盘中也是这样的二进制形式，我们只需要将这些指令组织好，按照我们的思路一条一条执行对应的命令，就能够让计算机计算任何我们需要的内容了，这其实就是机器语言。 不过随着时代的进步，指令集越来越大，CPU支持的运算类型也越来越多，这样的纯二进制编写实在是太累了，并且越来越多的命令我们根本记不住，于是就有了汇编语言。汇编语言将这些二进制的操作码通过助记符来替换： MOV 传送字或字节。 MOVSX 先符号扩展,再传送。 MOVZX 先零扩展,再传送。 PUSH 把字压入堆栈。 把这些原有的二进制命令通过一个单词来代替，这样是不是就好记多了，在程序编写完成后，我们只需要最后将这些单词转换回二进制指令就可以了，这也是早期出现的低级编程语言。 不过虽然通过这些助记符就能够很轻松地记住命令，但是还是不够方便，因为可能我们的程序需要完成一个很庞大的任务，但是如果还是这样一条一条指令进行编写，是不是太慢了点，有时候可能做一个简单的计算，都需要好几条指令来完成。于是，高级编程语言——C语言，终于诞生了。 C语言诞生于美国的贝尔实验室，由丹尼斯·里奇（Dennis MacAlistair Ritchie）以肯尼斯·蓝·汤普森（Kenneth Lane Thompson）设计的B语言为基础发展而来，在它的主体设计完成后，汤普森和里奇用它完全重写了UNIX操作系统，且随着UNIX操作系统的发展，C语言也得到了不断的完善。 高级语言不同于低级语言，低级语言的主要操作对象是指令本身，而高级语言却更加符合我们人脑的认知，更像是通过我们人的思维，去告诉计算机你需要做什么，包括语法也会更加的简单易懂。下面是一段简单的C语言代码： 123456int main() &#123; int a = 10; //定义一个a等于10 int b = 10; //定义一个b等于10 int c = a + b; //语义非常明确，c就是a加上b计算出来的结果。 return 0;&#125; 不过现在看不懂没关系，我们后面慢慢学。 C语言虽然支持按照我们更容易理解的方式去进行编程，但是最后还是会编译成汇编指令最后变成计算机可以直接执行的指令，不过具体的编译过程，我们不需要再关心了，我们只需要去写就可以了，而对我们代码进行编译的东西，称为编译器。 当然，除了C语言之外，还有很多其他的高级语言，比如Java、Python、C#、PHP等等，相比其他编程语言，C算是比较古老的一种了，但是时隔多年直至今日，其他编程语言也依然无法撼动它的王者地位： 可以看到在2021年9月，依然排在编程语言排行榜的第一名（Python和Java紧随其后），可见这门语言是多么的不可撼动，很多操作系统、高级编程语言底层实现，几乎都是依靠C语言去编写的（包括Java的底层也是C&#x2F;C++实现的）所以学习这一门语言，对于理工科尤其是计算机专业极为重要，学好C语言你甚至可以融汇贯通到其他语言，学起来也会轻松很多。 那么从下节课开始，我们就先做好一些环境上的准备。 C语言开发环境部署完成开发环境部署之后，我们就可以使用C语言来将一句话输出到控制台了，成功编译运行下面的简单程序： 123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;Hello, World!\\n&quot;); return 0;&#125; 首先，我们既然要将我们编写的C语言代码进行编译，那么肯定得找到一个合适的编译器才行，现代的集成开发环境IDE一般都包含了这些编译器，所以我们不需要进行单独的安装。 我们只需要找一个集成开发环境去安装就行了，目前功能比较完善的集成开发环境有： Codeblocks（支持Windows、Linux、MacOS操作系统） Visual Studio（支持Windows、MacOS操作系统） CLion（支持Windows、Linux、MacOS操作系统） 这里我们就使用CLion作为我们的开发工具使用（这个IDE是收费的，但是学生可以申请免费使用，别担心，大学四年肯定是够你用了，选这个是考虑到后面同学们可能会继续学习Java，Java语言的推荐IDE也是同一个公司的产品，界面都长得差不多）当然如果你想要使用其他的开发工具，也可以，但是这里我们就不演示了。 首先前往官网下载：CLion: A Cross-Platform IDE for C and C++ by JetBrains 下载完成后我们直接点击安装： 如果你不是很熟悉，建议直接点Next安装到C盘默认路径，不要去修改，当然如果确实C盘没有空间，那可以自行修改为其他路径，但是注意最好路径中不要出现中文。 勾选一下创建快捷方式，然后继续点Next等待安装就行了： 安装完成后，我们可以直接打开： 这里会提示我们激活，点击按钮去官网注册一个账号。注册完成后，推荐去申请一下学生授权，因为试用只有30天：Jetbrains学生授权获取指南 - 知乎 (zhihu.com) 这里我们点击开始试用，然后就可以点击Continue了，现在成功来到主界面： 由于是英文，使用不太方便，所以我们安装一下中文插件： 现在我们就成功安装好CLion集成开发环境了。 现在我们来创建我们的第一个C语言项目（我们的程序是以一个项目的形式进行管理的，这里知道怎么创建就行了）： 这里选择C可执行文件，然后项目的保存位置可以自行修改，配置完成后点击创建： 可以看到，在创建之后，会自动为我们生成一段示例代码，而之后我们要编写的代码，都在生成的main.c中进行编写，除了这个文件，其他的全部不要去修改，也不用管是什么意思，后面我们会慢慢介绍。 接着我们需要配置一下工具链，选择捆绑的MinGW（如果已经有了就不需要配置了） 那么这段示例代码有了，我们如何编译运行呢？ 我们可以点击代码旁边的绿色三角形符号或是右上角的绿色三角形，就可以直接编译运行我们的代码了。运行的结果是在控制台输出一个“HelloWorld！”，当然我们也可以直接运行编译出来的可执行文件： 我们可以看到，这里生成了一个项目名称.exe文件，这种就是Windows环境下可以直接运行的应用程序，我们可以打开这个文件夹，直接使用cmd来运行： 运行出来的效果是一样的，这种程序实际上就是最原始的命令行程序，输入和输出都是在这种黑框框中进行的，而我们的主要学习目标也是这种命令行程序。 这样我们就配置好了开发环境，然后就不要去动其他的东西了，一般新手最容易遇到一些奇奇怪怪的问题。","categories":[{"name":"C语言基础知识","slug":"C语言基础知识","permalink":"http://example.com/categories/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"C语言基础-1","slug":"C语言基础-1","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-1/"}]},{"title":"day03-JDBC","slug":"day03-JDBC","date":"2022-09-19T01:09:17.000Z","updated":"2022-10-05T07:05:19.987Z","comments":true,"path":"2022/09/19/day03-JDBC/","link":"","permalink":"http://example.com/2022/09/19/day03-JDBC/","excerpt":"","text":"Course：JDBC 数据库编程 一、JDBC介绍 JDBC (Java DataBase Contectivity) Java与数据库的连接——数据库编程 JDBC 是Java语言（JDK）为完成数据库的访问操作提供的一套统一的标准。 二、JDBC步骤 三、JDBC入门案例 JDBC 是用Java代码完成数据访问的规范 3.1 加载驱动3.1.1 下载驱动jar包 对应数据库匹配版本的驱动jar包 地址https://mvnrepository.com/ 搜索mysql 选择版本下载 MySQL数据库版本为5.x,驱动jar包建议使用5.1.47 MySQL数据库版本为8.x,驱动jar包建议使用8.0.x 3.1.2 将驱动jar文件添加到Java应用 在java应用中创建lib文件夹 将下载好的jar文件拷贝—粘贴到lin目录 将驱动jar文件设置为java库：选择lib&#x2F;驱动jar—右键—Add as Library.. —OK 3.1.3 注册驱动 通过反射机制，将驱动jar文件中提供的驱动类载入到JVM中 12//1.注册驱动（驱动jar包中的驱动类（Driver）的路径：com.mysql.cj.jdbc.Driver）Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); 3.2 创建连接12345678910//2.创建连接：通过数据库驱动管理器 DriverManager（java.sql.Driver）获取连接// JDBC JDK提供的数据库连接的规范 --- java.sql// java.sql.Connection接口 一个对象就表示一个数据库连接// url 数据库的统一资源定位器（定位数据库连接资源）// url参数// characterEncoding 设置编码// useSSL=true 使用SSL通信// useTimezone=true 设置客户端和服务端时区转换String url = &quot;jdbc:mysql://localhost:3306/db_test3&quot;;Connection connection = DriverManager.getConnection(url,&quot;root&quot;,&quot;@QFedu123&quot;); 3.3 编写SQL指令12//3.编写要执行的SQL指令:SQL指令中需要的参数可以通过字符串拼接的形式（会导致SQL注入）String sql = &quot;insert into books(book_id,book_name,book_author,book_price,book_stock,book_desc) values(&#x27;&quot;+id+&quot;&#x27;,&#x27;&quot;+name+&quot;&#x27;,&#x27;&quot;+author+&quot;&#x27;,&quot;+price+&quot;,&quot;+stock+&quot;,&#x27;&quot;+desc+&quot;&#x27;)&quot;; 3.4 加载SQL指令1234//4.加载SQL指令:获取SQL指令的加载器// java.sql.Statement 对象 可以理解为 SQL指令的“加载器”// java.sql.PreparedStatement 对象 SQL指令的“预编译加载器”Statement statement = connection.createStatement(); 3.5 执行SQL、获取结果123456//5.执行SQL获取执行结果// a. 如果SQL指令为DQL,则 ResultSet rs = statement.executeQuery(sql); rs中就是查询结果// b. 如果SQL指令为DML，则 int i = statement.executeUpdate(sql); i就表示DML操作影响的数据行数// 如果i&gt;0，表示DML操作是成功的；如果i=0表示DML操作对数据表中的数据没有影响int i = statement.executeUpdate(sql); 3.6 处理结果123456//6.处理结果（业务）// 添加操作：返回值i&gt;0表示添加成功，否则表示添加失败// 修改操作：返回值i&gt;0表示修改对数据有影响，如果i=0 表示对数据库没有影响// 删除操作：返回值i&gt;0表示删除对数据有影响，如果i=0 表示对数据库没有影响// 查询操作：从ResultSet rs中取出查询结果，封装到Java对象中System.out.println(i&gt;0?&quot;添加成功&quot;:&quot;添加失败&quot;); 3.7 关闭连接12345678910//7.关闭连接// 如果执行DML操作：需要关闭Statement和Connection// 如果执行DQL操作：需要关闭ResultSet、Statement和Connection// 关闭之前先判空、由大到大关闭if(statement != null &amp;&amp; !statement.isClosed())&#123; statement.close();&#125;if(connection !=null &amp;&amp; !connection.isClosed())&#123; connection.close();&#125; 四、JDBC增删查改操作实例 使用JDBC完成数据库的CRUD访问 4.1 insert操作1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestInsertBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; String name = &quot;Java进阶之路&quot;; String author = &quot;老王&quot;; double price = 22.22; int stock = 10; String desc = &quot;这本书很好&quot;; //1.注册驱动（驱动jar包中的驱动类（Driver）的路径：com.mysql.cj.jdbc.Driver） Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2.创建连接：通过数据库驱动管理器 DriverManager（java.sql.Driver）获取连接 String url = &quot;jdbc:mysql://localhost:3306/db_test3&quot;; Connection connection = DriverManager.getConnection(url,&quot;root&quot;,&quot;@QFedu123&quot;); //3.编写要执行的SQL指令 String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(&#x27;&quot;+name+&quot;&#x27;,&#x27;&quot;+author+&quot;&#x27;,&quot;+price+&quot;,&quot;+stock+&quot;,&#x27;&quot;+desc+&quot;&#x27;)&quot;; //4.加载SQL指令:获取SQL指令的加载器 Statement statement = connection.createStatement(); //5.执行SQL获取执行结果 int i = statement.executeUpdate(sql); //6.处理结果（业务） System.out.println(i&gt;0?&quot;添加成功&quot;:&quot;添加失败&quot;); //7.关闭连接 if(statement != null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection !=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 4.2 delete操作1234567891011121314151617181920212223242526272829303132/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestDeleteBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; int bid = 1012; //使用JDBC，根据图书编号删除图书信息 //1.注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2.创建连接 String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); //3.编写SQL String sql = &quot;delete from books where book_id=&quot;+bid; //4.获取SQL加载器 Statement statement = connection.createStatement(); //5.执行SQL int i = statement.executeUpdate(sql); //6.处理结果 System.out.println(i&gt;0?&quot;删除成功&quot;:&quot;删除失败&quot;); //7.关闭连接 if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 4.3 update操作123456789101112131415161718192021222324252627282930313233343536373839package com.qfedu.jdbc.les1;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestUpdateBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; // 根据数据记录的主键 修改其他的字段 // 根据图书ID，修改图书名称、作者、价格、库存、描述 int id = 1011; String name = &quot;Java进阶之路&quot;; String author = &quot;亮亮&quot;; double price = 36.80; int stock = 8; String desc = &quot;这本书非常好&quot;; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); String sql = &quot;update books set book_name=&#x27;&quot;+name+&quot;&#x27;,book_author=&#x27;&quot;+author+&quot;&#x27;,book_price=&quot;+price+&quot;,book_stock=&quot;+stock +&quot;,book_desc=&#x27;&quot;+desc+&quot;&#x27; where book_id=&quot;+id; Statement statement = connection.createStatement(); int i = statement.executeUpdate(sql); System.out.println(i&gt;0?&quot;修改成功&quot;:&quot;修改失败&quot;); if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 4.4 select操作（一条结果） 结果集处理 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.qfedu.jdbc.les1;import java.sql.*;/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestSelectBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //根据图书ID，查询一本图书信息 int bid = 1011; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=&quot;+bid; Statement statement = connection.createStatement(); //通过executeQuery方法执行查询语句，并且将查询的结果存放到一个ResultSet对象中（结果集） ResultSet rs = statement.executeQuery(sql); //处理结果：从rs中获取查询结果 if(rs.next())&#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); System.out.println(bookId+&quot;\\t&quot;+bookName+&quot;\\t&quot;+bookAuthor+&quot;\\t&quot;+bookPrice+&quot;\\t&quot;+bookStock+&quot;\\t&quot;+bookDesc); &#125; //关闭连接 结果集也需要关闭 if(rs!=null &amp;&amp; !rs.isClosed())&#123; rs.close(); &#125; if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 4.5 select操作（多条结果）123456789101112131415161718192021222324252627282930313233343536373839package com.qfedu.jdbc.les1;import java.sql.*;/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestSelectBooks &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //查询所有图书信息 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books&quot;; Statement statement = connection.createStatement(); ResultSet rs = statement.executeQuery(sql); while(rs.next())&#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); System.out.println(bookId+&quot;\\t&quot;+bookName+&quot;\\t&quot;+bookAuthor+&quot;\\t&quot;+bookPrice+&quot;\\t&quot;+bookStock+&quot;\\t&quot;+bookDesc); &#125; if(rs!=null &amp;&amp; !rs.isClosed())&#123; rs.close(); &#125; if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 五、JDBC的核心类与接口 java.sql.DriverManager类 驱动管理器 java.sql.Connection接口 数据库连接 java.sql.Statement接口 SQL指令的“加载&#x2F;执行器” java.sql.ResultSet接口 结果集 5.1 DriverManager类 注册驱动 创建数据库连接 注册驱动 12345// 在Driver类中的静态初始化块中，注册驱动：DriverManager.registerDriver(new Driver());Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);// 在我们的应用程序中手动注册驱动的代码也可以省略 【Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);】// 如果我们没有手动注册驱动，驱动管理器在获取连接的时候发现没有注册驱动则读取 驱动jar/META-INF/servicesjava.sql.Driver文件中配置的驱动类路径进行注册 获取连接 1234// url 数据库服务器的地址// username 数据库连接用户名// password 数据库连接密码Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); 5.2 Connection接口 Connection对象表示Java应用程序与数据库之间的连接 通过Connection接口对象，获取执行SQL语句的Statement对象 完成数据的事务管理 5.2.1 获取Statement对象 Statement接口: 编译执行静态SQL指令 1Statement statement = connection.createStatement(); PreparedStatement接口：继承了Statement接口，预编译动态SQL指令（解决SQL注入问题） 1PreparedStatement preparedStatement = connection.prepareStatement(sql); CallableStatement接口：继承了PreparedStatement接口，可以调用存储过程 1CallableStatement callableStatement = connection.prepareCall(sql); 5.2.2 事务管理12345678//开启事务（关闭事务自动提交）connection.setAutoCommit(false);//事务回滚connection.rollback();//提交事务connection.commit(); 5.3 Statement接口 用于编译、执行SQL指令的 12345// 执行DML操作的SQL指令int i = statement.executeUpdate(sql);// 执行DQL操作的SQL指令ResultSet rs = statement.executeQuery(sql); 5.4 ResultSet接口 ResultSet接口对象，表示查询操作返回的结果集，提供了便利的方法用于获取结果集中的数据 判断结果集中是否还有数据未取出 1234ResultSet rs = statement.executeQuery(select_statement);// 判断rs中是否还有数据rs.next(); 获取rs指向的结果集中某行的数据 1234567int id = rs.getInt(String columnLable); //获取rs指向的行的 列 数据（字段名）int id = rs.getInt(int columnIndex);rs.getString(&quot;&quot;); //获取String类型数据rs.getDouble(&quot;&quot;); //获取Double类型数据....rs.getDate(&quot;&quot;); //获取日期类型数据 六、SQL注入问题6.1 什么是SQL注入问题？ 在JDBC操作SQL指令编写过程中，如果SQL指令中需要数据，我们可以通过字符串拼接的形式将参数拼接到SQL指令中，如String sql = &quot;delete from books where book_id=&quot;+s;(s就是拼接到SQL中的变量) 使用字符串拼接变量的形式来设置SQL语句中的数据，可能会导致因变量值的改变引起SQL指令的原意发生改变，这就被称为SQL注入。SQL注入问题是需要避免的。 例如： 如果s的值为1，SQL指令 ： delete from books where book_id&#x3D;1 如果s的值为1 or 1=1，SQL指令：delete from books where book_id&#x3D;1 or 1&#x3D;1 6.2 如何解决SQL注入问题？ 使用PreparedStatement进行SQL预编译解决SQL注入问题： 在编写SQL指令时，如果SQL指令中需要参数，一律使用?参数占位符 如果SQL指令中有?，在JDBC操作步骤中不再使用Statement，而是从Conection对象获取PreparedStatement对SQL指令进行预编译 PreparedStatement preparedStatement = connection.prepareStatement(sql); 预编译完成之后，通过PreparedStatement对象给预编译后的SQL指令的?复制 prepareadStatement.setInt(参数占位符序号,值); prepareadStatement.setString(参数占位符序号,值); SQL指令中的所有?完成赋值之后，通过PreparedStatement执行SQL执行SQL时不再加载SQL int i &#x3D; prepareadStatement.executeUpdate(); ResultSet rs &#x3D; preparedStatement.executeQuery(); 6.3 使用PreparedStatement预编译案例 删除操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.qfedu.jdbc.les1;import com.mysql.cj.jdbc.Driver;import java.sql.*;import java.util.Scanner;/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestDeleteBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入你要删除的图书的ID：&quot;); String s = scanner.nextLine(); int bid = Integer.parseInt(s); //1.注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2.创建连接 String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); //3.编写SQL:SQL指令中的参数使用?表示 String sql = &quot;delete from books where book_id=?&quot;; //4.如果SQL指令有参数占位符?,则从Connection获取PreparedStatement预编译SQL指令 // 预编译：在SQL指令中的参数赋值之前对SQL执行的语法结构进行编译 PreparedStatement preparedStatement = connection.prepareStatement(sql); // SQL指令预编译之后，给SQL中的?赋值 preparedStatement.setInt(1,bid); //5.执行SQL int i = preparedStatement.executeUpdate(); //6.处理结果 System.out.println(i&gt;0?&quot;删除成功&quot;:&quot;删除失败&quot;); //7.关闭连接 if(preparedStatement!=null &amp;&amp; !preparedStatement.isClosed())&#123; preparedStatement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 修改操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.qfedu.jdbc.les1;import java.sql.*;/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestInsertBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; String name = &quot;Java进阶之路&quot;; String author = &quot;老王&quot;; double price = 22.22; int stock = 10; String desc = &quot;这本书很好&quot;; //1.注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2.创建连接 String url = &quot;jdbc:mysql://localhost:3306/db_test3&quot;; Connection connection = DriverManager.getConnection(url,&quot;root&quot;,&quot;@QFedu123&quot;); //3.编写要执行的SQL指令:SQL指令中所需的参数一律使用? String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; //4.SQL中有? 使用PreparedStatement预编译SQL PreparedStatement preparedStatement = connection.prepareStatement(sql); // 给SQL指令中的?复制 preparedStatement.setString(1,name); preparedStatement.setString(2,author); preparedStatement.setDouble(3,price); preparedStatement.setInt(4,stock); preparedStatement.setString(5,desc); //5.执行SQL获取执行结果 int i = preparedStatement.executeUpdate(); //6.处理结果（业务） System.out.println(i&gt;0?&quot;添加成功&quot;:&quot;添加失败&quot;); //7.关闭连接 if(preparedStatement != null &amp;&amp; !preparedStatement.isClosed())&#123; preparedStatement.close(); &#125; if(connection !=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 练习1：修改操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.qfedu.jdbc.les1;import java.sql.*;/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestUpdateBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; // 根据数据记录的主键 修改其他的字段 // 根据图书ID，修改图书名称、作者、价格、库存、描述 int id = 1011; String name = &quot;Java进阶之路&quot;; String author = &quot;亮亮&quot;; double price = 36.80; int stock = 8; String desc = &quot;这本书非常好&quot;; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); //1. String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; //2. PreparedStatement preparedStatement = connection.prepareStatement(sql); //3. preparedStatement.setString(1,name); preparedStatement.setString(2,author); preparedStatement.setDouble(3,price); preparedStatement.setInt(4,stock); preparedStatement.setString(5,desc); //4. int i = preparedStatement.executeUpdate(); System.out.println(i&gt;0?&quot;修改成功&quot;:&quot;修改失败&quot;); //5. if(preparedStatement!=null &amp;&amp; !preparedStatement.isClosed())&#123; preparedStatement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 练习2：根据ID查询图书信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.qfedu.jdbc.les1;import java.sql.*;/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestSelectBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //根据图书ID，查询一本图书信息 int bid = 1013; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1,bid); //通过executeQuery方法执行查询语句，并且将查询的结果存放到一个ResultSet对象中（结果集） ResultSet rs = preparedStatement.executeQuery(); //处理结果：从rs中获取查询结果 if(rs.next())&#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); System.out.println(bookId+&quot;\\t&quot;+bookName+&quot;\\t&quot;+bookAuthor+&quot;\\t&quot;+bookPrice+&quot;\\t&quot;+bookStock+&quot;\\t&quot;+bookDesc); &#125; //关闭连接 结果集也需要关闭 if(rs!=null &amp;&amp; !rs.isClosed())&#123; rs.close(); &#125; if(preparedStatement!=null &amp;&amp; !preparedStatement.isClosed())&#123; preparedStatement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 备注 如果SQL指令中需要参数，则使用PreparedStatement进行SQL预编译，如果SQL指令中没有参数建议使用Statement（Statement执行效率要高于PreparedStatement）。 七、工具类封装7.1 代码的复用性在我们的应用程序中，如果需要完成相同的操作，相同的代码无需重复编写，我们只需一次编写多次调用即可！ JDBC数据库编程是由一个固定的步骤： 注册驱动 创建连接 编写SQL 获取Statement对象 执行SQL 处理结果 关闭连接 7.2 工具类封装 DBManager DBUtil JDBCUtil DBHelper 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.qfedu.jdbc.utils;import java.sql.*;/** * @Descript JDBC数据库连接帮助类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class DBHelper &#123; /*将创建数据库连接所需的字符串定义为常量，集中管理*/ private static final String DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;; private static final String URL = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; private static final String USERNAME = &quot;root&quot;; private static final String PASSWORD = &quot;@QFedu123&quot;; /** * 注册驱动只需执行一次，因此我们放在帮助类的静态初始化块中完成 */ static&#123; try &#123; Class.forName(DRIVER); &#125; catch (ClassNotFoundException e) &#123; System.out.println(&quot;-----------注册驱动失败&quot;); &#125; &#125; /** * 创建数据库连接对象 */ public static Connection getConnection()&#123; Connection connection = null; try &#123; connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); &#125; catch (SQLException e) &#123; System.out.println(&quot;-----------创建连接失败&quot;); &#125; return connection; &#125; /** * 关闭连接 * 多态的应用：使用Statement接口做参数，既可以传递Statement接口对象， * 也可以传递PreparedStatement接口对象 */ public static void close(Statement statement, Connection connection)&#123; close(null,statement,connection); &#125; /** * 关闭连接 */ public static void close(ResultSet resultSet,Statement statement, Connection connection)&#123; try &#123; if(resultSet!=null &amp;&amp; !resultSet.isClosed())&#123; resultSet.close(); &#125; if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;catch (Exception e)&#123; System.out.println(&quot;~~~~~关闭数据库连接失败&quot;); &#125; &#125;&#125; 八、DAO与DTO的封装 DAO Data Access Object 数据访问对象 DTO Data Transfer Object 数据传输对象（实体类） 用于传输DML操作参数及DQL的查询结果 8.1 CRUD方法的封装 面向对象的特征之一——封装 我们将能够完成某个CRUD操作的代码单独定义成一个方法，当需要完成此CRUD操作时调用这个方法即可; insert操作封装 delete操作封装 update操作封装 8.2 DTO实体类封装 问题：在封装CRUD方法时，对于查询操作而言，需要将查询到的数据库记录返回给调用者，但是一个查询方法只能返回一个值，而一条数据库记录有多个值，如何将一条数据库记录的多个值返回呢？ 处理：在Java程序中创建一个属性与数据库表匹配的类，通过此类的对象封装查询到的数据，我们把用于传递JDBC增删查改操作的数据的对象称之为数据传输对象——DTO(实体类：带有属性，其对象可以存放数据的类) 实体类创建规则： 1234567* 1.类中属性的个数和类型，与对应的数据表保持一致* 2.提供所有属性的get和set方法：Alt+Insert --- Getter And Setter --- 选择所有属性 --- OK* 3.提供全参构造器：Alt+Insert --- Constructor --- 选择所有属性 --- OK* 4.提供无参构造器：Alt+Insert --- Constructor --- SelectNone* 5.重写toString方法：Alt+Insert --- toString --- OK* 6.[暂略] 重写hashcode和equals* 7.[暂略]实现序列化Serializable接口 实体类实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.qfedu.jdbc.dto;import java.io.Serializable;/** * @Descript 存放图书信息的类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Book implements Serializable &#123; private int bookId; private String bookName; private String bookAuthor; private double bookPrice; private int bookStock; private String bookDesc; @Override public String toString() &#123; return &quot;Book&#123;&quot; + &quot;bookId=&quot; + bookId + &quot;, bookName=&#x27;&quot; + bookName + &#x27;\\&#x27;&#x27; + &quot;, bookAuthor=&#x27;&quot; + bookAuthor + &#x27;\\&#x27;&#x27; + &quot;, bookPrice=&quot; + bookPrice + &quot;, bookStock=&quot; + bookStock + &quot;, bookDesc=&#x27;&quot; + bookDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public Book() &#123; &#125; public Book(int bookId, String bookName, String bookAuthor, double bookPrice, int bookStock, String bookDesc) &#123; this.bookId = bookId; this.bookName = bookName; this.bookAuthor = bookAuthor; this.bookPrice = bookPrice; this.bookStock = bookStock; this.bookDesc = bookDesc; &#125; //get和set方法&#125; 使用实体类封装查询操作返回的结果： 1234567891011121314151617181920212223242526/*** 根据图书ID查询一条图书记录*/public Book queryBook(int bid) throws SQLException&#123; Book book = null; Connection connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1,bid); //通过executeQuery方法执行查询语句，并且将查询的结果存放到一个ResultSet对象中（结果集） ResultSet rs = preparedStatement.executeQuery(); //处理结果：从rs中获取查询结果 if(rs.next())&#123; int id = rs.getInt(&quot;book_id&quot;); String name = rs.getString(&quot;book_name&quot;); String author = rs.getString(&quot;book_author&quot;); double price = rs.getDouble(&quot;book_price&quot;); int stock = rs.getInt(&quot;book_stock&quot;); String desc = rs.getString(&quot;book_desc&quot;); //我们需要将查询到的一条数据库图书记录的6个值返回 book = new Book(id,name,author,price,stock,desc); &#125; //关闭连接 结果集也需要关闭 DBHelper.close(rs,preparedStatement,connection); return book;&#125; 8.3 实体类封装查询结果 查询的每条结果分别存放到一个DTO对象中，再将多个DTO对象存放到一个List集合中，返回这个List集合 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.qfedu.jdbc.les1;import com.qfedu.jdbc.dto.Book;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * @Description * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestSelectBooks &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; List&lt;Book&gt; list = new TestSelectBooks().listBooks(); for(Book b:list)&#123; System.out.println(b.getBookName()+&quot;\\t&quot;+b.getBookAuthor()); &#125; &#125; public List&lt;Book&gt; listBooks() throws SQLException&#123; List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); //查询所有图书信息 Connection connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books&quot;; Statement statement = connection.createStatement(); ResultSet rs = statement.executeQuery(sql); while(rs.next())&#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); Book book = new Book(bookId, bookName, bookAuthor, bookPrice, bookStock, bookDesc); bookList.add(book); &#125; DBHelper.close(rs,statement,connection); return bookList; &#125;&#125; 8.4 实体类传递添加、修改操作参数 在JDBC的添加、修改等方法中需要多个数据，我们可以通过实体类来进行参数传递 8.4.1 添加操作1234567891011121314151617public boolean insertBook(Book book) throws SQLException &#123; boolean flag = false; //调用工具类，获取数据库连接对象 Connection connection = DBHelper.getConnection(); String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,book.getBookName()); preparedStatement.setString(2,book.getBookAuthor()); preparedStatement.setDouble(3,book.getBookPrice()); preparedStatement.setInt(4,book.getBookStock()); preparedStatement.setString(5,book.getBookDesc()); int i = preparedStatement.executeUpdate(); flag = i&gt;0; //关闭连接 DBHelper.close(preparedStatement,connection); return flag;&#125; 8.4.2 修改操作12345678910111213141516public boolean updateBook(Book book) throws SQLException&#123; boolean flag = false; Connection connection = DBHelper.getConnection(); String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,book.getBookName()); preparedStatement.setString(2,book.getBookAuthor()); preparedStatement.setDouble(3,book.getBookPrice()); preparedStatement.setInt(4,book.getBookStock()); preparedStatement.setString(5,book.getBookDesc()); preparedStatement.setInt(6,book.getBookId()); int i = preparedStatement.executeUpdate(); flag = i&gt;0; DBHelper.close(preparedStatement,connection); return flag;&#125; 8.5 DAO类封装 DAO封装：将对数据库中同一张数据表的JDBC操作方法封装到同一个Java类中，这个类就是访问此数据表的数据访问对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import java.util.ArrayList;import java.util.List;/** * @Descript DAO Data Access Object 数据访问对象 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookDAO &#123; public boolean deleteBook(int bid) throws SQLException &#123; boolean flag = false; //使用JDBC，根据图书编号删除图书信息 //1.注册驱动 创建连接 Connection connection = DBHelper.getConnection(); //3.编写SQL String sql = &quot;delete from books where book_id=?&quot;; //4.如果SQL指令有参数占位符?,则从Connection获取PreparedStatement预编译SQL指令 // 预编译：在SQL指令中的参数赋值之前对SQL执行的语法结构进行编译 PreparedStatement preparedStatement = connection.prepareStatement(sql); // SQL指令预编译之后，给SQL中的?赋值 preparedStatement.setInt(1,bid); //5.执行SQL int i = preparedStatement.executeUpdate(); //6.处理结果 flag = i&gt;0; //7.关闭连接 DBHelper.close(preparedStatement,connection); return true; &#125; /** * 添加图书 * @return 如果添加成功返回true，如果添加失败则返回false * @throws SQLException */ public boolean insertBook(Book book) throws SQLException &#123; boolean flag = false; //调用工具类，获取数据库连接对象 Connection connection = DBHelper.getConnection(); String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,book.getBookName()); preparedStatement.setString(2,book.getBookAuthor()); preparedStatement.setDouble(3,book.getBookPrice()); preparedStatement.setInt(4,book.getBookStock()); preparedStatement.setString(5,book.getBookDesc()); int i = preparedStatement.executeUpdate(); // 如果i&gt;0，表示DML操作是成功的；如果i=0表示DML操作对数据表中的数据没有影响 flag = i&gt;0; //关闭连接 DBHelper.close(preparedStatement,connection); return flag; &#125; /** * 根据图书ID查询一条图书记录 */ public Book queryBook(int bid) throws SQLException&#123; Book book = null; Connection connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1,bid); //通过executeQuery方法执行查询语句，并且将查询的结果存放到一个ResultSet对象中（结果集） ResultSet rs = preparedStatement.executeQuery(); //处理结果：从rs中获取查询结果 if(rs.next())&#123; int id = rs.getInt(&quot;book_id&quot;); String name = rs.getString(&quot;book_name&quot;); String author = rs.getString(&quot;book_author&quot;); double price = rs.getDouble(&quot;book_price&quot;); int stock = rs.getInt(&quot;book_stock&quot;); String desc = rs.getString(&quot;book_desc&quot;); //我们需要将查询到的一条数据库图书记录的6个值返回 book = new Book(id,name,author,price,stock,desc); &#125; //关闭连接 结果集也需要关闭 DBHelper.close(rs,preparedStatement,connection); return book; &#125; public List&lt;Book&gt; listBooks() throws SQLException&#123; List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); //查询所有图书信息 Connection connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books&quot;; Statement statement = connection.createStatement(); ResultSet rs = statement.executeQuery(sql); while(rs.next())&#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); Book book = new Book(bookId, bookName, bookAuthor, bookPrice, bookStock, bookDesc); bookList.add(book); &#125; DBHelper.close(rs,statement,connection); return bookList; &#125; public boolean updateBook(Book book) throws SQLException&#123; boolean flag = false; Connection connection = DBHelper.getConnection(); String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,book.getBookName()); preparedStatement.setString(2,book.getBookAuthor()); preparedStatement.setDouble(3,book.getBookPrice()); preparedStatement.setInt(4,book.getBookStock()); preparedStatement.setString(5,book.getBookDesc()); preparedStatement.setInt(6,book.getBookId()); int i = preparedStatement.executeUpdate(); flag = i&gt;0; DBHelper.close(preparedStatement,connection); return flag; &#125;&#125; 8.6 DAO类代码优化 1.在应用程序开发中，如果方法中抛出异常且自己可以处理，则直接通过try&#x2F;catch进行捕获处理； 2.JDBC操作方法的连接需要放在finally中进行关闭； 3.将数据库连接Connection、Statement、ResultSet等需要关闭的数据库对象定义在try之前; 4.因为所有的JDBC操作都需要Conection、Statement对象，查询方法都需要ResultSet对象，因此在DAO中可以将这些对象定义成类的成员变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package com.qfedu.jdbc.dao;import com.qfedu.jdbc.dto.Book;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * @Descript DAO Data Access Object 数据访问对象 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookDAO &#123; private Connection connection; private Statement statement; private PreparedStatement preparedStatement; private ResultSet rs; public boolean deleteBook(int bid) &#123; boolean flag = false; try&#123; connection = DBHelper.getConnection(); String sql = &quot;delete from books where book_id=?&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1,bid); int i = preparedStatement.executeUpdate(); flag = i&gt;0; &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(preparedStatement,connection); &#125; return flag; &#125; public boolean insertBook(Book book) &#123; boolean flag = false; try&#123; //调用工具类，获取数据库连接对象 connection = DBHelper.getConnection(); String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,book.getBookName()); preparedStatement.setString(2,book.getBookAuthor()); preparedStatement.setDouble(3,book.getBookPrice()); preparedStatement.setInt(4,book.getBookStock()); preparedStatement.setString(5,book.getBookDesc()); int i = preparedStatement.executeUpdate(); // 如果i&gt;0，表示DML操作是成功的；如果i=0表示DML操作对数据表中的数据没有影响 flag = i&gt;0; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(preparedStatement,connection); &#125; return flag; &#125; public Book queryBook(int bid) &#123; Book book = null; try &#123; connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1, bid); //通过executeQuery方法执行查询语句，并且将查询的结果存放到一个ResultSet对象中（结果集） rs = preparedStatement.executeQuery(); //处理结果：从rs中获取查询结果 if (rs.next()) &#123; int id = rs.getInt(&quot;book_id&quot;); String name = rs.getString(&quot;book_name&quot;); String author = rs.getString(&quot;book_author&quot;); double price = rs.getDouble(&quot;book_price&quot;); int stock = rs.getInt(&quot;book_stock&quot;); String desc = rs.getString(&quot;book_desc&quot;); //我们需要将查询到的一条数据库图书记录的6个值返回 book = new Book(id, name, author, price, stock, desc); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; finally &#123; DBHelper.close(rs, preparedStatement, connection); &#125; return book; &#125; public List&lt;Book&gt; listBooks()&#123; List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); try &#123; connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books&quot;; statement = connection.createStatement(); rs = statement.executeQuery(sql); while (rs.next()) &#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); Book book = new Book(bookId, bookName, bookAuthor, bookPrice, bookStock, bookDesc); bookList.add(book); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(rs, statement, connection); &#125; return bookList; &#125; public boolean updateBook(Book book) &#123; boolean flag = false; try &#123; connection = DBHelper.getConnection(); String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1, book.getBookName()); preparedStatement.setString(2, book.getBookAuthor()); preparedStatement.setDouble(3, book.getBookPrice()); preparedStatement.setInt(4, book.getBookStock()); preparedStatement.setString(5, book.getBookDesc()); preparedStatement.setInt(6, book.getBookId()); int i = preparedStatement.executeUpdate(); flag = i &gt; 0; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; finally &#123; DBHelper.close(preparedStatement, connection); &#125; return flag; &#125;&#125; 九、JDBC综合案例 完成学生信息的CRUD操作 9.1 JDBC数据库编程的流程 创建数据库、数据表 123456create table students( stu_num char(8) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null); 创建新的Java工程 创建JDBC的工具类：DBHelper 创建DTO类（用于封装参数及查询结果） 创建DAO类（用于完成CRUD操作） 9.2 创建JDBC工具类 在Java工程中创建package :com.qfedu.jdbc.utils 在com.qfedu.jdbc.utils包中创建工具类DBHelper 编写DBHelper工具类： 添加驱动jar文件 编写DBHelper代码 9.3 创建DTO类 在Java工程中创建package：com.qfedu.jdbc.dto 在com.qfedu.jdbc.dto创建数据表对应的实体类Student 编写实体类 1234567891011121314151617181920212223242526272829303132333435package com.qfedu.jdbc.dto;/** * @Descript 用于传递学生信息的实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Student &#123; private String stuNum; private String stuName; private String stuGender; private int stuAge; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;stuNum=&#x27;&quot; + stuNum + &#x27;\\&#x27;&#x27; + &quot;, stuName=&#x27;&quot; + stuName + &#x27;\\&#x27;&#x27; + &quot;, stuGender=&#x27;&quot; + stuGender + &#x27;\\&#x27;&#x27; + &quot;, stuAge=&quot; + stuAge + &#x27;&#125;&#x27;; &#125; public Student() &#123; &#125; public Student(String stuNum, String stuName, String stuGender, int stuAge) &#123; this.stuNum = stuNum; this.stuName = stuName; this.stuGender = stuGender; this.stuAge = stuAge; &#125; //get set&#125; 9.4 创建DAO类 创建DAO类，完成JDBC操作 在Java项目中创建package:com.qfedu.jdbc.dao 在com.qfedu.jdbc.dao包中创建类StudentDAO 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.qfedu.jdbc.dao;import com.qfedu.jdbc.dto.Student;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * @Descript students表的数据访问类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class StudentDAO &#123; private Connection connection; private Statement statement; private PreparedStatement preparedStatement; private ResultSet resultSet; //1、添加学生信息 public boolean insert(Student student)&#123; boolean flag = false; try &#123; connection = DBHelper.getConnectin(); String sql = &quot;insert into students(stu_num,stu_name,stu_gender,stu_age) values(?,?,?,?)&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,student.getStuNum()); preparedStatement.setString(2,student.getStuName()); preparedStatement.setString(3,student.getStuGender()); preparedStatement.setInt(4,student.getStuAge()); int i = preparedStatement.executeUpdate(); flag = i&gt;0; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(preparedStatement,connection); &#125; return flag; &#125; //2、根据学号查询一个学生记录 public Student queryStudent(String snum)&#123; Student student = null; try&#123; connection = DBHelper.getConnectin(); String sql = &quot;select stu_num,stu_name,stu_gender,stu_age from students where stu_num=?&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,snum); resultSet = preparedStatement.executeQuery(); if(resultSet.next())&#123; String stuNum = resultSet.getString(&quot;stu_num&quot;); String stuName = resultSet.getString(&quot;stu_name&quot;); String stuGender = resultSet.getString(&quot;stu_gender&quot;); int stuAge = resultSet.getInt(&quot;stu_age&quot;); student = new Student(stuNum,stuName,stuGender,stuAge); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(resultSet,preparedStatement,connection); &#125; return student; &#125; //3、查询多个学生信息 public List&lt;Student&gt; listStudents()&#123; List&lt;Student&gt; studentList = new ArrayList&lt;&gt;(); try&#123; connection = DBHelper.getConnectin(); String sql = &quot;select stu_num,stu_name,stu_gender,stu_age from students&quot;; statement = connection.createStatement(); resultSet = statement.executeQuery(sql); while(resultSet.next())&#123; String stuNum = resultSet.getString(&quot;stu_num&quot;); String stuName = resultSet.getString(&quot;stu_name&quot;); String stuGender = resultSet.getString(&quot;stu_gender&quot;); int stuAge = resultSet.getInt(&quot;stu_age&quot;); Student s = new Student(stuNum,stuName,stuGender,stuAge); studentList.add(s); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; finally &#123; DBHelper.close(resultSet,statement,connection); &#125; return studentList; &#125;&#125; 9.5 测试DAO类中的方法 使用junit对DAO中创建的JDBC方法进行单元测试 9.5.1 下载导入junit依赖到项目中 下载：https://mvnrepository.com/ （如果使用junit 4.10 + 版本单元测试，需要以下两个jar文件） junit-4.12.jar hamcrest-core-1.3.jar 将junit-4.12.jar、hamcrest-core-1.3.jar拷贝项目的lib文件夹 选择拷贝到项目中的jar文件—右键—Add as Library 9.5.2 创建单元测试类 如果我们需要对某个类中的方法进行单元测试，我们需要创建这个类的测试类 StudentDAO ———&gt; StudentDAOTest（测试类：类名&#x3D;被测试类+Test） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.qfedu.jdbc.test;import com.qfedu.jdbc.dao.StudentDAO;import com.qfedu.jdbc.dto.Student;import org.junit.Test;import java.util.List;import static org.junit.Assert.*;/** * @Descript 此类是StudentDAO的单元测试类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class StudentDAOTest &#123; //1.在测试类中定义成员变量：创建被测试类的对象 private StudentDAO studentDAO = new StudentDAO(); //2创建测试方法 ： 用来测试StudentDAO类中的insertStudent方法 //a.测试方法名=test+被测试方法名 //b.测试方法无参数无返回值 @Test public void testInsertStudent()&#123; //准备被测试方法所需的参数 Student stu = new Student(&quot;1008&quot;,&quot;Tom&quot;,&quot;男&quot;,20); //调用被测试方法，获取结果 boolean b = studentDAO.insertStudent(stu); //断言返回结果(成立 | 不成立) assertTrue(b); &#125; @Test public void testQueryStudent()&#123; String snum = &quot;1008&quot;; Student student = studentDAO.queryStudent(snum); assertEquals(&quot;Tom2&quot;,student.getStuName()); &#125; @Test public void testListStudents()&#123; List&lt;Student&gt; studentList = studentDAO.listStudents(); assertEquals(8,studentList.size()); &#125;&#125; 十、JDBC事务管理 什么是事务？ 事务的四大特性—ACID 事务的隔离级别 MySQL事务管理： start transaction rollback commit 10.1 JDBC实现借书操作 向records表添加借书记录 修改books表中的库存 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.qfedu.jdbc.dao;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;/** * @Descript * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookDAO &#123; /** * 借书： * @param stuNum 借书的学生学号 * @param bookId 借书的图书编号 * @param num 借书的数量 * @return */ public boolean borrowBook2(String stuNum,int bookId,int num)&#123; boolean flag = false; try &#123; //1.向`records`表添加借书记录 Connection connection = DBHelper.getConnectin(); String sql1 = &quot;insert into records(snum,bid,borrow_num,is_return,borrow_date) values(?,?,?,0,sysdate())&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql1); preparedStatement.setString(1,stuNum); preparedStatement.setInt(2,bookId); preparedStatement.setInt(3,num); int i = preparedStatement.executeUpdate(); int k = 10/0; //造异常：算术异常 //2.修改`books`表中的库存 Connection connection2 = DBHelper.getConnectin(); String sql2 = &quot;update books set book_stock=book_stock-? where book_id=?&quot;; PreparedStatement preparedStatement2 = connection2.prepareStatement(sql2); preparedStatement2.setInt(1,num); preparedStatement2.setInt(2,bookId); int j = preparedStatement2.executeUpdate(); flag = i&gt;0 &amp;&amp; j&gt;0; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; // 关闭连接 &#125; return flag; &#125;&#125; 分析： 借书业务由两个数据库操作完成，这两个操作要么同时成功，要么同时失败，构成一个数据库事务； JDBC的DML操作默认是自定提交的，因此当第一个DML操作（添加借书记录）完成后，无论第二个操作（修改库存）是否成功，借书记录都会添加到数据库，而且是永久的 JDBC中该如何做事务管理呢？ 10.2 JDBC事务管理 一个事务中的多个DML操作需要基于同一个数据库连接； 创建连接之后，设置事务手动提交（关闭自动提交）；connection.setAutoCommit(false); 当当前事务中的所有DML操作完成之后手动提交；connection.commit(); 当事务中的任何一个步骤出现异常，在catch代码块中执行事务回滚。connection.rollback(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.qfedu.jdbc.dao;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;/** * @Descript * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookDAO &#123; /** * 借书： * @param stuNum 借书的学生学号 * @param bookId 借书的图书编号 * @param num 借书的数量 * @return */ public boolean borrowBook(String stuNum,int bookId,int num)&#123; boolean flag = false; Connection connection = null; PreparedStatement preparedStatement1 = null; PreparedStatement preparedStatement2 = null; try &#123; connection = DBHelper.getConnectin(); //设置使用当前Connection连接操作数据库自动提交关闭 connection.setAutoCommit(false); //1.向`records`表添加借书记录 String sql1 = &quot;insert into records(snum,bid,borrow_num,is_return,borrow_date) values(?,?,?,0,sysdate())&quot;; preparedStatement1 = connection.prepareStatement(sql1); preparedStatement1.setString(1,stuNum); preparedStatement1.setInt(2,bookId); preparedStatement1.setInt(3,num); int i = preparedStatement1.executeUpdate(); int k = 10/0; //造异常：算术异常 //2.修改`books`表中的库存 String sql2 = &quot;update books set book_stock=book_stock-? where book_id=?&quot;; preparedStatement2 = connection.prepareStatement(sql2); preparedStatement2.setInt(1,num); preparedStatement2.setInt(2,bookId); int j = preparedStatement2.executeUpdate(); // 提交事务 connection.commit(); flag = i&gt;0 &amp;&amp; j&gt;0; &#125;catch (Exception e)&#123; try &#123; //一旦事务执行过程中出现异常，执行回滚 connection.rollback(); &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; &#125;finally &#123; DBHelper.close(preparedStatement1,null); DBHelper.close(preparedStatement2,connection); &#125; return flag; &#125; &#125; 10.3 Service层的事务管理 DAO只负责数据库的操作，业务由service层进行管理 10.3.1 Service分层介绍 DAO负责特定的数据库操作 Servcie进行业务处理，Service业务处理过程如果需要数据库操作，则调用DAO完成 10.3.2 Service分层实现 创建RecordDAO，完成insertRecord方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.qfedu.jdbc.dao;import com.qfedu.jdbc.utils.DBHelper;import java.sql.Connection;import java.sql.PreparedStatement;/** * @Descript 完成对借书记录表的JDBC操作 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class RecordDAO &#123; /** * 添加借书记录 * @param snum 借书的学生的学号 * @param bid 借书的图书编号 * @param num 借书的数量 * @return 添加借书记录成功返回true，失败返回false */ public boolean insertRecord(String snum,int bid,int num)&#123; boolean flag = false; Connection connection = null; PreparedStatement preparedStatement1 = null; try&#123; //1.向`records`表添加借书记录 connection = DBHelper.getConnectin(); String sql1 = &quot;insert into records(snum,bid,borrow_num,is_return,borrow_date) values(?,?,?,0,sysdate())&quot;; preparedStatement1 = connection.prepareStatement(sql1); preparedStatement1.setString(1,snum); preparedStatement1.setInt(2,bid); preparedStatement1.setInt(3,num); int i = preparedStatement1.executeUpdate(); flag = i&gt;0; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(preparedStatement1,connection); &#125; return flag; &#125;&#125; 在BookDAO中定义updateStock修改库存方法 1234567891011121314151617181920212223242526272829303132333435363738394041package com.qfedu.jdbc.dao;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;/** * @Descript * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookDAO &#123; /** * 修改库存 * @param bid 要修改库存的图书编号 * @param num book_stock=book_stock-num * @return */ public boolean updateStock(int bid,int num)&#123; boolean flag = false; Connection connection = null; PreparedStatement preparedStatement2 = null; try&#123; //2.修改`books`表中的库存 connection = DBHelper.getConnectin(); String sql2 = &quot;update books set book_stock=book_stock-? where book_id=?&quot;; preparedStatement2 = connection.prepareStatement(sql2); preparedStatement2.setInt(1,num); preparedStatement2.setInt(2,bid); int j = preparedStatement2.executeUpdate(); flag = j&gt;0; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(preparedStatement2,connection); &#125; return flag; &#125;&#125; 创建BookService完成借书业务 1234567891011121314151617181920212223242526272829package com.qfedu.jdbc.service;import com.qfedu.jdbc.dao.BookDAO;import com.qfedu.jdbc.dao.RecordDAO;/** * @Descript 图书管理的业务类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookService &#123; private RecordDAO recordDAO = new RecordDAO(); private BookDAO bookDAO = new BookDAO(); /** * 借书业务，包含两个步骤，这两个步骤要么同时成功，要么同时失败——事务 */ public boolean borrowBook(String stuNum,int bookId,int num)&#123; //1.添加借书记录 boolean b1 = recordDAO.insertRecord(stuNum, bookId, num); //2.修改图书库存 boolean b2 = bookDAO.updateStock(bookId, num); // 结果处理 boolean r = b1 &amp;&amp; b2; return r; &#125;&#125; 10.3.3 Service层的事务管理 Servcie层事务中多个数据库的DML操作是相互独立的，如何保证所有DML要么同时成功，要么同时失败呢？ 事务管理要满足以下条件： 多个DML操作需使用同一个数据库连接 第一个DML操作之前设置事务手动提交 所有DML操作执行完成之后提交事务 出现异常则进行事务回滚 如何让Service事务中的多个DML使用同一个数据库连接？ 在Service获取连接对象，将连接对象传递到DAO中 分析：DAO类中的Connection对象需要通过Service传递给进来，这种对象传递本来也无可厚非，但是当我们通过面向接口开发时（面向接口，是为了能够灵活的定义实现类），容易造成接口的冗余（接口污染） 使用ThreadLocal容器，实现多个DML操作使用相同的连接 存储Connection的容器可以使用List集合 使用List集合做容器，在多线程并发编程中会出现资源竞争问题——多个并发的线程使用的是同一个数据库连接对象（我们的要求是同一个事务中使用同一个连接，而并非多个线程共享连接） 为了解决并发编程的连接对象共享问题，我们可以使用ThreadLocal作为数据库连接对象的容器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.qfedu.jdbc.utils;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * @Descript * @Author 千锋涛哥 * 公众号： Java架构栈 */public class DBHelper &#123; //1.定义数据库连接信息 private static final String DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;; private static final String URL = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; private static final String USERNAME = &quot;root&quot;; private static final String PASSWORD = &quot;@QFedu123&quot;; //1️⃣定义ThreadLocal容器 private static final ThreadLocal&lt;Connection&gt; local = new ThreadLocal&lt;&gt;(); //2.静态初始化块注册驱动 static&#123; try &#123; Class.forName(DRIVER); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; //3.创建数据库连接 public static Connection getConnectin()&#123; // 2️⃣从ThreadLocal容器中获取连接 Connection connection = local.get(); try &#123; if(connection == null)&#123; //3️⃣如果容器中没有连接，则创建连接，并将创建的连接存放到容器 connection = DriverManager.getConnection(URL,USERNAME,PASSWORD); local.set(connection); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125; //4. 4️⃣关闭连接 // 如果使用ThreadLocal存储数据库连接，关闭连接时同时要将Connection对象从ThreadLocal中移除 public static void closeConnection()&#123; // 获取到当前线程使用的数据库连接对象 Connection connection = local.get(); try &#123; if(connection !=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; // 将关闭后的连接对象从ThreadLocal中移除 local.remove(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void closeStatement(Statement statement)&#123; closeStatement(null,statement); &#125; public static void closeStatement(ResultSet resultSet, Statement statement)&#123; try &#123; if(resultSet!=null &amp;&amp; !resultSet.isClosed())&#123; resultSet.close(); &#125; if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 十一、数据库连接池11.1 什么是数据库连接池？ 如果每个JDBC操作需要数据库连接都重新创建，使用完成之后都销毁，我们的JVM会因为频繁的创建、销毁连接而占用额外的系统资源。 数据库连接本质上是可被重用的资源（当一个JDBC操作完成之后，其创建的连接是可以被其他JDBC操作使用的），基于这个特性： 我们可以创建一个存放数据库连接的容器（连接池），连接池是有最大容量的 当我们要进行JDBC操作时，直接从这个容器中获取连接 如果容器中没有空闲的连接且连接池中连接的个数没有达到最大值，则创建新的数据库连接存入连接池并给这个操作使用，使用完成之后无需关闭连接直接归还这个容器中即可； 如果容器中没有空闲的连接且连接池中连接的个数达到最大值，当前操作就会进行等待，等待连接池中的某个连接被归还，归还之后再使用； 如果容器中有空闲连接，则无需创建新的连接，直接从容器中获取这个空闲连接进行使用； 连接池：存放数据库连接对象的容器 连接池作用：对数据库连接进行管理，减少因重复创建、销毁连接导致的系统开销 11.2 常用连接池 我们可以编程实现：创建一个数组、集合来存放数据库连接； 目前市面上已经有多种实现的数据库连接池了，我们无需再手动实现，只需引用对应的数据库连接池产品，即可在我们自己的Java应用中使用连接池（站在巨人的肩上） 功能 dbcp druid c3p0 HikariCP 是否支持PSCache 是 是 是 否 监控 jmx jmx&#x2F;log&#x2F;http jmx,log jmx 扩展性 弱 好 弱 弱 sql拦截及解析 无 支持 无 无 代码 简单 中等 复杂 简单 特点 依赖于common-pool 阿里开源，功能全面 历史久远，代码逻辑复杂，且不易维护 优化力度大，功能简单，起源于boneCP 连接池管理 LinkedBlockingDeque 数组 ThreadLocalCopyOnWriteArrayList 基于连接池的性能、使用的便捷性、连接监控等多方面综合情况，druid是目前企业应用中使用最广泛的 Hikari在SpringBoot中默认集成，性能是诸多竞品中最好的 11.3 使用Druid连接池11.3.1 创建Java应用 创建Java工程 添加驱动jar文件 11.3.2 创建连接池属性配置 在src中创建package：com.qfedu.jdbc.utils 在com.qfedu.jdbc.utils中创建druid.properties文件 配置druid连接池的实行 123456789101112131415# 数据库连接信息driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8username=rootpassword=@QFedu123# 连接池属性# 连接池的初始化连接数&lt;创建数据库连接池时默认初始化的连接的个数&gt;initialSize=10# 连接池的最大连接数maxActive=50# 最小空闲连接数（当数据库连接使用率很低时，连接池中的连接会被释放一部分）minIdle=5# 超时等待时间(单位：ms)maxWait=30000 11.3.3 创建连接池工具类 下载并导入druid的jar文件druid-1.2.8.jar 在com.qfedu.jdbc.utils创建DruidUtils工具类（工具类与属性文件druid.properties在同目录下） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.qfedu.jdbc.utils;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;/** * @Descript Druid数据库连接池工具类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class DruidUtils &#123; //1.定义DruidDataSource对象：表示Druid数据库连接池（数据源） private static DruidDataSource druidDataSource; //2.静态代码块初始化定义DruidDataSource对象 static&#123; try &#123; //读取druid.properties文件中配置的属性 InputStream is = DruidUtils.class.getResourceAsStream(&quot;druid.properties&quot;); Properties properties = new Properties(); properties.load(is); //使用属性文件初始化DruidDataSource对象 druidDataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //3.创建静态方法，从连接池对象中获取连接 public static Connection getConnection()&#123; Connection connection = null; try &#123; connection = druidDataSource.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125; &#125; 十二、通用JDBC操作封装 在DAO层的JDBC操作中，对数据的表增、删、改、查操作存在代码的冗余，我们可以对其公共部分进行封装，实现代码的复用。 12.1 DML操作封装 对于数据库的DML操作： 参数不同 SQL通过 SQL参数复制不同 通用的DML操作方法 123456789101112131415161718192021222324252627282930313233343536373839404142package com.qfedu.jdbc.utils;import java.sql.Connection;import java.sql.PreparedStatement;/** * @Descript 公共DAO，用于封装公共的JDBC操作 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class CommonDAO &#123; /** * 公共DML操作 * @param sql 执行的SQL指令 * @return */ /** * sql : delete from students where stu_num=? * args: snum * * sql : insert into students(stu_num,stu_name,stu_gender,stu_age) values(?,?,?,?) * args: 1009 Lucy 女 18 */ public boolean update(String sql, Object... args)&#123; boolean b = false; try&#123; Connection connection = DruidUtils.getConnection(); PreparedStatement preparedStatement = connection.prepareStatement(sql); for (int i = 0; i &lt; args.length ; i++) &#123; preparedStatement.setObject(i+1,args[i]); &#125; int i = preparedStatement.executeUpdate(); b = i&gt;0; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return b; &#125;&#125; 12.2 DQL操作封装 使用泛型设置通用查询方法的返回类型 123456789101112131415package com.qfedu.jdbc.utils;import java.sql.ResultSet;import java.sql.SQLException;/** * @Descript 用于定义结果集映射的接口 * @Author 千锋涛哥 * 公众号： Java架构栈 */public interface RowMapper&lt;T&gt; &#123; public T getRow(ResultSet resultSet) throws SQLException;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.qfedu.jdbc.utils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.List;/** * @Descript 公共DAO，用于封装公共的JDBC操作 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class CommonDAO&lt;T&gt; &#123; /** * 公共DML操作 */ public boolean update(String sql, Object... args)&#123; boolean b = false; try&#123; Connection connection = DruidUtils.getConnection(); PreparedStatement preparedStatement = connection.prepareStatement(sql); for (int i = 0; i &lt; args.length ; i++) &#123; preparedStatement.setObject(i+1,args[i]); &#125; int i = preparedStatement.executeUpdate(); b = i&gt;0; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return b; &#125; /** * 查询 */ public List&lt;T&gt; select(String sql, RowMapper&lt;T&gt; rowMapper,Object...args)&#123; List&lt;T&gt; list = new ArrayList&lt;&gt;(); try&#123; Connection connection = DruidUtils.getConnection(); PreparedStatement preparedStatement = connection.prepareStatement(sql); for (int i = 0; i &lt;args.length ; i++) &#123; preparedStatement.setObject(i+1,args[i]); &#125; ResultSet resultSet = preparedStatement.executeQuery(); while(resultSet.next())&#123; // 从查询结果中取出一条记录（多个值），封装到一个实体类对象中 // getRow就是方法调用者在调用方法时，传递进来的用于映射查询结果的方法 T t = rowMapper.getRow(resultSet); list.add(t); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return list; &#125;&#125; 12.3 基于通用JDBC操作的案例 图书信息进行JDBC操作 创建图书实体类Book 创建BookDAO 12.3.1 创建实体类12345678910111213141516171819/** * @Descript 图书信息实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Book &#123; private int bookId; private String bookName; private String bookAuthor; private double bookPrice; private int bookStock; private String bookDesc; //无参构造器 //全参构造器 //toString //get和set&#125; 12.3.2 创建DAO类 DAO中的操作都是调用CommonDAO实现的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.qfedu.jdbc.dao;import com.qfedu.jdbc.dto.Book;import com.qfedu.jdbc.utils.CommonDAO;import com.qfedu.jdbc.utils.RowMapper;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;/** * @Descript 对图书信息表进行CRUD操作 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookDAO &#123; private CommonDAO&lt;Book&gt; commonDAO = new CommonDAO&lt;&gt;(); public boolean insertBook(Book book)&#123; String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; boolean b = commonDAO.update(sql, book.getBookName(), book.getBookAuthor(), book.getBookPrice(), book.getBookStock(), book.getBookDesc()); return b; &#125; public boolean deleteBook(int bookId)&#123; String sql = &quot;delete from books where book_id=?&quot;; boolean b = commonDAO.update(sql, bookId); return b; &#125; public boolean updateBook(Book book)&#123; String sql=&quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; boolean b = commonDAO.update(sql, book.getBookName(), book.getBookAuthor(), book.getBookPrice(), book.getBookStock(), book.getBookDesc(), book.getBookId()); return b; &#125; public Book queryBook(int bookId)&#123; String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; RowMapper&lt;Book&gt; bookRowMapper = new RowMapper&lt;Book&gt;()&#123; public Book getRow(ResultSet resultSet) throws SQLException &#123; int bid = resultSet.getInt(&quot;book_id&quot;); String bookName = resultSet.getString(&quot;book_name&quot;); String bookAuthor = resultSet.getString(&quot;book_author&quot;); double bookPrice = resultSet.getDouble(&quot;book_price&quot;); int bookStock = resultSet.getInt(&quot;book_stock&quot;); String bookDesc = resultSet.getString(&quot;book_desc&quot;); return new Book(bid,bookName,bookAuthor,bookPrice,bookStock,bookDesc); &#125; &#125;; List&lt;Book&gt; list = commonDAO.select(sql, bookRowMapper, bookId); return list.size()&gt;0?list.get(0):null; &#125; public List&lt;Book&gt; listBooks()&#123; String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books&quot;; List&lt;Book&gt; list = commonDAO.select(sql, resultSet -&gt; &#123; int bid = resultSet.getInt(&quot;book_id&quot;); String bookName = resultSet.getString(&quot;book_name&quot;); String bookAuthor = resultSet.getString(&quot;book_author&quot;); double bookPrice = resultSet.getDouble(&quot;book_price&quot;); int bookStock = resultSet.getInt(&quot;book_stock&quot;); String bookDesc = resultSet.getString(&quot;book_desc&quot;); return new Book(bid, bookName, bookAuthor, bookPrice, bookStock, bookDesc); &#125;); return list; &#125;&#125; 十三、Apache DBUtils13.1 DBUtils介绍 Commons DBUtils是Apache组织提供的一个针对JDBC进行简单封装的开源工具类库，使用DBUtils可以极大简化JDBC应用程序开发，同时不会影响数据库访问的性能。 DBUtils是Java编程中数据库访问的轻巧、使用的工具类库 提供对数据表通用的DML操作 提供对数据表通用的DQL操作（可以把结果封装成对象、集合等类型） DBUtils工具类库中的核心类： QueryRunner，用于执行SQL指令（相当于我们自己封装的CommonDAO类） update() , 用于执行DML指令 query(), 用于执行DQL指令 ResultSetHandler接口，结果集处理器，用于处理查询结果（相当于我们自己的封装的RowMapper接口） BeanHandler实现类：当查询语句返回一条结果时，使用BeanHandler将结果转换成一个对象 BeanListHandler实现类：当查询语句返回多个结果时，使用BeanListHandler将结果转换成一个集合 ScalarHandler实现类：当查询结果返回一个值时，使用ScalarHandler将这个值转换成Java变量类型 13.2 DBUtils的使用准备 新建Java工程 添加依赖： mysql-connector-java-8.0.26.jar druid-1.2.8.jarApache DBUtils建立数据库连接是依赖连接池数据源的，因此我们需要使用连接池 commons-dbutils-1.7.jar 配置druid的属性文件 创建com.qfedu.jdbc.utils包 在包中创建druid.properties文件，配置如下 123456789101112131415# 数据库连接信息driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8username=rootpassword=@QFedu123# 连接池属性# 连接池的初始化连接数&lt;创建数据库连接池时默认初始化的连接的个数&gt;initialSize=10# 连接池的最大连接数maxActive=50# 最小空闲连接数（当数据库连接使用率很低时，连接池中的连接会被释放一部分）minIdle=5# 超时等待时间(单位：ms)maxWait=30000 创建Druid连接池工具类 在com.qfedu.jdbc.utils包创建DruidUtils工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.qfedu.jdbc.utils;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;/** * @Descript * @Author 千锋涛哥 * 公众号： Java架构栈 */public class DruidUtils &#123; private static DruidDataSource druidDataSource; static&#123; try &#123; InputStream is = DruidUtils.class.getResourceAsStream(&quot;druid.properties&quot;); Properties properties = new Properties(); properties.load(is); druidDataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取数据库连接池数据源对象 * @return */ public static DataSource getDataSource()&#123; return druidDataSource; &#125; public static Connection getConnection()&#123; Connection connection = null; try &#123; connection = druidDataSource.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125;&#125; 13.3 DBUtils使用 完成图书信息的数据库操作 创建实体类 123456789101112131415/** * @Descript 图书信息实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Book &#123; private int bookId; private String bookName; private String bookAuthor; private double bookPrice; private int bookStock; private String bookDesc; &#125; 13.3.1 添加操作123456789101112131415public int insertBook(Book book)&#123; int i= 0; try &#123; //1.编写SQL String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; //2.准备参数 Object[] params = &#123;book.getBookName(),book.getBookAuthor(),book.getBookPrice(),book.getBookStock(),book.getBookDesc()&#125;; //3.调用commons-dbutils中的QueryRunner执行SQL QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); i = queryRunner.update(sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i;&#125; 13.3.2 删除操作1234567891011public int deleteBook(int bookId)&#123; int i = 0; try &#123; String sql = &quot;delete from books where book_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); i = queryRunner.update(sql,bookId); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i;&#125; 13.3.3 修改操作123456789101112public int updateBook(Book book)&#123; int i=0; try &#123; String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; Object[] params = &#123;book.getBookName(),book.getBookAuthor(),book.getBookPrice(),book.getBookStock(),book.getBookDesc(),book.getBookId()&#125;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); i = queryRunner.update(sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i;&#125; 13.3.4 查询操作查询一条记录 1234567891011121314151617public Book queryBook(int bookId)&#123; Book book = null; try &#123; String sql = &quot;select book_id bookId,book_name bookName,book_author bookAuthor,book_price bookPrice,book_stock bookStock,book_desc bookDesc from books where book_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); //1.对于查询操作，我们需要通过QueryRunner对象调用query方法来执行 //2.所有的query方法都需要一个ResultSetHandler的参数，通过此参数指定query方法的返回类型 // 如果SQL指令执行之后返回的是一行记录，我们通过BeanHandler指定查询结果封装的实体类类型 // 要求：查询结果集的字段名必须与指定的实体类的属性名匹配 // 方案1：创建实体类的时候，实体类中属性的名字与数据表中的列名相同 // 方案2：查询语句字段取别名，让字段别名与实体类属性名一致 book = queryRunner.query(sql, new BeanHandler&lt;Book&gt;(Book.class), bookId); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return book;&#125; 自定义结果集处理 自定义ResultSetHandler 1234567891011121314151617181920212223242526272829303132public Book queryBook2(int bookId)&#123; Book book = null; try &#123; String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); //1.对于查询操作，我们需要通过QueryRunner对象调用query方法来执行 //2.所有的query方法都需要一个ResultSetHandler的参数，通过此参数指定query方法的返回类型 // 如果SQL指令执行之后返回的是一行记录，我们通过BeanHandler指定查询结果封装的实体类类型 // 要求：查询结果集的字段名必须与指定的实体类的属性名匹配 // 方案3：自定义ResultSetHandler结果处理 ResultSetHandler&lt;Book&gt; resultSetHandler = new ResultSetHandler&lt;Book&gt;() &#123; @Override public Book handle(ResultSet resultSet) throws SQLException &#123; Book book = null; if(resultSet.next()) &#123; int id = resultSet.getInt(&quot;book_id&quot;); String bookName = resultSet.getString(&quot;book_name&quot;); String bookAuthor = resultSet.getString(&quot;book_author&quot;); double bookPrice = resultSet.getDouble(&quot;book_price&quot;); int bookStock = resultSet.getInt(&quot;book_stock&quot;); String bookDesc = resultSet.getString(&quot;book_desc&quot;); book = new Book(id,bookName,bookAuthor,bookPrice,bookStock,bookDesc); &#125; return book; &#125; &#125;; book = queryRunner.query(sql, resultSetHandler, bookId); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return book;&#125; 查询多条记录 123456789101112public List&lt;Book&gt; listBooks()&#123; List&lt;Book&gt; bookList = null; try &#123; String sql = &quot;select book_id bookId,book_name bookName,book_author bookAuthor,book_price bookPrice,book_stock bookStock,book_desc bookDesc from books&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); //如果SQL指令执行之后返回的是多行记录，我们通过BeanListHandler指定查询结果封装的实体类的集合类型 bookList = queryRunner.query(sql, new BeanListHandler&lt;Book&gt;(Book.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return bookList;&#125; 查询一个值 例如在做分页的时候，我们需要查询数据的总记录数 123456789101112131415public long getCount()&#123; long count = 0; String sql = &quot;select count(1) from books&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); // 如果SQL指令执行之后返回的是一个值时，我们通过ScalarHandler指定返回类型 // QueryRunner在处理统计操作时，是以long类型进行操作的，因此不能直接转成Integer // 如果我们确定这个值在int范围内，我们可以在得到long类型之后进行强转，建议使用long处理 ScalarHandler&lt;Long&gt; scalarHandler = new ScalarHandler&lt;Long&gt;(); try &#123; count = queryRunner.query(sql, scalarHandler); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count;&#125;","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"}]},{"title":"day02-MySQL","slug":"day02-MySQL","date":"2022-09-19T01:08:56.000Z","updated":"2022-10-05T06:55:20.713Z","comments":true,"path":"2022/09/19/day02-MySQL/","link":"","permalink":"http://example.com/2022/09/19/day02-MySQL/","excerpt":"","text":"一、MySQL课程内容1.1 数据库介绍 数据库概念 术语介绍 1.2 MySQL数据库 下载、安装、配置、卸载 MySQL客户端工具的安装及使用 1.3 SQL 结构化查询语言 什么是SQL SQL操作数据（CRUD操作：添加、查询、修改、删除） 1.4 SQL 高级 存储过程 索引 触发器、视图 1.5 数据库设计 数据库设计步骤 数据库设计范式 E-R图 PowerDesigner建模工具、PDMan 1.6 数据库事务 什么是事务 事务特性ACID 事务隔离级别 事务管理 二、数据库介绍2.1 数据库概念 数据库，就是存放数据的仓库 数据库（DataBase，简称DB）是长期存储在计算机内部有结构的、大量的、共享的数据集合。 长期存储：持久存储 有结构： 类型：数据库不仅可以存放数据，而且存放的数据还是有类型的 关系：存储数据与数据之间的关系 大量：大多数数据库都是文件系统的，也就是说存储在数据库中的数据实际上就是存储在磁盘的文件中 共享：多个应用程序可以通过数据库实现数据的共享 2.2 关系型数据库与非关系型数据库 关系型数据库 关系型数据库，采用了关系模型来组织数据的存储，以行和列的形式存储数据并记录数据与数据之间的关系 —— 将数据存储在表格中，可以通过建立表格与表格之间的关联来维护数据与数据之间的关系。 学生信息—- 学生表 班级信息—- 班级表 非关系型数据库 非关系型数据库，采用键值对的模型来存储数据，只完成数据的记录，不会记录数据与数据之间的关系。 在非关系型数据库中基于其特定的存储结构来解决一些大数据应用的难题。 NoSQL(Not only SQL)数据库来指代非关系型数据库。 2.3 常见的数据库产品关系型数据库产品 MySQL 免费 MariaDB Percona Server PostgreSQL Oracle 收费 SQL Server Access Sybase 达梦数据库 非关系型数据库产品 面向检索的列式存储 Column-Oriented HaBase （Hadoop子系统） BigTable （Google） 面向高并发的缓存存储Key-Value Redis MemcacheDB 面向海量数据访问的文档存储 Document–Oriented MongoDB CouchDB 2.4 数据库术语 数据库（Database）：存储的数据的集合，提供数据存储的服务 数据（Data）：实际上指的是描述事物的符号记录 数据库管理系统（Database Management System，DBMS ）： 数据库管理系统，是位于用户与操作系统之间的一层数据管理软件 数据库系统管理员（Database Anministrator，简称为DBA）:负责数据库创建、使用及维护的专门人员 数据库系统（Database System，DBS）：数据库系统管理员、数据库管理系统及数据库组成整个单元 三、MySQL数据库环境准备 MySQL下载、安装、配置、卸载，安装DBMS、使用DBMS 3.1 MySQL版本及下载3.1.1 版本 MySQL 是Oracle的免费的关系型数据库 ， 官网 https://www.mysql.com/ MySQL 目前的最新版本为8.0.26 ，在企业项目中主流版本： 5.0 — 5.5 — 5.6 — 5.7 — 8.0.26 5.x — 2020年 5.7.32 8.x — 2018年8.0.11 — 2019年 8.0.16 — 2021年 8.0.26 MySQL 8.x新特性 性能：官方8.x比5.7速度要快2倍 支持NoSQL存储：5.7开始提供了对NoSQL的支持，8.0.x做了更进一步的改进 窗口函数 索引：隐藏索引、降序索引 可用性、可靠性 3.1.2 下载 官网下载：https://dev.mysql.com/downloads/installer/ 需要注册oracle 服务器在国外，下载速度…. 镜像下载：https://www.filehorse.com/download-mysql-64/download/ 3.2 MySQL 安装 傻瓜式（直接点击下一步） 选择Developer Default模式安装 此模式会安装开发人员需要的常用组件；在安装这些组件时需要对应的环境依赖，我们要暂停，先去安装依赖的环境： 例如：Microsoft Visual C++ 2019 Redistributable Package (x64) is not installed. Latest binary compatible version will be installed if agreed to resolve this requirement. 安装： 选择自定义Custom安装 3.3 MySQL配置3.3.1 端口配置 3.3.2 账号密码设置 3.3.3 服务名称 3.4 MySQL 服务的启动与停止 MySQL是以服务的形式运行在系统中 3.4.1 计算机管理窗口此电脑—右键—管理 3.4.2 windows命令行打开命令行 ： win + R — 输入cmd回车 以管理员身份打开命令行：win+s—- 输入cmd—-选择以管理员身份运行 3.5 MySQL卸载 关闭服务 12## 管理员身份启动 cmd 命令行net stop mysql80 卸载软件 打开控制面板 点击“程序和功能” 卸载MySQL 删除目录 MySQL的安装目录：C:\\Program Files (x86)\\MySQL MySQL的数据文件目录(默认隐藏)：C:\\ProgramData\\MySQL (如果不允许删除，强制删除) 删除注册表 打开注册表： win+r — 输入regedit—回车 删除 HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\MySQL80 删除搜索mysql的相关项（非必须） 四、MySQL的管理工具 当完成数据库的安装之后，mysql是以服务的形式运行在windows&#x2F;linux系统，用户是通过DBMS工具来对MySQL进行操作的，当我们安装完成MySQL之后默认安装了mysql Commcand line Client，此工具是一个命令行形式的工具，通常我们会单独安装可视化的DBMS工具： SQLyog Navicat for MySQL 4.1 MySQL Command line Client使用 打开MySQL Command line Client: 开始菜单 — MySQL — MySQL 8.0 Command line Client 连接MySQL : 输入密码即可 （如果密码错误或者mysql服务没有启动，窗口会闪退） 关闭MySQL Command line Client：输入exit指令回车即可退出 4.2 可视化工具Navicat使用4.2.1 Navicat工具下载及安装 傻瓜式安装 4.2.2 创建连接 打开navicat工具 创建连接： 五、MySQL逻辑结构 MySQL可以存储数据，但是存储在MySQL中的数据需要按照特定的结果进行存储 学生 —— 学校 数据 —— 数据库 5.1 逻辑结构 5.2 记录&#x2F;元组 六、SQL 结构化查询语言6.1 SQL概述 SQL（Structured Query Language）结构化查询语言，用于存取、查询、更新数据以及管理关系型数据库系统 6.1.1 SQL发展 SQL是在1981年由IBM公司推出，一经推出基于其简洁的语法在数据库中得到了广泛的应用，成为主流数据库的通用规范 SQL由ANSI组织确定规范 在不同的数据库产品中遵守SQL的通用规范，但是也对SQL有一些不同的改进，形成了一些数据库的专有指令 MySQL: limit SQLServer ： top Oracle：rownum 6.1.2 SQL分类 根据SQL指令完成的数据库操作的不同，可以将SQL指令分为四类： **DDL Data Definition Language 数据定义语言 ** 用于完成对数据库对象（数据库、数据表、视图、索引等）的创建、删除、修改 DMLData Manipulation Language 数据操作&#x2F;操纵语言 用于完成对数据表中的数据的添加、删除、修改操作 添加：将数据存储到数据表 删除：将数据从数据表移除 修改：对数据表中的数据进行修改 DQL Data Query Language 数据查询语言 用于将数据表中的数据查询出来 DCL Data Control Language 数据控制语言 用于完成事务管理等控制性操作 6.2 SQL基本语法 在MySQL Command Line Client 或者navicat等工具中都可以编写SQL指令 SQL指令不区分大小写 每条SQL表达式结束之后都以;结束 SQL关键字之间以空格进行分隔 SQL之间可以不限制换行（可以有空格的地方就可以有换行） 6.3 DDL 数据定义语言6.3.1 DDL-数据库操作 使用DDL语句可以创建数据库、查询数据库、修改数据库、删除数据库 查询数据库 12345## 显示当前mysql中的数据库列表show databases;## 显示指定名称的数据的创建的SQL指令show create database &lt;dbName&gt;; 创建数据库 12345678## 创建数据库 dbName表示创建的数据库名称，可以自定义create database &lt;dbName&gt;;## 创建数据库，当指定名称的数据库不存在时执行创建create database if not exists &lt;dbName&gt;;## 在创建数据库的同时指定数据库的字符集（字符集：数据存储在数据库中采用的编码格式 utf8 gbk）create database &lt;dbName&gt; character set utf8; 修改数据库 修改数据库字符集 12## 修改数据库的字符集alter database &lt;dbName&gt; character set utf8; # utf8 gbk 删除数据库 删除数据库时会删除当前数据库中所有的数据表以及数据表中的数据 12345## 删除数据库drop database &lt;dbName&gt;;## 如果数据库存在则删除数据库drop database is exists &lt;dbName&gt;; 使用&#x2F;切换数据库 1use &lt;dbName&gt; 6.3.2 DDL-数据表操作创建数据表 数据表实际就是一个二维的表格，一个表格是由多列组成，表格中的每一类称之为表格的一个字段 12345678create table students( stu_num char(8) not null unique, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, stu_tel char(11) not null unique, stu_qq varchar(11) unique); 查询数据表 1show tables; 查询表结构 1desc &lt;tableName&gt;; 删除数据表 12345## 删除数据表drop table &lt;tableName&gt;;## 当数据表存在时删除数据表drop table if exists &lt;tableName&gt;; 修改数据表 1234567891011121314151617## 修改表名alter table &lt;tableName&gt; rename to &lt;newTableName&gt;;## 数据表也是有字符集的，默认字符集和数据库一致alter table &lt;tableName&gt; character set utf8;## 添加列（字段）alter table &lt;tableName&gt; add &lt;columnName&gt; varchar(200);## 修改列（字段）的列表和类型alter table &lt;tableName&gt; change &lt;oldColumnName&gt; &lt;newCloumnName&gt; &lt;type&gt;;## 只修改列（字段）类型alter table &lt;tableName&gt; modify &lt;columnName&gt; &lt;newType&gt;;## 删除列（字段）alter table stus drop &lt;columnName&gt;; 6.4 MySQL数据类型 数据类型，指的是数据表中的列中支持存放的数据的类型 6.4.1 数值类型在mysql中有多种数据类型可以存放数值，不同的类型存放的数值的范围或者形式是不同的 类型 内存空间大小 范围 说明 tinyint 1byte 有符号 -128127无符号 0255 特小型整数（年龄） smallint 2byte （16bit） 有符号 -32768 ~ 32767无符号 0~65535 小型整数 mediumint 3byte 有符号 -2^31 ~ 2^31 - 1无符号 0~2^32-1 中型整数 int/integer 4byte 整数 bigint 8byte 大型整数 float 4byte 单精度 double 8byte 双精度 decimal 第一参数+2 decimal(10,2)表示数值一共有10位小数位有2位 6.4.2 字符串类型 存储字符序列的类型 类型 字符长度 说明 char 0~255 字节 定长字符串，最多可以存储255个字符 ;当我们指定数据表字段为char(n)此列中的数据最长为n个字符，如果添加的数据少于n，则补’\\u0000’至n长度 varchar 0~65536 字节 可变长度字符串，此类型的类最大长度为65535 tinyblob 0~255 字节 存储二进制字符串 blob 0~65535 存储二进制字符串 mediumblob 0~1677215 存储二进制字符串 longblob 0~4294967295 存储二进制字符串 tinytext 0~255 文本数据（字符串） text 0~65535 文本数据（字符串） mediumtext 0~1677215 文本数据（字符串） longtext 0~4294967295 文本数据（字符串） 6.4.3 日期类型 在MySQL数据库中，我们可以使用字符串来存储时间，但是如果我们需要基于时间字段进行查询操作（查询在某个时间段内的数据）就不便于查询实现 类型 格式 说明 date 2021-09-13 日期，只存储年月日 time 11:12:13 时间，只存储时分秒 year 2021 年份 datetime 2021-09-13 11:12:13 日期+时间，存储年月日时分秒 timestamp 20210913 111213 日期+时间 （时间戳） 6.5 字段约束6.5.1 约束介绍 在创建数据表的时候，指定的对数据表的列的数据限制性的要求（对表的列中的数据进行限制） 为什么要给表中的列添加约束呢？ 保证数据的有效性 保证数据的完整性 保证数据的正确性 字段常见的约束有哪些呢？ 非空约束（not null）：限制此列的值必须提供，不能为null 唯一约束（unique）：在表中的多条数据，此列的值不能重复 主键约束（primary key）：非空+唯一，能够唯一标识数据表中的一条数据 外键约束（foreign key）：建立不同表之间的关联关系 6.5.2 非空约束 限制数据表中此列的值必须提供 创建表：设置图书表的 book_name not null 12345create table books( book_isbn char(4), book_name varchar(10) not null, book_author varchar(6)); 添加数据： 6.5.3 唯一约束 在表中的多条数据，此列的值不能重复 创建表：设置图书表的book_isbn为 unique 12345create table books( book_isbn char(4) unique, book_name varchar(10) not null, book_author varchar(6)); 添加数据： 6.5.4 主键约束 主键——就是数据表中记录的唯一标识，在一张表中只能有一个主键（主键可以是一个列，也可以是多个列的组合） 当一个字段声明为主键之后，添加数据时： 此字段数据不能为null 此字段数据不能重复 创建表时添加主键约束 12345create table books( book_isbn char(4) primary key, book_name varchar(10) not null, book_author varchar(6)); 或者 123456create table books( book_isbn char(4), book_name varchar(10) not null, book_author varchar(6), primary key(book_isbn)); 删除数据表主键约束 1alter table books drop primary key; 创建表之后添加主键约束 123456789## 创建表时没有添加主键约束create table books( book_isbn char(4), book_name varchar(10) not null, book_author varchar(6));## 创建表之后添加主键约束 alter table books modify book_isbn char(4) primary key; 6.5.5 主键自动增长 在我们创建一张数据表时，如果数据表中有列可以作为主键（例如：学生表的学号、图书表的isbn）我们可以直接这是这个列为主键； 当有些数据表中没有合适的列作为主键时，我们可以额外定义一个与记录本身无关的列（ID）作为主键，此列数据无具体的含义主要用于标识一条记录，在mysql中我们可以将此列定义为int，同时设置为自动增长，当我们向数据表中新增一条记录时，无需提供ID列的值，它会自动生成。 定义主键自动增长 定义int类型字段自动增长：auto_increment 12345create table types( type_id int primary key auto_increment, type_name varchar(20) not null, type_remark varchar(100)); 注意：自动增长从1开始，每添加一条记录，自动的增长的列会自定+1，当我们把某条记录删除之后再添加数据，自动增长的数据也不会重复生成（自动增长只保证唯一性、不保证连续性） 6.5.6 联合主键 联合组件——将数据表中的多列组合在一起设置为表的主键 定义联合主键 123456create table grades( stu_num char(8), course_id int, score int, primary key(stu_num,course_id)); 注意：在实际企业项目的数据库设计中，联合主键使用频率并不高；当一个张数据表中没有明确的字段可以作为主键时，我们可以额外添加一个ID字段作为主键。 6.5.7 外键约束在多表关联部分讲解 6.6 DML 数据操纵语言 用于完成对数据表中数据的插入、删除、修改操作 12345678create table students( stu_num char(8) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, stu_tel char(11) not null unique, stu_qq varchar(11) unique); 6.6.1 插入数据语法 1insert into &lt;tableName&gt;(columnName,columnName....) values(value1,value2....); 示例 12345678910111213## 向数据表中指定的列添加数据（不允许为空的列必须提供数据）insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel) values(&#x27;20210101&#x27;,&#x27;张三&#x27;,&#x27;男&#x27;,21,&#x27;13030303300&#x27;);## 数据表名后的字段名列表顺序可以不与表中一致，但是values中值的顺序必须与表名后字段名顺序对应insert into stus(stu_num,stu_name,stu_age,stu_tel,stu_gender)values(&#x27;20210103&#x27;,&#x27;王五&#x27;,20,&#x27;13030303302&#x27;,&#x27;女&#x27;);## 当要向表中的所有列添加数据时，数据表名后面的字段列表可以省略，但是values中的值的顺序要与数据表定义的字段保持一致; insert into stus values(&#x27;20210105&#x27;,&#x27;孙琦&#x27;,&#x27;男&#x27;,21,&#x27;13030303304&#x27;,&#x27;666666&#x27;);## 不过在项目开发中，即使要向所有列添加数据,也建议将列名的列表显式写出来(增强SQL的稳定性)insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq) values(&#x27;20210105&#x27;,&#x27;孙琦&#x27;,&#x27;男&#x27;,21,&#x27;13030303304&#x27;,&#x27;666666&#x27;); 6.6.2 删除数据 从数据表中删除满足特定条件（所有）的记录 语法 1delete from &lt;tableName&gt; [where conditions]; 实例 12345678## 删除学号为20210102的学生信息delete from stus where stu_num=&#x27;20210102&#x27;;## 删除年龄大于20岁的学生信息(如果满足where子句的记录有多条，则删除多条记录)delete from stus where stu_age&gt;20;## 如果删除语句没有where子句，则表示删除当前数据表中的所有记录(敏感操作)delete from stus; 6.6.3 修改数据 对数据表中已经添加的记录进行修改 语法 1update &lt;tableName&gt; set columnName=value [where conditions] 示例 1234567891011## 将学号为20210105的学生姓名修改为“孙七”（只修改一列）update stus set stu_name=&#x27;孙七&#x27; where stu_num=&#x27;20210105&#x27;;## 将学号为20210103的学生 性别修改为“男”,同时将QQ修改为 777777（修改多列）update stus set stu_gender=&#x27;男&#x27;,stu_qq=&#x27;777777&#x27; where stu_num=&#x27;20210103&#x27;;## 根据主键修改其他所有列 update stus set stu_name=&#x27;韩梅梅&#x27;,stu_gender=&#x27;女&#x27;,stu_age=18,stu_tel=&#x27;13131313311&#x27; ,stu_qq=&#x27;999999&#x27; where stu_num=&#x27;20210102&#x27;; ## 如果update语句没有where子句，则表示修改当前表中所有行（记录）update stus set stu_name=&#x27;Tom&#x27;; 6.7 DQL 数据查询语言 从数据表中提取满足特定条件的记录 单表查询 多表联合查询 6.7.1 查询基础语法12345## select 关键字后指定要显示查询到的记录的哪些列select colnumName1[,colnumName2,colnumName3...] from &lt;tableName&gt; [where conditions];## 如果要显示查询到的记录的所有列，则可以使用 * 替代字段名列表 （在项目开发中不建议使用*）select * from stus; 6.7.2 where 子句 在删除、修改及查询的语句后都可以添加where子句（条件），用于筛选满足特定的添加的数据进行删除、修改和查询操作。 123delete from tableName where conditions;update tabeName set ... where conditions;select .... from tableName where conditions; 条件关系运算符 123456789101112131415161718192021## = 等于select * from stus where stu_num = &#x27;20210101&#x27;;## != &lt;&gt; 不等于select * from stus where stu_num != &#x27;20210101&#x27;;select * from stus where stu_num &lt;&gt; &#x27;20210101&#x27;;## &gt; 大于select * from stus where stu_age&gt;18;## &lt; 小于select * from stus where stu_age&lt;20;## &gt;= 大于等于select * from stus where stu_age&gt;=20;## &lt;= 小于等于select * from stus where stu_age&lt;=20;## between and 区间查询 between v1 and v2 [v1,v2]select * from stus where stu_age between 18 and 20; 条件逻辑运算符 在where子句中，可以将多个条件通过逻辑预算(and or not )进行连接，通过多个条件来筛选要操作的数据。 12345678## and 并且 筛选多个条件同时满足的记录select * from stus where stu_gender=&#x27;女&#x27; and stu_age&lt;21;## or 或者 筛选多个条件中至少满足一个条件的记录select * from stus where stu_gender=&#x27;女&#x27; or stu_age&lt;21;## not 取反select * from stus where stu_age not between 18 and 20; 6.7.3 LIKE 子句 在where子句的条件中，我们可以使用like关键字来实现模糊查询 语法 1select * from tableName where columnName like &#x27;reg&#x27;; 在like关键字后的reg表达式中 %表示任意多个字符 【%o% 包含字母o】 _表示任意一个字符 【_o% 第二个字母为o】 示例 1234567891011# 查询学生姓名包含字母o的学生信息select * from stus where stu_name like &#x27;%o%&#x27;;# 查询学生姓名第一个字为`张`的学生信息select * from stus where stu_name like &#x27;张%&#x27;;# 查询学生姓名最后一个字母为o的学生信息select * from stus where stu_name like &#x27;%o&#x27;;# 查询学生姓名中第二个字母为o的学生信息select * from stus where stu_name like &#x27;_o%&#x27;; 6.7.4 对查询结果的处理设置查询的列 声明显示查询结果的指定列 1select colnumName1,columnName2,... from stus where stu_age&gt;20; 计算列 对从数据表中查询的记录的列进行一定的运算之后显示出来 12345678910111213## 出生年份 = 当前年份 - 年龄select stu_name,2021-stu_age from stus;+-----------+--------------+| stu_name | 2021-stu_age |+-----------+--------------+| omg | 2000 || 韩梅梅 | 2003 || Tom | 2001 || Lucy | 2000 || Polly | 2000 || Theo | 2004 |+-----------+--------------+ as 字段取别名 我们可以为查询结果的列名 去一个语义性更强的别名 (如下案例中as关键字也可以省略) 1234567891011121314151617181920212223select stu_name,2021-stu_age as stu_birth_year from stus;+-----------+----------------+| stu_name | stu_birth_year |+-----------+----------------+| omg | 2000 || 韩梅梅 | 2003 || Tom | 2001 || Lucy | 2000 || Polly | 2000 || Theo | 2004 |+-----------+----------------+ select stu_name as 姓名,2021-stu_age as 出生年份 from stus;+-----------+--------------+| 姓名 | 出生年份 |+-----------+--------------+| omg | 2000 || 韩梅梅 | 2003 || Tom | 2001 || Lucy | 2000 || Polly | 2000 || Theo | 2004 |+-----------+--------------+ distinct 消除重复行 从查询的结果中将重复的记录消除 distinct 123456789101112131415161718192021select stu_age from stus;+---------+| stu_age |+---------+| 21 || 18 || 20 || 21 || 21 || 17 |+---------+select distinct stu_age from stus;+---------+| stu_age |+---------+| 21 || 18 || 20 || 17 |+---------+ 6.7.5 排序 - order by 将查询到的满足条件的记录按照指定的列的值升序&#x2F;降序排列 语法 1select * from tableName where conditions order by columnName asc|desc; order by columnName 表示将查询结果按照指定的列排序 asc 按照指定的列升序（默认） desc 按照指定的列降序 实例 12345678910111213141516171819202122232425# 单字段排序select * from stus where stu_age&gt;15 order by stu_gender desc;+----------+-----------+------------+---------+-------------+--------+| stu_num | stu_name | stu_gender | stu_age | stu_tel | stu_qq |+----------+-----------+------------+---------+-------------+--------+| 20210101 | omg | 男 | 21 | 13030303300 | NULL || 20210103 | Tom | 男 | 20 | 13030303302 | 777777 || 20210105 | Polly | 男 | 21 | 13030303304 | 666666 || 20210106 | Theo | 男 | 17 | 13232323322 | NULL || 20210102 | 韩梅梅 | 女 | 18 | 13131313311 | 999999 || 20210104 | Lucy | 女 | 21 | 13131323334 | NULL |+----------+-----------+------------+---------+-------------+--------+# 多字段排序 ： 先满足第一个排序规则，当第一个排序的列的值相同时再按照第二个列的规则排序select * from stus where stu_age&gt;15 order by stu_gender asc,stu_age desc;+----------+-----------+------------+---------+-------------+--------+| stu_num | stu_name | stu_gender | stu_age | stu_tel | stu_qq |+----------+-----------+------------+---------+-------------+--------+| 20210104 | Lucy | 女 | 21 | 13131323334 | NULL || 20210102 | 韩梅梅 | 女 | 18 | 13131313311 | 999999 || 20210101 | omg | 男 | 21 | 13030303300 | NULL || 20210105 | Polly | 男 | 21 | 13030303304 | 666666 || 20210103 | Tom | 男 | 20 | 13030303302 | 777777 || 20210106 | Theo | 男 | 17 | 13232323322 | NULL |+----------+-----------+------------+---------+-------------+--------+ 6.7.6 聚合函数 SQL中提供了一些可以对查询的记录的列进行计算的函数——聚合函数 count max min sum avg count() 统计函数，统计满足条件的指定字段值的个数（记录数） 123456789101112131415# 统计学生表中学生总数select count(stu_num) from stus;+----------------+| count(stu_num) |+----------------+| 7 |+----------------+# 统计学生表中性别为男的学生总数select count(stu_num) from stus where stu_gender=&#x27;男&#x27;;+----------------+| count(stu_num) |+----------------+| 5 |+----------------+ max() 计算最大值，查询满足条件的记录中指定列的最大值 12345678910111213select max(stu_age) from stus;+--------------+| max(stu_age) |+--------------+| 21 |+--------------+select max(stu_age) from stus where stu_gender=&#x27;女&#x27;;+--------------+| max(stu_age) |+--------------+| 21 |+--------------+ min() 计算最小值，查询满足条件的记录中指定列的最小值 12345678910111213select min(stu_age) from stus;+--------------+| min(stu_age) |+--------------+| 14 |+--------------+select min(stu_age) from stus where stu_gender=&#x27;女&#x27;;+--------------+| min(stu_age) |+--------------+| 18 |+--------------+ sum() 计算和，查询满足条件的记录中 指定的列的值的总和 123456789101112131415# 计算所有学生年龄的综合select sum(stu_age) from stus;+--------------+| sum(stu_age) |+--------------+| 133 |+--------------+# 计算所有性别为男的学生的年龄的综合select sum(stu_age) from stus where stu_gender=&#x27;男&#x27;;+--------------+| sum(stu_age) |+--------------+| 94 |+--------------+ avg() 求平均值，查询满足条件的记录中 计算指定列的平均值 12345678910111213select avg(stu_age) from stus;+--------------+| avg(stu_age) |+--------------+| 19.0000 |+--------------+select avg(stu_age) from stus where stu_gender=&#x27;男&#x27;;+--------------+| avg(stu_age) |+--------------+| 18.8000 |+--------------+ 6.7.7 日期函数 和 字符串函数日期函数 当我们向日期类型的列添加数据时，可以通过字符串类型赋值（字符串的格式必须为 yyyy-MM-dd hh:mm:ss） 如果我们想要获取当前系统时间添加到日期类型的列，可以使用now() 或者 sysdate() 示例： 123456789101112131415161718192021222324252627282930313233343536373839desc stus;+---------------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------------+-------------+------+-----+---------+-------+| stu_num | char(8) | NO | PRI | NULL | || stu_name | varchar(20) | NO | | NULL | || stu_gender | char(2) | YES | | NULL | || stu_age | int | NO | | NULL | || stu_tel | char(11) | NO | UNI | NULL | || stu_qq | varchar(11) | YES | UNI | NULL | || stu_enterence | datetime | YES | | NULL | |+---------------+-------------+------+-----+---------+-------+# 通过字符串类型 给日期类型的列赋值insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_enterence)values(&#x27;20200108&#x27;,&#x27;张小三&#x27;,&#x27;女&#x27;,20,&#x27;13434343344&#x27;,&#x27;123111&#x27;,&#x27;2021-09-01 09:00:00&#x27;);# 通过now()获取当前时间insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_enterence)values(&#x27;20210109&#x27;,&#x27;张小四&#x27;,&#x27;女&#x27;,20,&#x27;13434343355&#x27;,&#x27;1233333&#x27;,now());# 通过sysdate()获取当前时间insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_enterence)values(&#x27;20210110&#x27;,&#x27;李雷&#x27;,&#x27;男&#x27;,16,&#x27;13434343366&#x27;,&#x27;123333344&#x27;,sysdate());# 通过now和sysdate获取当前系统时间mysql&gt; select now();+---------------------+| now() |+---------------------+| 2021-09-10 16:22:19 |+---------------------+mysql&gt; select sysdate();+---------------------+| sysdate() |+---------------------+| 2021-09-10 16:22:26 |+---------------------+ 字符串函数 就是通过SQL指令对字符串进行处理 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# concat(colnum1,colunm2,...) 拼接多列select concat(stu_name,&#x27;-&#x27;,stu_gender) from stus;+---------------------------------+| concat(stu_name,&#x27;-&#x27;,stu_gender) |+---------------------------------+| 韩梅梅-女 || Tom-男 || Lucy-女 || 林涛-男 |+---------------------------------+# upper(column) 将字段的值转换成大写mysql&gt; select upper(stu_name) from stus;+-----------------+| upper(stu_name) |+-----------------+| 韩梅梅 || TOM || LUCY || POLLY || THEO || 林涛 |+-----------------+# lower(column) 将指定列的值转换成小写mysql&gt; select lower(stu_name) from stus;+-----------------+| lower(stu_name) |+-----------------+| 韩梅梅 || tom || lucy || polly || theo |+-----------------+# substring(column,start,len) 从指定列中截取部分显示 start从1开始mysql&gt; select stu_name,substring(stu_tel,8,4) from stus;+-----------+------------------------+| stu_name | substring(stu_tel,8,4) |+-----------+------------------------+| 韩梅梅 | 3311 || Tom | 3302 || Lucy | 3334 |+-----------+------------------------+ 6.7.8 分组查询 - group by 分组——就是将数据表中的记录按照指定的类进行分组 语法 12345select 分组字段/聚合函数 from 表名 [where 条件] group by 分组列名 [having 条件][order by 排序字段] select 后使用* 显示对查询的结果进行分组之后，显示每组的第一条记录（这种显示通常是无意义的） select后通常显示分组字段和聚合函数(对分组后的数据进行统计、求和、平均值等) 语句执行属性： 1️⃣先根据where条件从数据库查询记录 2️⃣group by对查询记录进行分组 3️⃣执行having对分组后的数据进行筛选 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 先对查询的学生信息按性别进行分组（分成了男、女两组），然后再分别统计每组学生的个数select stu_gender,count(stu_num) from stus group by stu_gender;+------------+----------------+| stu_gender | count(stu_num) |+------------+----------------+| 女 | 4 || 男 | 5 |+------------+----------------+# 先对查询的学生信息按性别进行分组（分成了男、女两组），然后再计算每组的平均年龄select stu_gender,avg(stu_age) from stus group by stu_gender;+------------+--------------+| stu_gender | avg(stu_age) |+------------+--------------+| 女 | 19.7500 || 男 | 18.2000 |+------------+--------------+# 先对学生按年龄进行分组（分了16、17、18、20、21、22六组），然后统计各组的学生数量，还可以对最终的结果排序select stu_age,count(stu_num) from stus group by stu_age order by stu_age;+---------+----------------+| stu_age | count(stu_num) |+---------+----------------+| 16 | 2 || 17 | 1 || 18 | 1 || 20 | 3 || 21 | 1 || 22 | 1 |+---------+----------------+# 查询所有学生，按年龄进行分组，然后分别统计每组的人数，再筛选当前组人数&gt;1的组，再按年龄升序显示出来select stu_age,count(stu_num) from stus group by stu_age having count(stu_num)&gt;1 order by stu_age;+---------+----------------+| stu_age | count(stu_num) |+---------+----------------+| 16 | 2 || 20 | 3 |+---------+----------------+# 查询性别为&#x27;男&#x27;的学生，按年龄进行分组，然后分别统计每组的人数，再筛选当前组人数&gt;1的组，再按年龄升序显示出来mysql&gt; select stu_age,count(stu_num) -&gt; from stus -&gt; where stu_gender=&#x27;男&#x27; -&gt; group by stu_age -&gt; having count(stu_num)&gt;1 -&gt; order by stu_age;+---------+----------------+| stu_age | count(stu_num) |+---------+----------------+| 16 | 2 || 20 | 2 |+---------+----------------+ 6.7.9 分页查询 - limit 当数据表中的记录比较多的时候，如果一次性全部查询出来显示给用户，用户的可读性&#x2F;体验性就不太好，因此我们可以将这些数据分页进行展示。 语法 1234select ... from ... where ...limit param1,param2 param1 int , 表示获取查询语句的结果中的第一条数据的索引（索引从0开始） param2 int, 表示获取的查询记录的条数（如果剩下的数据条数&lt;param2，则返回剩下的所有记录） 案例 对数据表中的学生信息进行分页显示，总共有10条数据，我们每页显示3条 总记录数 count 10 每页显示 pageSize 3 总页数： pageCount &#x3D; count%pageSize&#x3D;&#x3D;0 ? count&#x2F;pageSize : count&#x2F;pageSize +1; 1234567891011121314151617# 查询第一页：select * from stus [where ...] limit 0,3; (1-1)*3# 查询第二页：select * from stus [where ...] limit 3,3; (2-1)*3# 查询第三页：select * from stus [where ...] limit 6,3; (3-1)*3# 查询第四页：select * from stus [where ...] limit 9,3; (4-1)*3# 如果在一张数据表中：# pageNum表示查询的页码# pageSize表示每页显示的条数# 通用分页语句如下：select * from &lt;tableName&gt; [where ...] limit (pageNum-1)*pageSize,pageSize; 七、数据表的关联关系7.1 关联关系介绍 MySQL是一个关系型数据库，不仅可以存储数据，还可以维护数据与数据之间的关系——通过在数据表中添加字段建立外键约束 数据与数据之间的关联关系分为四种： 一对一关联 一对多关联 多对一关联 多对多关联 7.2 一对一关联 人 — 身份证 一个人只有一个身份证、一个身份证只对应一个人 学生 — 学籍 一个学生只有一个学籍、一个学籍也对应唯一的一个学生 用户 — 用户详情 一个用户只有一个详情、一个详情也只对应一个用户 方案1： 主键关联——两张数据表中主键相同的数据为相互对应的数据 方案2：唯一外键 —— 在任意一张表中添加一个字段添加外键约束与另一张表主键关联，并且将外键列添加唯一约束 7.3 一对多与多对一 班级 — 学生 （一对多） 一个班级包含多个学生 学生 — 班级 （多对一） 多个学生可以属于同一个班级 图书 — 分类 商品 —- 商品类别 方案：在多的一端添加外键 ，与一的一端主键进行关联 7.4 多对多关联 学生 — 课程 一个学生可以选择多门课、一门课程也可以由多个学生选择 会员 — 社团 一个会员可以参加多个社团、一个社团也可以招纳多个会员 方法：额外创建一张关系表来维护多对多关联——在关系表中定义两个外键，分别与两个数据表的主键进行关联 7.5 外键约束 外键约束——将一个列添加外键约束与另一张表的主键(唯一列)进行关联之后，这个外键约束的列添加的数据必须要在关联的主键字段中存在 案例：学生表 与 班级表 先创建班级表 12345create table classes( class_id int primary key auto_increment, class_name varchar(40) not null unique, class_remark varchar(200)); 创建学生表（在学生表中添加外键与班级表的主键进行关联） 123456789101112131415161718192021222324# 【方式一】在创建表的时候，定义cid字段，并添加外键约束# 由于cid 列 要与classes表的class_id进行关联，因此cid字段类型和长度要与 class_id一致create table students( stu_num char(8) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, cid int, constraint FK_STUDENTS_CLASSES foreign key(cid) references classes(class_id));#【方式二】先创建表，再添加外键约束create table students( stu_num char(8) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, cid int);# 在创建表之后，为cid添加外键约束alter table students add constraint FK_STUDENTS_CLASSES foreign key(cid) references classes(class_id);# 删除外键约束alter table students drop foreign key FK_STUDENTS_CLASSES; 向班级表添加班级信息 1234567891011121314insert into classes(class_name,class_remark) values(&#x27;Java2104&#x27;,&#x27;...&#x27;);insert into classes(class_name,class_remark) values(&#x27;Java2105&#x27;,&#x27;...&#x27;);insert into classes(class_name,class_remark) values(&#x27;Java2106&#x27;,&#x27;...&#x27;);insert into classes(class_name,class_remark) values(&#x27;Python2106&#x27;,&#x27;...&#x27;);select * from classes;+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 1 | Java2104 | ... || 2 | Java2105 | ... || 3 | Java2106 | ... || 4 | Python2106 | ... |+----------+------------+--------------+ 向学生表中添加学生信息 123456insert into students(stu_num,stu_name,stu_gender,stu_age,cid)values(&#x27;20210102&#x27;,&#x27;李斯&#x27;,&#x27;女&#x27;,20, 4 );# 添加学生时，设置给cid外键列的值必须在其关联的主表classes的classs_id列存在insert into students(stu_num,stu_name,stu_gender,stu_age,cid)values(&#x27;20210103&#x27;,&#x27;王五&#x27;,&#x27;男&#x27;,20, 6 ); 7.6 外键约束-级联 当学生表中存在学生信息关联班级表的某条记录时，就不能对班级表的这条记录进行修改ID和删除操作，如下： 123456789101112131415161718192021222324252627mysql&gt; select * from classes;+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 1 | Java2104 | ... | # 班级表中class_id=1的班级信息 被学生表中的记录关联了| 2 | Java2105 | ... | # 我们就不能修改Java2104的class_id,并且不能删除 | 3 | Java2106 | ... || 4 | Python2106 | ... |+----------+------------+--------------+mysql&gt; select * from students;+----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210101 | 张三 | 男 | 18 | 1 || 20210102 | 李四 | 男 | 18 | 1 || 20210103 | 王五 | 男 | 18 | 1 || 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+mysql&gt; update classes set class_id=5 where class_name=&#x27;Java2104&#x27;;ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`db_test2`.`students`, CONSTRAINT `FK_STUDENTS_CLASSES` FOREIGN KEY (`cid`) REFERENCES `classes` (`class_id`))mysql&gt; delete from classes where class_id=1;ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`db_test2`.`students`, CONSTRAINT `FK_STUDENTS_CLASSES` FOREIGN KEY (`cid`) REFERENCES `classes` (`class_id`)) 如果一定要修改Java2104 的班级ID，该如何实现呢 ？ 将引用Java2104班级id的学生记录中的cid修改为 NULL 在修改班级信息表中Java2104记录的 class_id 将学生表中cid设置为NULL的记录的cid重新修改为 Java2104这个班级的新的id 12345678910111213141516171819202122232425262728291️⃣update students set cid=NULL where cid=1; # 结果如下：+----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210101 | 张三 | 男 | 18 | NULL || 20210102 | 李四 | 男 | 18 | NULL || 20210103 | 王五 | 男 | 18 | NULL || 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+2️⃣update classes set class_id=5 where class_name=&#x27;Java2104&#x27;; # 结果如下+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 2 | Java2105 | ... || 3 | Java2106 | ... || 4 | Python2106 | ... || 5 | Java2104 | ... |+----------+------------+--------------+3️⃣update students set cid=5 where cid IS NULL; # 结果如下+----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210101 | 张三 | 男 | 18 | 5 || 20210102 | 李四 | 男 | 18 | 5 || 20210103 | 王五 | 男 | 18 | 5 || 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+ 我们可以使用级联操作来实现： 在添加外键时，设置级联修改 和 级联删除 12345# 删除原有的外键alter table students drop foreign key FK_STUDENTS_CLASSES;# 重新添加外键，并设置级联修改和级联删除alter table students add constraint FK_STUDENTS_CLASSES foreign key(cid) references classes(class_id) ON UPDATE CASCADE ON DELETE CASCADE; 测试级联修改： 12345678910111213141516171819202122232425262728293031323334353637383940# 班级信息+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 2 | Java2105 | ... || 3 | Java2106 | ... || 4 | Python2106 | ... || 5 | Java2104 | ... |+----------+------------+--------------+# 学生信息+----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210101 | 张三 | 男 | 18 | 5 || 20210102 | 李四 | 男 | 18 | 5 || 20210103 | 王五 | 男 | 18 | 5 || 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+# 直接修改Java2104的class_id,关联Java2104这个班级的学生记录的cid也会同步修改update classes set class_id=1 where class_name=&#x27;Java2104&#x27;;# 班级信息+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 2 | Java2105 | ... || 3 | Java2106 | ... || 4 | Python2106 | ... || 1 | Java2104 | ... |+----------+------------+--------------+# 学生信息+----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210101 | 张三 | 男 | 18 | 1 || 20210102 | 李四 | 男 | 18 | 1 || 20210103 | 王五 | 男 | 18 | 1 || 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+ 测试级联删除 123456789101112131415# 删除class_id=1的班级信息，学生表引用此班级信息的记录也会被同步删除delete from classes where class_id=1;+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 2 | Java2105 | ... || 3 | Java2106 | ... || 4 | Python2106 | ... |+----------+------------+--------------++----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+ 八、连接查询 通过对DQL的学习，我们可以很轻松的从一张数据表中查询出需要的数据；在企业的应用开发中，我们经常需要从多张表中查询数据（例如：我们查询学生信息的时候需要同时查询学生的班级信息），可以通过连接查询从多张数据表提取数据: 在MySQL中可以使用join实现多表的联合查询——连接查询，join按照其功能不同分为三个操作： inner join 内连接 left join 左连接 right join 右连接 8.1 数据准备8.1.1 创建数据表创建班级信息表 和 学生信息表 12345678910111213create table classes( class_id int primary key auto_increment, class_name varchar(40) not null unique, class_remark varchar(200));create table students( stu_num char(8) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, cid int, constraint FK_STUDENTS_CLASSES foreign key(cid) references classes(class_id) ON UPDATE CASCADE ON DELETE CASCADE); 8.1.2 添加数据添加班级信息 123456789# Java2104 包含三个学生信息insert into classes(class_name,class_remark) values(&#x27;Java2104&#x27;,&#x27;...&#x27;);# Java2105 包含两个学生信息insert into classes(class_name,class_remark) values(&#x27;Java2105&#x27;,&#x27;...&#x27;);# 以下两个班级在学生表中没有对应的学生信息insert into classes(class_name,class_remark) values(&#x27;Java2106&#x27;,&#x27;...&#x27;);insert into classes(class_name,class_remark) values(&#x27;Python2105&#x27;,&#x27;...&#x27;); 添加学生信息 1234567891011121314151617# 以下三个学生信息 属于 class_id=1 的班级 （Java2104）insert into students(stu_num,stu_name,stu_gender,stu_age,cid) values(&#x27;20210101&#x27;,&#x27;张三&#x27;,&#x27;男&#x27;,20,1);insert into students(stu_num,stu_name,stu_gender,stu_age,cid) values(&#x27;20210102&#x27;,&#x27;李四&#x27;,&#x27;女&#x27;,20,1);insert into students(stu_num,stu_name,stu_gender,stu_age,cid) values(&#x27;20210103&#x27;,&#x27;王五&#x27;,&#x27;男&#x27;,20,1);# 以下三个学生信息 属于 class_id=2 的班级 （Java2105）insert into students(stu_num,stu_name,stu_gender,stu_age,cid) values(&#x27;20210104&#x27;,&#x27;赵柳&#x27;,&#x27;女&#x27;,20,2);insert into students(stu_num,stu_name,stu_gender,stu_age,cid) values(&#x27;20210105&#x27;,&#x27;孙七&#x27;,&#x27;男&#x27;,20,2);# 小红和小明没有设置班级信息insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;20210106&#x27;,&#x27;小红&#x27;,&#x27;女&#x27;,20);insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;20210107&#x27;,&#x27;小明&#x27;,&#x27;男&#x27;,20); 8.2 内连接 INNER JOIN语法 1select ... from tableName1 inner join tableName2 ON 匹配条件 [where 条件]; 8.2.1 笛卡尔积 笛卡尔积（A集合&amp;B集合）：使用A中的每个记录一次关联B中每个记录，笛卡尔积的总数&#x3D;A总数*B总数 如果直接执行select ... from tableName1 inner join tableName2;会获取两种数据表中的数据集合的笛卡尔积（依次使用tableName1 表中的每一条记录 去 匹配 tableName2的每条数据） 8.2.2 内连接条件 两张表时用inner join连接查询之后生产的笛卡尔积数据中很多数据都是无意义的，我们如何消除无意义的数据呢？ —— 添加两张进行连接查询时的条件 使用 on设置两张表连接查询的匹配条件 12345-- 使用where设置过滤条件：先生成笛卡尔积再从笛卡尔积中过滤数据（效率很低）select * from students INNER JOIN classes where students.cid = classes.class_id;-- 使用ON设置连接查询条件：先判断连接条件是否成立，如果成立两张表的数据进行组合生成一条结果记录select * from students INNER JOIN classes ON students.cid = classes.class_id; 结果：只获取两种表中匹配条件成立的数据，任何一张表在另一种表如果没有找到对应匹配则不会出现在查询结果中（例如：小红和小明没有对应的班级信息，Java2106和Python2106没有对应的学生）。 8.2 左连接 LEFT JOIN 需求：请查询出所有的学生信息，如果学生有对应的班级信息，则将对应的班级信息也查询出来 左连接：显示左表中的所有数据，如果在有右表中存在与左表记录满足匹配条件的数据，则进行匹配；如果右表中不存在匹配数据，则显示为Null 12345# 语法select * from leftTabel LEFT JOIN rightTable ON 匹配条件 [where 条件];-- 左连接 : 显示左表中的所有记录select * from students LEFT JOIN classes ON students.cid = classes.class_id; 8.3 右连接 RIGHT JOIN12-- 右连接 ：显示右表中的所有记录select * from students RIGHT JOIN classes ON students.cid = classes.class_id; 8.4 数据表别名 如果在连接查询的多张表中存在相同名字的字段，我们可以使用表名.字段名来进行区分，如果表名太长则不便于SQL语句的编写，我们可以使用数据表别名 使用示例： 1234select s.*,c.class_namefrom students sINNER JOIN classes cON s.cid = c.class_id; 8.5 子查询&#x2F;嵌套查询 子查询 — 先进行一次查询，第一次查询的结果作为第二次查询的源&#x2F;条件（第二次查询是基于第一次的查询结果来进行的） 8.5.1 子查询返回单个值-单行单列案例1：查询班级名称为&#39;Java2104&#39;班级中的学生信息(只知道班级名称，而不知道班级ID) 传统的方式： 12345-- a.查询Java2104班的班级编号select class_id from classes where class_name=&#x27;Java2104&#x27;;-- b.查询此班级编号下的学生信息select * from students where cid = 1; 子查询： 12-- 如果子查询返回的结果是一个值（单列单行），条件可以直接使用关系运算符（= != ....）select * from students where cid = (select class_id from classes where class_name=&#x27;Java2105&#x27;); 8.5.2 子查询返回多个值-多行单列案例2：查询所有Java班级中的学生信息 传统的方式： 12345678910111213141516-- a.查询所有Java班的班级编号select class_id from classes where class_name LIKE &#x27;Java%&#x27;;+--------------+| class_id |+--------------+| 1 || 2 || 3 |+--------------+-- b.查询这些班级编号中的学生信息(union 将多个查询语句的结果整合在一起)select * from students where cid=1UNIONselect * from students where cid=2UNIONselect * from students where cid=3; 子查询 12-- 如果子查询返回的结果是多个值（单列多行），条件使用IN / NOT INselect * from students where cid IN (select class_id from classes where class_name LIKE &#x27;Java%&#x27;); 8.5.3 子查询返回多个值-多行多列案例3：查询cid=1的班级中性别为男的学生信息 123456-- 多条件查询：select * from students where cid=1 and stu_gender=&#x27;男&#x27;;-- 子查询:先查询cid=1班级中的所有学生信息，将这些信息作为一个整体虚拟表(多行多列)-- 再基于这个虚拟表查询性别为男的学生信息（‘虚拟表’需要别名）select * from (select * from students where cid=1) t where t.stu_gender=&#x27;男&#x27;; 九、存储过程9.1 存储过程介绍9.1.1 SQL指令执行过程 从SQL执行执行的流程中我们分析存在的问题： 如果我们需要重复多次执行相同的SQL，SQL执行都需要通过连接传递到MySQL，并且需要经过编译和执行的步骤； 如果我们需要连续执行多个SQL指令，并且第二个SQL指令需要使用第一个SQL指令执行的结果作为参数； 9.1.2 存储过程的介绍 存储过程： 将能够完成特定功能的SQL指令进行封装（SQL指令集），编译之后存储在数据库服务器上，并且为之取一个名字，客户端可以通过名字直接调用这个SQL指令集，获取执行结果。 9.1.3 存储过程优缺点分析存储过程优点： SQL指令无需客户端编写，通过网络传送，可以节省网络开销，同时避免SQL指令在网络传输过程中被恶意篡改保证安全性； 存储过程经过编译创建并保存在数据库中的，执行过程无需重复的进行编译操作，对SQL指令的执行过程进行了性能提升； 存储过程中多个SQL指令之间存在逻辑关系，支持流程控制语句（分支、循环），可以实现更为复杂的业务; 存储过程的缺点： 存储过程是根据不同的数据库进行编译、创建并存储在数据库中；当我们需要切换到其他的数据库产品时，需要重写编写针对于新数据库的存储过程； 存储过程受限于数据库产品，如果需要高性能的优化会成为一个问题； 在互联网项目中，如果需要数据库的高（连接）并发访问，使用存储过程会增加数据库的连接执行时间（因为我们将复杂的业务交给了数据库进行处理） 9.2 创建存储过程9.2.1 存储过程创建语法12345-- 语法:create procedure &lt;proc_name&gt;([IN/OUT args])begin -- SQLend; 9.2.2 示例123456-- 创建一个存储过程实现加法运算: Java语法中，方法是有参数和返回值的-- 存储过程中，是有输入参数 和 输出参数的create procedure proc_test1(IN a int,IN b int,OUT c int)begin SET c = a+b;end; 9.3 调用存储过程1234567-- 调用存储过程-- 定义变量@mset @m = 0;-- 调用存储过程，将3传递给a，将2传递给b，将@m传递给ccall proc_test1(3,2,@m);-- 显示变量值select @m from dual; 9.4 存储过程中变量的使用 存储过程中的变量分为两种：局部变量 和 用户变量 9.4.1 定义局部变量局部变量：定义在存储过程中的变量，只能在存储过程内部使用 局部变量定义语法 12-- 局部变量要定义在存储过程中，而且必须定义在存储过程开始declare &lt;attr_name&gt; &lt;type&gt; [default value]; 局部变量定义示例： 12345678create procedure proc_test2(IN a int,OUT r int)begin declare x int default 0; -- 定义x int类型，默认值为0 declare y int default 1; -- 定义y set x = a*a; set y = a/2; set r = x+y;end; 9.4.2 定义用户变量用户变量：相当于全局变量，定义的用户变量可以通过select @attrName from dual进行查询 123-- 用户变量会存储在mysql数据库的数据字典中（dual）-- 用户变量定义使用set关键字直接定义，变量名要以@开头set @n=1; 9.4.3 给变量设置值 无论是局部变量还是用户变量，都是使用set关键字修改值 123set @n=1;call proc_test2(6,@n);select @n from dual; 9.4.4 将查询结果赋值给变量在存储过程中使用select..into..给变量赋值 123456789-- 查询学生数量create procedure proc_test3(OUT c int)begin select count(stu_num) INTO c from students; -- 将查询到学生数量赋值给cend;-- 调用存储过程call proc_test3(@n);select @n from dual; 9.4.5 用户变量使用注意事项 因为用户变量相当于全局变量，可以在SQL指令以及多个存储过程中共享，在开发中建议尽量少使用用户变量，用户变量过多会导致程序不易理解、难以维护。 9.5 存储过程的参数 MySQL存储过程的参数一共有三种：IN \\ OUT \\ INOUT 9.5.1 IN 输入参数输入参数——在调用存储过程中传递数据给存储过程的参数（在调用的过程必须为具有实际值的变量 或者 字面值） 12345678-- 创建存储过程：添加学生信息create procedure proc_test4(IN snum char(8),IN sname varchar(20), IN gender char(2), IN age int, IN cid int, IN remark varchar(255))begin insert into students(stu_num,stu_name,stu_gender,stu_age,cid,remark) values(snum,sname,gender,age,cid,remark);end;call proc_test4(&#x27;20210108&#x27;,&#x27;小丽&#x27;,&#x27;女&#x27;,20,1,&#x27;aaa&#x27;); 9.5.2 OUT 输出参数输出参数——将存储过程中产生的数据返回给过程调用者，相当于Java方法的返回值，但不同的是一个存储过程可以有多个输出参数 123456789-- 创建存储过程，根据学生学号，查询学生姓名create procedure proc_test5(IN snum char(8),OUT sname varchar(20))begin select stu_name INTO sname from students where stu_num=snum;end;set @name=&#x27;&#x27;;call proc_test5(&#x27;20210108&#x27;,@name);select @name from dual; 9.5.3 INOUT 输入输出参数12345678create procedure proc_test6(INOUT str varchar(20))begin select stu_name INTO str from students where stu_num=str;end;set @name=&#x27;20210108&#x27;;call proc_test6(@name);select @name from dual; 9.6 存储过程中流程控制 在存储过程中支持流程控制语句用于实现逻辑的控制 9.6.1 分支语句 if-then-else 1234567891011-- 单分支：如果条件成立，则执行SQLif conditions then -- SQLend if;-- 如果参数a的值为1，则添加一条班级信息create procedure proc_test7(IN a int)begin if a=1 then insert into classes(class_name,remark) values(&#x27;Java2109&#x27;,&#x27;test&#x27;); end if;end; 12345678910111213141516-- 双分支：如果条件成立则执行SQL1，否则执行SQL2if conditions then -- SQL1else -- SQL2end if;-- 如果参数a的值为1，则添加一条班级信息；否则添加一条学生信息create procedure proc_test7(IN a int)begin if a=1 then insert into classes(class_name,remark) values(&#x27;Java2109&#x27;,&#x27;test&#x27;); else insert into students(stu_num,stu_name,stu_gender,stu_age,cid,remark) values(&#x27;20210110&#x27;,&#x27;小花&#x27;,&#x27;女&#x27;,19,1,&#x27;...&#x27;); end if;end; case 12345678910111213141516-- casecreate procedure proc_test8(IN a int)begin case a when 1 then -- SQL1 如果a的值为1 则执行SQL1 insert into classes(class_name,remark) values(&#x27;Java2110&#x27;,&#x27;wahaha&#x27;); when 2 then -- SQL2 如果a的值为2 则执行SQL2 insert into students(stu_num,stu_name,stu_gender,stu_age,cid,remark) values(&#x27;20210111&#x27;,&#x27;小刚&#x27;,&#x27;男&#x27;,21,2,&#x27;...&#x27;); else -- SQL (如果变量的值和所有when的值都不匹配，则执行else中的这个SQL) update students set stu_age=18 where stu_num=&#x27;20210110&#x27;; end case;end; 9.6.2 循环语句 while 12345678910111213-- whilecreate procedure proc_test9(IN num int)begin declare i int; set i = 0; while i&lt;num do -- SQL insert into classes(class_name,remark) values( CONCAT(&#x27;Java&#x27;,i) ,&#x27;....&#x27;); set i = i+1; end while;end;call proc_test9(4); repeat 12345678910111213-- repeatcreate procedure proc_test10(IN num int)begin declare i int; set i = 1; repeat -- SQL insert into classes(class_name,remark) values( CONCAT(&#x27;Python&#x27;,i) ,&#x27;....&#x27;); set i = i+1; until i &gt; num end repeat;end;call proc_test10(4); loop 12345678910111213141516-- loopcreate procedure proc_test11(IN num int)begin declare i int ; set i =0; myloop:loop -- SQL insert into classes(class_name,remark) values( CONCAT(&#x27;HTML&#x27;,i) ,&#x27;....&#x27;); set i = i+1; if i=num then leave myloop; end if; end loop;end;call proc_test11(5); 9.7 存储过程管理9.7.1 查询存储过程 存储过程是属于某个数据库的，也就是说当我们将存储过程创建在某个数据库之后，只能在当前数据库中调用此存储过程。 查询存储过程：查询某个数据库中有哪些存储过程 12345-- 根据数据库名，查询当前数据库中的存储过程show procedure status where db=&#x27;db_test2&#x27;;-- 查询存储过程的创建细节show create procedure db_test2.proc_test1; 9.7.2 修改存储过程 修改存储过程指的是修改存储过程的特征&#x2F;特性 1alter procedure &lt;proc_name&gt; 特征1 [特征2 特征3 ....] 存储过程的特征参数： CONTAINS SQL 表示子程序包含 SQL 语句，但不包含读或写数据的语句 NO SQL 表示子程序中不包含 SQL 语句 READS SQL DATA 表示子程序中包含读数据的语句 MODIFIES SQL DATA 表示子程序中包含写数据的语句 SQL SECURITY { DEFINER |INVOKER } 指明谁有权限来执行 DEFINER 表示只有定义者自己才能够执行 INVOKER 表示调用者可以执行 COMMENT &#39;string&#39; 表示注释信息 1alter procedure proc_test1 READS SQL DATA; 9.7.3 删除存储过程1234-- 删除存储过程-- drop 删除数据库中的对象 数据库、数据表、列、存储过程、视图、触发器、索引....-- delete 删除数据表中的数据drop procedure proc_test1; 9.8 存储过程练习案例 使用存储过程解决企业项目开发过程中的问题 案例：使用存储过程完成借书操作 9.8.1 数据准备12345678910111213141516171819202122232425262728293031323334-- 创建数据库create database db_test3;-- 使用数据库use db_test3;-- 创建图书信息表：create table books( book_id int primary key auto_increment, book_name varchar(50) not null, book_author varchar(20) not null, book_price decimal(10,2) not null, book_stock int not null, book_desc varchar(200));-- 添加图书信息insert into books(book_name,book_author,book_price,book_stock,book_desc)values(&#x27;Java程序设计&#x27;,&#x27;亮亮&#x27;,38.80,12,&#x27;亮亮老师带你学Java&#x27;);insert into books(book_name,book_author,book_price,book_stock,book_desc)values(&#x27;Java王者之路&#x27;,&#x27;威哥&#x27;,44.40,9,&#x27;千锋威哥，Java王者领路人&#x27;);-- 创建学生信息表create table students( stu_num char(4) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null);-- 添加学生信息insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1001&#x27;,&#x27;张三&#x27;,&#x27;男&#x27;,20);insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1002&#x27;,&#x27;李四&#x27;,&#x27;女&#x27;,20);insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1003&#x27;,&#x27;王五&#x27;,&#x27;男&#x27;,20); 业务分析 哪个学生借哪本书，借了多少本？ 操作： 保存借书记录 修改图书库存 条件： 判断学生是否存在？ 判断图书是否存在、库存是否充足？ 创建借书记录表 1234567891011-- 借书记录表：create table records( rid int primary key auto_increment, snum char(4) not null, bid int not null, borrow_num int not null, is_return int not null, -- 0表示为归还 1 表示已经归还 borrow_date date not null, constraint FK_RECORDS_STUDENTS foreign key(snum) references students(stu_num), constraint FK_RECORDS_BOOKS foreign key(bid) REFERENCES books(book_id)); 9.8.2 创建存储过程实现借书业务1234567891011121314151617181920212223242526272829303132333435363738394041424344454647-- 实现借书业务：-- 参数1： a 输入参数 学号-- 参数2： b 输入参数 图书编号-- 参数3： m 输入参数 借书的数量-- 参数4： state 输出参数 借书的状态（1 借书成功，2 学号不存在，3 图书不存在， 4 库存不足）create procedure proc_borrow_book(IN a char(4),IN b int, IN m int,OUT state int)begin declare stu_count int default 0; declare book_count int default 0; declare stock int default 0; -- 判断学号是否存在：根据参数 a 到学生信息表查询是否有stu_num=a的记录 select count(stu_num) INTO stu_count from students where stu_num=a; if stu_count&gt;0 then -- 学号存在 -- 判断图书ID是否存在：根据参数b 查询图书记录总数 select count(book_id) INTO book_count from books where book_id=b; if book_count &gt;0 then -- 图书存在 -- 判断图书库存是否充足：查询当前图书库存，然后和参数m进行比较 select book_stock INTO stock from books where book_id=b; if stock &gt;= m then -- 执行借书 -- 操作1：在借书记录表中添加记录 insert into records(snum,bid,borrow_num,is_return,borrow_date) values(a,b,m,0,sysdate()); -- 操作2：修改图书库存 update books set book_stock=stock-m where book_id=b; -- 借书成功 set state=1; else -- 库存不足 set state=4; end if; else -- 图书不存在 set state = 3; end if; else -- 不存在 set state = 2; end if;end;-- 调用存储过程借书set @state=0;call proc_borrow_book(&#x27;1001&#x27;,1,2,@state);select @state from dual; 9.8.3 创建存储过程实现还书业务期待… 9.9 游标 问题：如果我们要创建一个存储 过程，需要返回查询语句查询到的多条数据，该如何实现呢？ 9.1.1 游标的概念游标可以用来依次取出查询结果集中的每一条数据——逐条读取查询结果集中的记录 9.1.2 游标的使用步骤1、声明游标 声明游标语法： 1DECLARE cursor_nanme CURSOR FOR select_statement; 实例 1declare mycursor cursor for select book_name,book_author,book_price from books; 2、打开游标 语法 1open mycursor; 3、使用游标 使用游标：提取游标当前指向的记录（提取之后，游标自动下移） 1FETCH mycursor INTO bname,bauthor,bprice; 4、关闭游标 1CLOSE mycursor; 9.1.3 游标使用案例123456789101112131415161718192021222324252627282930313233-- 游标使用案例create procedure proc_test2(OUT result varchar(200))begin declare bname varchar(20); declare bauthor varchar(20); declare bprice decimal(10,2); declare num int; declare i int; declare str varchar(50); -- 此查询语句执行之后返回的是一个结果集（多条记录），使用游标可以来遍历查询结果集 declare mycursor cursor for select book_name,book_author,book_price from books; select count(1) INTO num from books; -- 打开游标 open mycursor; -- 使用游标要结合循环语句 set i=0; while i&lt;num do -- 使用游标：提取游标当前指向的记录（提取之后，游标自动下移） FETCH mycursor INTO bname,bauthor,bprice; set i=i+1; -- set str=concat_ws(&#x27;~&#x27;,bname,bauthor,bprice); select concat_ws(&#x27;~&#x27;,bname,bauthor,bprice) INTO str; set result = concat_ws(&#x27;,&#x27;,result,str); end while; -- 关闭游标 close mycursor;end;-- 案例测试set @r = &#x27;&#x27;;call proc_test2(@r);select @r from dual; 十、触发器10.1 触发器的介绍触发器，就是一种特殊的存储过程。触发器和存储过程一样是一个能够完成特定功能、存储在数据库服务器上的SQL片段，但是触发器无需调用，当对数据表中的数据执行DML操作时自动触发这个SQL片段的执行，无需手动调用。 在MySQL,只有执行insert\\delete\\update操作才能触发触发器的执行。 10.2 触发器的使用10.2.1 案例说明1234567891011121314-- 学生信息表create table students( stu_num char(4) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null);-- 学生信息操作日志表create table stulogs( id int primary key auto_increment, time TIMESTAMP, log_text varchar(200)); 1234-- 当向students表中添加学生信息时，同时要在 stulogs表中添加一条操作日志insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1004&#x27;,&#x27;夏利&#x27;,&#x27;女&#x27;,20);-- 手动进行记录日志insert into stulogs(time,log_text) values(now(),&#x27;添加1004学生信息&#x27;); 案例：当向学生信息表添加、删除、修改学生信息时，使用触发器自定进行日志记录 10.2.2 创建触发器语法 123456create trigger tri_name&lt;before|after&gt; -- 定义触发时机&lt;insert|delete|update&gt; -- 定义DML类型ON &lt;table_name&gt;for each row -- 声明为行级触发器（只要操作一条记录就触发触发器执行一次）sql_statement -- 触发器操作 12345-- 创建触发器：当学生信息表发生添加操作时，则向日志信息表中记录一条日志create trigger tri_test1after insert on studentsfor each rowinsert into stulogs(time,log_text) values(now(), concat(&#x27;添加&#x27;,NEW.stu_num,&#x27;学生信息&#x27;)); 10.2.3 查看触发器1show triggers; 10.2.3 测试触发器 我们创建的触发器是在students表发生insert操作时触发，我们只需执行学生信息的添加操作 123456-- 测试1：添加一个学生信息，触发器执行了一次insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1005&#x27;,&#x27;小明&#x27;,&#x27;男&#x27;,20);-- 测试2：一条SQL指令添加了2条学生信息，触发器就执行了2次insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1006&#x27;,&#x27;小刚&#x27;,&#x27;男&#x27;,20),(&#x27;1007&#x27;,&#x27;李磊&#x27;,&#x27;男&#x27;,20); 10.2.4 删除触发器1drop trigger tri_test1; 10.3 NEW与OLD 触发器用于监听对数据表中数据的insert、delete、update操作，在触发器中通常处理一些DML的关联操作；我们可以使用NEW和OLD关键字在触发器中获取触发这个触发器的DML操作的数据 NEW : 在触发器中用于获取insert操作添加的数据、update操作修改后的记录 OLD：在触发器中用于获取delete操作删除前的数据、update操作修改前的数据 10.3.1 NEW insert操作中：NEW表示添加的新记录 1234create trigger tri_test1after insert on studentsfor each rowinsert into stulogs(time,log_text) values(now(), concat(&#x27;添加&#x27;,NEW.stu_num,&#x27;学生信息&#x27;)); update操作中：NEW 表示修改后的数据 1234-- 创建触发器 : 在监听update操作的触发器中，可以使用NEW获取修改后的数据create trigger tri_test2after update on students for each rowinsert into stulogs(time,log_text) values(now(), concat(&#x27;修改学生信息为：&#x27;,NEW.stu_num,NEW.stu_name)); 10.3.2 OLD delete操作中：OLD表示删除的记录 123create trigger tri_test3after delete on students for each rowinsert into stulogs(time,log_text) values(now(), concat(&#x27;删除&#x27;,OLD.stu_num,&#x27;学生信息&#x27;)); update操作中：OLD表示修改前的记录 123create trigger tri_test2after update on students for each rowinsert into stulogs(time,log_text) values(now(), concat(&#x27;将学生姓名从【&#x27;,OLD.stu_name,&#x27;】修改为【&#x27;,NEW.stu_name,&#x27;】&#x27;)); 10.4 触发器使用总结10.4.1 优点 触发器是自动执行的，当对触发器相关的表执行响应的DML操作时立即执行； 触发器可以实现表中的数据的级联操作（关联操作），有利于保证数据的完整性； 触发器可以对DML操作的数据进行更为复杂的合法性校验 10.4.2 缺点 使用触发器实现的业务逻辑如果出现问题将难以定位，后期维护困难； 大量使用触发器容易导致代码结构杂乱，增加了程序的复杂性； 当触发器操作的数据量比较大时，执行效率会大大降低。 10.4.3 使用建议 在互联网项目中，应避免适应触发器； 对于并发量不大的项目可以选择使用存储过程，但是在互联网引用中不提倡使用存储过程（原因：存储过程时将实现业务的逻辑交给数据库处理，一则增减了数据库的负载，二则不利于数据库的迁移） 十一、视图11.1 视图的概念视图，就是由数据库中一张表或者多张表根据特定的条件查询出得数据构造成得虚拟表 11.2 视图的作用 安全性：如果我们直接将数据表授权给用户操作，那么用户可以CRUD数据表中所有数据，加入我们想要对数据表中的部分数据进行保护，可以将公开的数据生成视图，授权用户访问视图；用户通过查询视图可以获取数据表中公开的数据，从而达到将数据表中的部分数据对用户隐藏。 简单性：如果我们需要查询的数据来源于多张数据表，可以使用多表连接查询来实现；我们通过视图将这些连表查询的结果对用户开放，用户则可以直接通过查询视图获取多表数据，操作更便捷。 11.3 创建视图11.3.1 语法123create view &lt;view_name&gt;ASselect_statement 11.3.2 实例 实例1： 1234567-- 创建视图实例1：将学生表中性别为男的学生生成一个视图create view view_test1ASselect * from students where stu_gender=&#x27;男&#x27;;-- 查询视图select * from view_test1; 示例2： 123456789-- 创建视图示例2：查询学生借书的信息（学生名、图书名、借书数量）create view view_test2ASselect s.stu_name,b.book_name,borrow_numfrom books b inner join records r inner join students son b.book_id=r.bid and r.snum=s.stu_num;-- 查询视图select * from view_test2; 11.4 视图数据的特性 视图是虚拟表，查询视图的数据是来源于数据表的。当对视图进行操作时，对原数据表中的数据是否由影响呢？ 查询操作：如果在数据表中添加了新的数据，而且这个数据满足创建视图时查询语句的条件，通过查询视图也可以查询出新增的数据；当删除原表中满足查询条件的数据时，也会从视图中删除。 新增数据：如果在视图中添加数据，数据会被添加到原数据表 删除数据：如果从视图删除数据，数据也将从原表中删除 修改操作：如果通过修改数据，则也将修改原数据表中的数据 视图的使用建议: 对复杂查询简化操作，并且不会对数据进行修改的情况下可以使用视图。 11.5 查询视图结构12-- 查询视图结构desc view_test2; 11.6 修改视图123456789-- 方式1create OR REPLACE view view_test1ASselect * from students where stu_gender=&#x27;女&#x27;;-- 方式2alter view view_test1ASselect * from students where stu_gender=&#x27;男&#x27;; 11.7 删除视图 删除数据表时会同时删除数据表中的数据，删除视图时不会影响原数据表中的数据 12-- 删除视图drop view view_test1; 十二、索引 数据库是用来存储数据，在互联网应用中数据库中存储的数据可能会很多(大数据)，数据表中数据的查询速度会随着数据量的增长逐渐变慢，从而导致响应用户请求的速度变慢——用户体验差，我们如何提高数据库的查询效率呢？ 12.1 索引的介绍索引，就是用来提高数据表中数据的查询效率的。 索引，就是将数据表中某一列&#x2F;某几列的值取出来构造成便于查找的结构进行存储，生成数据表的目录 当我们进行数据查询的时候，则先在目录中进行查找得到对应的数据的地址，然后再到数据表中根据地址快速的获取数据记录，避免全表扫描。 12.2 索引的分类MySQL中的索引，根据创建索引的列的不同，可以分为： 主键索引：在数据表的主键字段创建的索引，这个字段必须被primary key修饰，每张表只能有一个主键 唯一索引：在数据表中的唯一列创建的索引(unique)，此列的所有值只能出现一次，可以为NULL 普通索引：在普通字段上创建的索引，没有唯一性的限制 组合索引：两个及以上字段联合起来创建的索引 说明: 在创建数据表时，将字段声明为主键（添加主键约束），会自动在主键字段创建主键索引； 在创建数据表时，将字段声明为唯一键（添加唯一约束），会自动在唯一字段创建唯一索引； 12.3 创建索引12.3.1 唯一索引123-- 创建唯一索引: 创建唯一索引的列的值不能重复-- create unique index &lt;index_name&gt; on 表名(列名);create unique index index_test1 on tb_testindex(tid); 12.3.2 普通索引123-- 创建普通索引: 不要求创建索引的列的值的唯一性-- create index &lt;index_name&gt; on 表名(列名);create index index_test2 on tb_testindex(name); 12.3.3 组合索引123-- 创建组合索引-- create index &lt;index_name&gt; on 表名(列名1,列名2...);create index index_test3 on tb_testindex(tid,name); 12.3.4 全文索引 MySQL 5.6 版本新增的索引，可以通过此索引进行全文检索操作，因为MySQL全文检索不支持中文，因此这个全文索引不被开发者关注，在应用开发中通常是通过搜索引擎（数据库中间件）实现全文检索 1create fulltext index &lt;index_name&gt; on 表名(字段名); 12.4 索引使用 索引创建完成之后无需调用，当根据创建索引的列进行数据查询的时候，会自动使用索引； 组合索引需要根据创建索引的所有字段进行查询时触发。 在 命令行窗口中可以查看查询语句的查询规划： 1explain select * from tb_testindex where tid=250000\\G; 12.5 查看索引12-- 命令行show create table tb_testindex\\G; 12345-- 查询数据表的索引show indexes from tb_testindex;-- 查询索引show keys from tb_testindex; 12.6 删除索引123-- 删除索引：索引是建立在表的字段上的，不同的表中可能会出现相同名称的索引-- 因此删除索引时需要指定表名drop index index_test3 on tb_testindex; 12.7 索引的使用总结12.7.1 优点 索引大大降低了数据库服务器在执行查询操作时扫描的数据，提高查询效率 索引可以避免服务器排序、将随机IO编程顺序IO 12.7.2 缺点 索引是根据数据表列的创建的，当数据表中数据发生DML操作时，索引页需要更新； 索引文件也会占用磁盘空间； 12.7.3 注意事项 数据表中数据不多时，全表扫面可能更快吗，不要使用索引； 数据量大但是DML操作很频繁时，不建议使用索引； 不要在数据重复读高的列上创建索引（性别）； 创建索引之后，要注意查询SQL语句的编写，避免索引失效。 十三、数据库事务13.1 数据库事务介绍 我们把完成特定的业务的多个数据库DML操作步骤称之为一个事务 事务，就是完成同一个业务的多个DML操作 123456789-- 借书业务-- 操作1：在借书记录表中添加记录insert into records(snum,bid,borrow_num,is_return,borrow_date) values(&#x27;1001&#x27;,1,1,0,sysdate());-- 操作2：修改图书库存update books set book_stock=book_stock-1 where book_id=1;-- 转账业务：张三给李四转账1000-- 操作1：李四的帐号+1000-- 操作2：张三的账户-1000 13.2 数据库事务特性 ACID特性，高频面试题 原子性（Atomicity）：一个事务中的多个DML操作，要么同时执行成功，要么同时执行失败 一致性（Consistency）：事务执行之前和事务执行之后，数据库中的数据是一致的，完整性和一致性不能被破坏 隔离性（Isolation）：数据库允许多个事务同时执行（张三借Java书的同时允许李四借Java书），多个必行的事务之间不能相互影响 持久性（Durability）：事务完整之后，对数据库的操作是永久的 13.3 MySQL事务管理13.3.1 自动提交 在MySQL中，默认DML指令的执行时自动提交的，当我们执行一个DML指令之后，自动同步到数据库中 13.3.2 事务管理 开启事务，就是关闭自动提交 在开始事务第一个操作之前，执行start transaction开启事务 依次执行事务中的每个DML操作 如果在执行的过程中的任何位置出现异常，则执行rollback回滚事务 如果事务中所有的DML操作都执行成功，则在最后执行commit提交事务 1234567891011121314151617-- 借书业务-- 【开启事务】（关闭自动提交---手动提交）start transaction;-- 操作1：在借书记录表中添加记录insert into records(snum,bid,borrow_num,is_return,borrow_date) values(&#x27;1007&#x27;,4,2,0,sysdate());-- select aaa;-- 【事务回滚】（清除连接缓存中的操作,撤销当前事务已经执行的操作）-- rollback;-- 操作2：修改图书库存update books set book_stock=book_stock-2 where book_id=4;-- 【提交事务】（将连接缓存中的操作写入数据文件）commit; 13.4 事务隔离级别 数据库允许多个事务并行，多个事务之间是隔离的、相互独立的；如果事务之间不相互隔离并且操作同一数据时，可能会导致数据的一致性被破坏。 MySQL数据库事务隔离级别： 13.4.1 读未提交（read uncommitted）T2可以读取T1执行但未提交的数据；可能会导致出现脏读 脏读，一个事务读取到了另一个事务中未提交的数据 13.4.2 读已提交（read committed）T2只能读取T1已经提交的数据；避免了脏读，但可能会导致不可重复度（虚读） 不可重复度（虚读）: 在同一个事务中，两次查询操作读取到数据不一致 例如：T2进行第一次查询之后在第二次查询之前，T1修改并提交了数据，T2进行第二次查询时读取到的数据和第一次查询读取到数据不一致。 13.4.3 可重复读（repeatable read）T2执行第一次查询之后，在事务结束之前其他事务不能修改对应的数据；避免了不可重复读(虚读)，但可能会导致幻读 幻读，T2对数据表中的数据进行修改然后查询，在查询之前T1向数据表中新增了一条数据，就导致T2以为修改了所有数据，但却查询出了与修改不一致的数据（T1事务新增的数据） 13.4.4 串行化(serializable)同时只允许一个事务对数据表进行操作；避免了脏读、虚读、幻读问题 隔离级别 脏读 不可重复读(虚读) 幻读 read uncommitted √ √ √ read committed × √ √ repeatable read × × √ serializable × × × 13.4.5 设置数据库事务隔离级别 我们可以通过设置数据库默认的事务隔离级别来控制事务之间的隔离性； 也可以通过客户端与数据库连接设置来设置事务间的隔离性（在应用程序中设置–Spring）； MySQL数据库默认的隔离级别为可重复读 查看MySQL数据库默认的隔离级别 123456-- 在MySQL8.0.3 之前select @@tx_isolation;-- 在MySQL8.0.3 之后select @@transaction_isolation; 设置MySQL默认隔离级别 1set session transaction isolation level &lt;read committed&gt;; 十四、数据库设计 MySQL数据库作为数据存储的介质为应用系统提供数据存储的服务，我们如何设计出合理的数据库、数据表以满足应用系统的数据存储需求呢？ 车库：是用来存放车辆的，车库都需要划分车位，如果不划分车位，车子杂乱无章的存放可能会导致车辆堵塞，同时也可能造成场地的浪费——有限的场地能够停放最多的车辆，同时方便每一辆车的出入 数据库，是用来存放数据的，我们需要设计合理的数据表——能够完成数据的存储，同时能够方便的提取应用系统所需的数据 14.1 数据库设计流程 数据库是为应用系统服务的，数据库存储什么样的数据也是由应用系统来决定的。 当我们进行应用系统开发时，我们首先要明确应用系统的功能需求——软件系统的需求分析 根据应用系统的功能，分析数据实体(实体，就是要存储的数据对象) 电商系统：商品、用户、订单…. 教务管理系统：学生、课程、成绩… 提取实体的数据项（数据项，就是实体的属性） 商品(商品名称、商品图片、商品描述…) 用户(姓名、登录名、登录密码…) 根据数据库设计三范式规范视图的数据项 检查实体的数据项是否满足数据库设计三范式 如果实体的数据项不满足三范式，可能会导致数据的冗余，从而引起数据维护困难、破坏数据一致性等问题 绘制E-R图 （实体关系图，直观的展示实体与实体之间的关系） 数据库建模 三线图进行数据表设计 PowerDesigner PDMan 建库建表 编写SQL指令创建数据库、数据表 添加测试数据，SQL测试 14.2 数据库设计案例 学校图书馆图书管理系统（借书） 14.2.1 数据实体 学生 类别 图书 借书记录 管理员 14.2.2 提取数据项 学生（学号、姓名、性别、年龄、院系编号） 院系（院系编号、院系名称、院系说明…） 类别（类别ID，类别名称，类别描述） 图书（图书ID，图书名称，图书作者，图书封面，图书价格，图书库存…） 借书记录（记录ID，学号，图书编号，数量，是否归还，借书日期，还书日期） 管理员（管理员ID，登录名，登录密码，员工编号） 员工（员工编号，员工姓名，手机，qq，邮箱） 14.2.3 数据库设计三范式第一范式：要求数据表中的字段（列）不可再分 以下表不满足第一范式（在数据库中创建不出不满足第一范式的表） 将细分的列作为单独的一列： 第二范式：不存在非关键字段对关键字段的部分依赖 以下表不满足第二范式 将每个关键字段列出来\\关键字段的组合也列出来，依次检查每个非关键字段 第三范式：不存在非关键字段之间的传递依赖 以下数据表不满足第三范式 将关键字段和被依赖的非关键字段分别作为主键，依次检查所有的非关键字段的依赖关系 14.2.4 数据库建模（E-R图） E-R (Entity-Relationship) 实体关系图，用于直观的体现实体与实体之间的关联关系（一对一、一对多、多对一、多对多） E-R图基本图例 E-R图示例 三线图 统一数据实体的表结构 每个实体创建一张数据表 多对多关联：需额外常见一个数据表维护关系，关系表分别创建外键与两张表关联 一对多、多对一关联：在多的一端添加外键与一的一端的主键建立主外键约束 一对一关联：在任意一端创建外键与另一端建立主外键关联，并且将外键设置为unique 14.2.5 数据库建模（PD） E-R图实际上就是数据模建模的一部分： E-R 图 数据表设计 建库建表 PowerDesigner建模工具 导出数据表 PDMan建模工具 下载并安装PowerDesigner建模工具 PowerDesigner使用 概念数据模型（选择workspace–右键new–Conceptual Data Model），相当于E-R 逻辑数据模型（打开概念数据模型–tools–Generate Logical Data Model）,体现了实体的主外键关联 物理数据模型（打开逻辑数据模型–tools–Generate Physical Data Mode—选择数据库类型及版本） 可以对物理数据模型进行微调 可以通过物理数据模型生成建库建表的SQL语句（在物理数据模型的窗口中—-Database工具条—Generate Database–生成SQL文件） 通过数据库的管理工具执行SQL文件就可以完成数据表的创建 面向对象模型（打开概念数据模型&#x2F;逻辑数据模型&#x2F;物理数据模型—tools–Generate Object-Orentited Model） 可以根据语言设置，生成实体类（Java） 如果想要借助于PD建模工具生成Java代码，创建概念的模型时实体名、属性名都要符合Java程序的命名规范。 在企业项目开发，我们通常是不会使用建模工具来生成数据表、实体类的，因为生成的代码规范不合乎我们的代码需求 14.2.6 数据库建模（PDMan） 下载安装PDMan 创建项目——在项目中创建数据表 在项目中生成关系图","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"day10-jQuery","slug":"day10-jQuery","date":"2022-09-16T15:30:55.000Z","updated":"2022-10-01T03:02:44.913Z","comments":true,"path":"2022/09/16/day10-jQuery/","link":"","permalink":"http://example.com/2022/09/16/day10-jQuery/","excerpt":"","text":"一、jQuery简介1.1 web前端的知识回顾 HTML 决定了网页的内容 CSS 决定了标签的样式 JavaScript 决定了网页的功能：对标签属性、样式的操作、DOM节点操作、ajax异步交互 在使用JS完成对应功能时，需要程序员自行完成代码的编写，开发相对还是比较繁琐的 1.2 jQuery什么？ jQuery就是一个JavaScript的框架，简化了JS的语法和操作，定义了HTML属性操作、样式操作、DOM操作等相关函数，实现了对ajax异步请求封装。 jQuery就是一个提供了很多预定义函数的JS文件。 二、jQuery入门使用2.1 下载jQuery函数库官网：https://jquery.com/ 下载：https://jquery.com/download/ 2.2 在网页中引入jQuery文件2.2.1 本地文件引入 先下载jquery.js文件 将jquery.js文件拷贝粘贴到web项目中 在html文件或者jsp文件，通过script标签引入jQuery文件 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 引入jQuery --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2.2.2 CDN引入 CDN 内容分发网络，将jQuery.js文件提前部署到一个服务器，我们可以通过jquery文件在服务器上的访问路径来引入此jquery.js文件： jQuery官方提供的CDN地址： http://code.jquery.com/jquery-3.6.0.js http://code.jquery.com/jquery-3.6.0.min.js 在html、jsp文件中,通过script标签直接引入jquery的cdn地址即可 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 引入jQuery --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://code.jquery.com/jquery-3.6.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2.3 jQuery入门示例 使用示例：点击按钮隐藏图片 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 引入jQuery --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://code.jquery.com/jquery-3.6.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=&quot;img1&quot; src=&quot;imgs/img01.png&quot; height=&quot;200&quot;/&gt;&lt;br/&gt; &lt;button id=&quot;btn&quot;&gt;测试&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; //点击按钮隐藏图片 $(&quot;#btn&quot;).click(function()&#123; $(&quot;#img1&quot;).hide(); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 三、jQuery API https://www.94xh.com/index.html 3.1 核心函数 jQuery()函数，选择器函数， 用于获取HTML文档中的元素 ，简写为 $() jQuery([selector,[context]]) 根据特定的规则从HTML文档中获取元素(特定的规则：选择器语法) 12$(&quot;#btn&quot;); //获取当前文档中id=btn的元素$(&quot;.inputStyle&quot;); //获取当前文档中class=inputStyle的元素 **jQuery(html,[ownerDocument]) **创建一个新的HTML元素 1$(&quot;&lt;textarea&gt;&lt;/textarea&gt;&quot;) jQuery(fn) 表示当网页文档加载完毕执行fn, 等价于 jQuery(document).ready(fn). 123456$(function()&#123; //给id=btn的按钮绑定点击事件 $(&quot;#btn&quot;).click(function()&#123; alert(111); &#125;);&#125;); $(selector).事件(fn): 当选择器选择的元素发生对应的事件就执行fn 12345//1.当前文档加载完毕执行fn$(document).ready(fn);//2.当id=btn的元素发生点击事件，就执行fn$(&quot;#btn&quot;).click(fn); 3.2 选择器 在 jQuery()函数的参数中传递不同的选择器表达式，就可以获取网页文档中不同的元素 3.2.1 基本选择器 ID选择器： $(“#id”) 12// 获取网页文档中id=btn的元素，相当于 document.getElementById(&quot;id&quot;)$(&quot;#btn&quot;) 标签选择器： $(“tagName”) 12// 获取网页文档中所有的img标签元素，相当于 document.getElementsByTagName(&quot;tagName&quot;);$(&quot;img&quot;) class选择器： $(“.class”) 12//获取网页文档中所有class=inputStyle的元素,相当于 document.getElementsByClassName(&quot;inputStyle&quot;)$(&quot;.inputStyle&quot;) 3.2.2 复合选择器 复合选择器——将多个基本选择器通过特定的符号进行连接，以实现更为精确的选择 $(“selector1 selector2”) 选择所有selector1 匹配的元素里面的匹配selector2的元素 $(“selector1,selector2”) 选择所有匹配selector1和selector2的元素（并集） $(“selector1 &gt; selector2”) 选择匹配selector1元素的子标签中匹配selector2的元素 $(“selector1 + selector2”) 匹配所有紧接在 selector1 元素后的 selector2元素 $(“selector1 ~ selector2”) 匹配所有在 selector1 元素后的 selector2元素 3.2.3 选择器筛选 在选择器匹配的元素中根据特定的筛选条件（索引、属性）更灵活的选择要操作的元素 选择器筛选语法 说明 $(“selector:first“) 匹配selector选择的元素集合中的第一个 $(“selector:last“) 匹配selector选择的元素集合中的最后一个 $(“selector:odd“) 匹配selector选择的元素集合中索引为奇数的元素(1,3,5,7,…) $(“selector:even“) 匹配selector选择的元素集合中索引为偶数的元素(0,2,4,6,…) $(“selector:eq(index)“) 匹配selector选择的元素集合中索引为index的元素 $(“selector:lt(index)“) 匹配selector选择的元素集合中索引小于index的元素 $(“selector:gt(index)“) 匹配selector选择的元素集合中索引大于index的元素 $(“selector[attrName=attrValue]“) 匹配selector选择的元素集合中attrName属性值为attrValue的元素 $(“selector[attrName!=attrValue]“) 3.3 筛选函数 jQuery中提供了一些函数，对选择器匹配的元素集合进行筛选 筛选函数 说明 $(“selector”).first() 从选择器匹配的元素集合中选择第一个元素 $(“selector”).last() 从选择器匹配的元素集合中选择最后一个元素 $(“selector”).eq(index) 匹配selector选择的元素集合中索引为index的元素 $(“input”).each(function(){ var r &#x3D; $(this).hasClass(&quot;inputStyle1&quot;); console.log(r);}); 判断某个元素是否有class&#x3D;’inputStyle1’,返回boolean $(“selector1”).filter(&quot;selector2&quot;) 从selector1匹配的元素集合中选择匹配selector2的元素 $(“selector”).is(tag) 判断选择器选择的元素是否为指定的标签 $(“selector1”).find(selector2) 从selector1匹配的元素集合中的元素里面，选择匹配selector2的元素 3.4 属性操作函数 jQuery提供了一组函数用于对HTML标签进行属性操作 attr(): 获取&#x2F;设置元素属性 1234567//1.获取元素属性值var v1 = $(&quot;img&quot;).attr(&quot;src&quot;);var v2 = $(&quot;img&quot;).attr(&quot;width&quot;);//2.设置元素属性$(&quot;img&quot;).attr(&quot;src&quot;,&quot;imgs/img02.png&quot;);$(&quot;img&quot;).attr(&quot;width&quot;,200); val()：获取&#x2F;设置元素的value属性值 12345//1.获取元素value属性值var v3 = $(&quot;#userName&quot;).val();//2.设置元素的value属性值$(&quot;#userName&quot;).val(&quot;这是设置的值&quot;); removeAttr(&#39;属性名&#39;)：移除元素属性 12//removeAttr() 移除元素属性$(&quot;img&quot;).removeAttr(&quot;width&quot;); prop(&#123;&#125;):同时设置元素的多个属性 1$(&quot;#img2&quot;).prop(&#123;width:200,src:&quot;imgs/img03.png&quot;,alt:&quot;看不到吗？&quot;&#125;); addClass(styleName)、removeClass(styleName)、toggleClass(styleName) 操作标签class属性值 12345678//addClass() 为元素class属性添加一个样式名$(&quot;#div1&quot;).addClass(&quot;style1&quot;);//removeClass() 删除元素class属性中指定的样式名$(&quot;#div1&quot;).removeClass(&quot;style2&quot;);//toggleClass 从元素的class属性中添加/移除指定的样式名$(&quot;#div1&quot;).toggleClass(&quot;style1&quot;); text()、html() 相当于innerHTML操作 text(“”) : 将参数以文本的形式设置到选择器匹配元素的里面，即使设置的内容是HTML标签，也不会当成标签解析 html(“”) : 将参数以HTML标签的形式设置到匹配的元素里面，参数内容会被浏览器解析为HTML标签，显示对应的标签效果。 12$(&quot;#div2&quot;).html(&quot;&lt;img src=&#x27;imgs/img02.png&#x27; height=&#x27;80&#x27;/&gt;&quot;); //会在div中显示一张图片$(&quot;#div2&quot;).text(&quot;&lt;img src=&#x27;imgs/img02.png&#x27; height=&#x27;80&#x27;/&gt;&quot;); //会将参数直接以文本形式显示出来 3.5 样式操作函数 css() 设置&#x2F;获取元素的样式属性 123456789//1.设置标签的样式$(&quot;#div1&quot;).css(&quot;width&quot;,&quot;200px&quot;);$(&quot;#div1&quot;).css(&quot;height&quot;,&quot;200px&quot;);$(&quot;#div1&quot;).css(&quot;border&quot;,&quot;1px red solid&quot;);//多个样式也可以一起设置$(&quot;#div1&quot;).css(&#123;width:&quot;100px&quot;,height:&quot;100px&quot;,background:&quot;#ff0000&quot;&#125;);//2.获取标签指定的样式var v = $(&quot;#div1&quot;).css(&quot;height&quot;); position() 获取元素的位置信息 123var position = $(&quot;#div1&quot;).position();console.log(position.top);console.log(position.left); 获取尺寸的函数： width() &#x2F; height(); innerWitdh() &#x2F; innerHeight(); outerWidth()&#x2F; outerHeight(); 3.6 文档处理函数 DOM操作 3.6.1 添加子节点 append appendTo 1234567// parent.append(child) : 在父节点中拼接子节点 (子节点会添加到父节点中的最后)// child可以是一个HTML标签字符串，表示新建一个HTML元素拼接到parent// child也可以是通过选择器选择的当前文档中的元素（被选择的元素发生移动）$(&quot;#div1&quot;).append(&quot;&lt;img src=&#x27;imgs/img03.png&#x27; height=&#x27;100&#x27;/&gt;&quot;);// child.appendTo(parent) : 将子节点拼接到父节点里面$(&quot;&lt;img src=&#x27;imgs/img03.png&#x27; height=&#x27;100&#x27;/&gt;&quot;).appendTo($(&quot;#div1&quot;)); 3.6.2 插入节点 before insertBefore 12345// node1.before(node2): 在node1的前面插入node2$(&quot;#img2&quot;).before(&quot;&lt;img src=&#x27;imgs/img03.png&#x27; height=&#x27;100&#x27;/&gt;&quot;);// node2.insertBefore(node1): 将node2插入到node1之前$(&quot;&lt;img src=&#x27;imgs/img03.png&#x27; height=&#x27;100&#x27;/&gt;&quot;).insertBefore($(&quot;#img2&quot;)); after insertAfter 12345// node1.after(node2) : 在node1的后面插入node2//$(&quot;#img1&quot;).after(&quot;&lt;img src=&#x27;imgs/img03.png&#x27; height=&#x27;100&#x27;/&gt;&quot;);node2.insertAfter(node1): 将node2插入到node1的后面$(&quot;&lt;img src=&#x27;imgs/img03.png&#x27; height=&#x27;100&#x27;/&gt;&quot;).insertAfter($(&quot;#img1&quot;)); 3.6.3 替换节点 replaceWith 12// node1.replaceWith(node2) : 使用node2替换node1$(&quot;#img2&quot;).replaceWith(&quot;&lt;img src=&#x27;imgs/img03.png&#x27; height=&#x27;100&#x27;/&gt;&quot;); 3.6.4 删除节点 empty 123//parent.empty():清楚当前标签中所有的子标签$(&quot;#div1&quot;).empty();$(&quot;body&quot;).empty(); remove 12// node.remove() :删除当前节点$(&quot;#img1&quot;).remove(); 3.6.5 节点包裹 wrap unwrap 12345//node1.wrap(node2) : 使用node2将node1包裹起来$(&quot;#img3&quot;).wrap(&quot;&lt;div style=&#x27;border:2px pink solid&#x27;&gt;&lt;/div&gt;&quot;)//node.unwrap() : 删除当前标签的父标签$(&quot;#img4&quot;).unwrap(); 3.7 事件函数 用于为页面中的元素绑定事件 元素事件绑定语法： 123456$(&quot;selector&quot;).事件函数(fn);//例如: 当id=btn的元素发生点击事件时，就执行对应的fn$(&quot;#btn&quot;).click(function()&#123; &#125;); 3.7.1 文档加载事件 ready() 文档加载完毕时触发 123$(document).ready(function()&#123; //alert(1);&#125;); 3.7.2 焦点事件 blur() 元素失去焦点时触发 123$(&quot;#userName&quot;).blur(function()&#123; console.log(&quot;---输入框失去焦点&quot;);&#125;); focus() 元素获得焦点时触发 123$(&quot;#userName&quot;).focus(function()&#123; console.log(&quot;---输入框获得焦点&quot;);&#125;); 3.7.3 鼠标事件 mousedown() 鼠标左键按下 mouseup() 鼠标左键松开 mouseenter() 鼠标指针穿过 mouseleave() 鼠标离开 （与 mouseout 事件不同，只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。如果鼠标指针离开任何子元素，同样会触发 mouseout 事件) mouseout() 鼠标离开 mouseover() 鼠标指针移到元素上 mousemove() 鼠标指针在元素上移动 3.7.4 键盘事件 keydown() 按键按下 keyup() 按键松开 3.7.5 点击事件 click() 鼠标单击事件 123$(&quot;#btn&quot;).click(function()&#123; alert(666);&#125;); dbclick() 鼠标双击事件 3.7.6 内容改变 change() 输入框或下拉菜单等内容被改变 1234567891011&lt;select id=&quot;city&quot;&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;武汉&quot;&gt;武汉&lt;/option&gt;&lt;/select&gt;&lt;script type=&quot;text/javascript&quot;&gt; //输入框 和 下拉菜单 等内容可被改变的元素 $(&quot;#city&quot;).change(function()&#123; console.log(&quot;内容被改变了&quot;); &#125;);&lt;/script&gt; 3.7.7 关闭&#x2F;打开事件 off(“事件名称”) 关闭元素的事件 on(“事件名称”,fn) 重新打开&#x2F;绑定元素的事件 123456789101112131415161718192021222324252627&lt;button id=&quot;btn2&quot;&gt;关闭事件&lt;/button&gt;&lt;button id=&quot;btn3&quot;&gt;打开事件&lt;/button&gt;&lt;select id=&quot;city&quot;&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;武汉&quot;&gt;武汉&lt;/option&gt;&lt;/select&gt; &lt;script type=&quot;text/javascript&quot;&gt; //输入框 和 下拉菜单 等内容可被改变的元素 $(&quot;#city&quot;).change(function()&#123; console.log(&quot;内容被改变了&quot;); &#125;); //关闭事件 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;#city&quot;).off(&quot;change&quot;); &#125;); //重新打开事件 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;#city&quot;).on(&quot;change&quot;,function()&#123; console.log(&quot;重新被打开的change事件&quot;); &#125;); &#125;);&lt;/script&gt; 3.7.8 获取事件对象 在事件函数的参数fn添加一个参数，可以获取当前事件的event对象 12345$(&quot;#city&quot;).change(function(event)&#123; //event表示事件对象 console.log(event); //$(this)表示发生事件的元素&#125;); 3.8 效果函数 元素的隐藏与显示 动画 3.8.1 隐藏与显示 以下显示与隐藏的函数都可以设置一个时间参数，用于设置显示隐藏的速度 时间参数可以是slow \\normal\\fast 单词 也可以是具体的数值，单位ms 1. show&#x2F;hide&#x2F;toggle 瞬间显示与隐藏 123456789101112131415161718192021222324&lt;img src=&quot;imgs/img01.png&quot; height=&quot;200&quot; /&gt;&lt;img src=&quot;imgs/img02.png&quot; height=&quot;200&quot; /&gt;&lt;img src=&quot;imgs/img03.png&quot; height=&quot;200&quot; /&gt;&lt;hr&gt;&lt;button id=&quot;btn1&quot;&gt;测试hide()&lt;/button&gt;&lt;button id=&quot;btn2&quot;&gt;测试show()&lt;/button&gt;&lt;button id=&quot;btn3&quot;&gt;测试toggle()&lt;/button&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; // hide() 隐藏 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;img&quot;).hide(); &#125;); // show() 显示 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;img&quot;).show(); &#125;); // toggle() 如果原来显示就执行隐藏，如果原来隐藏就执行显示 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;img&quot;).toggle(); &#125;);&lt;/script&gt; 2.slideDown&#x2F;slideUp&#x2F;slideToggle 放大缩小的显示与隐藏 12345678910111213141516171819&lt;button id=&quot;btn4&quot;&gt;测试slideUp()&lt;/button&gt;&lt;button id=&quot;btn5&quot;&gt;测试slideDown()&lt;/button&gt;&lt;button id=&quot;btn6&quot;&gt;测试slideToggle()&lt;/button&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; // slideUp() 缩起来 $(&quot;#btn4&quot;).click(function()&#123; $(&quot;img&quot;).slideUp(); &#125;); // slideDown() 展开 $(&quot;#btn5&quot;).click(function()&#123; $(&quot;img&quot;).slideDown(); &#125;); // slideToggle() 如果原来显示就执行隐藏，如果原来隐藏就执行显示 $(&quot;#btn6&quot;).click(function()&#123; $(&quot;img&quot;).slideToggle(); &#125;);&lt;/script&gt; 3.fadeOut&#x2F;fadeIn&#x2F;fadeToggle&#x2F;fadeTo 淡入淡出的显示与隐藏 1234567891011121314151617181920212223242526&lt;button id=&quot;btn7&quot;&gt;测试fadeOut()&lt;/button&gt;&lt;button id=&quot;btn8&quot;&gt;测试fadeIn()&lt;/button&gt;&lt;button id=&quot;btn9&quot;&gt;测试fadeToggle()&lt;/button&gt;&lt;button id=&quot;btn10&quot;&gt;测试fadeTo()&lt;/button&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; //fadeOut 淡出 $(&quot;#btn7&quot;).click(function()&#123; $(&quot;img&quot;).fadeOut(); &#125;); //fadeIn 淡入 $(&quot;#btn8&quot;).click(function()&#123; $(&quot;img&quot;).fadeIn(); &#125;); //fadeToggle $(&quot;#btn9&quot;).click(function()&#123; $(&quot;img&quot;).fadeToggle(); &#125;); //fadeTo 将元素的透明度改变到指定的值 // 参数1：速度 // 参数2：透明度 $(&quot;#btn10&quot;).click(function()&#123; $(&quot;img&quot;).fadeTo(3000,0.5); &#125;); &lt;/script&gt; 3.8.2 动画播放与停止 animate stop 12345678910111213141516171819&lt;img src=&quot;imgs/img01.png&quot; id=&quot;img4&quot; style=&quot;width: 200px; height: 200px; border-radius: 50%&quot; /&gt;&lt;button id=&quot;btn11&quot;&gt;测试动画&lt;/button&gt;&lt;button id=&quot;btn12&quot;&gt;停止动画&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; //params:一组包含作为动画属性和终值的样式属性和及其值的集合 //speed:三种预定速度之一的字符串(&quot;slow&quot;,&quot;normal&quot;, or &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000) //easing:要使用的擦除效果的名称(需要插件支持).默认jQuery提供&quot;linear&quot; 和 &quot;swing&quot;. //fn:在动画完成时执行的函数，每个元素执行一次。 $(&quot;#btn11&quot;).click(function()&#123; $(&quot;#img4&quot;).animate(&#123;width:&quot;300px&quot;,height:&quot;300px&quot;&#125;,5000); $(&quot;#img4&quot;).animate(&#123;width:&quot;100px&quot;,height:&quot;100px&quot;&#125;,5000); &#125;); $(&quot;#btn12&quot;).click(function()&#123; //在动画完成之前执行stop,，就让动画停止下来，保持当前状态 $(&quot;#img4&quot;).stop(); &#125;);&lt;/script&gt; 3.9 AJAX3.9.1 ajax()函数1234567891011121314151617181920$.ajax(&#123; url:&quot;请求url?param1=v1&quot;, //url ajax请求的目标服务器地址 type:&quot;get|post&quot;, //type 指定请求方式（get|post） headers:&#123; //headers 设置请求头参数 key1:&quot;value1&quot;, key2:&quot;value2&quot; &#125;, data:&#123; //data 传递的参数 userName:&quot;zhangsan&quot;, userPwd:&quot;123456&quot; &#125;, contentType:&quot;application/json&quot;, //contentType 请求信息的转码方式 processData:false, //processData 设置数据是否压缩传输（文件上传设置为false） success:function(res)&#123; //success ajax请求成功之后执行的回调函数，参数res就是服务器返回的数据 &#125;, error:function(e)&#123; //error ajax请求出现错误执行的回调函数，参数e表示异常信息对象 &#125;&#125;); 3.9.2 jQuery的异步交互实例 验证用户是否可用 (将jquery.js文件拷贝到java web工程) 1.regist.jsp1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;用户注册&lt;/h3&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;p&gt; 帐号：&lt;input type=&quot;text&quot; id=&quot;userName&quot;/&gt;&lt;label id=&quot;tipsLabel&quot;&gt;&lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;检测&quot; id=&quot;checkBtn&quot;/&gt; &lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot;/&gt;&lt;/p&gt; &lt;p&gt;确认密码：&lt;input type=&quot;password&quot;/&gt;&lt;/p&gt; &lt;p&gt;姓名：&lt;input type=&quot;text&quot;/&gt;&lt;/p&gt; &lt;p&gt;电话：&lt;input type=&quot;text&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交注册&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;#checkBtn&quot;).click(function()&#123; //发送ajax请求，验证用户名是否可用 var name = $(&quot;#userName&quot;).val(); $.ajax(&#123; url:&quot;CheckUserNameServlet?userName=&quot;+name, //url传递用户名 type:&quot;get&quot;, success:function(res)&#123; if(res.code == 1000)&#123; $(&quot;#tipsLabel&quot;).replaceWith(&quot;&lt;label id=&#x27;tipsLabel&#x27; style=&#x27;color:green&#x27;&gt;用户名可用！&lt;/label&gt;&quot;); &#125;else&#123;$(&quot;#tipsLabel&quot;).replaceWith(&quot;&lt;label id=&#x27;tipsLabel&#x27; style=&#x27;color:red&#x27;&gt;用户名不可用！&lt;/label&gt;&quot;); &#125; &#125; &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.CheckUserNameServlet1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Description 验证用户名是否可用 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/CheckUserNameServlet&quot;)public class CheckUserNameServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收用户名 String name = request.getParameter(&quot;userName&quot;); //2.判断是否可用 boolean b = !name.startsWith(&quot;admin&quot;); //3.响应ajax请求 response.setContentType(&quot;application/json;charset=utf-8&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); String jsonStr = b ? &quot;&#123;\\&quot;code\\&quot;:1000,\\&quot;msg\\&quot;:\\&quot;success\\&quot;&#125;&quot;:&quot;&#123;\\&quot;code\\&quot;:1001,\\&quot;msg\\&quot;:\\&quot;fail\\&quot;&#125;&quot;; // &#123;&quot;code&quot;:1000,&quot;msg&quot;:&quot;success&quot;&#125; &#123;&quot;code&quot;:1001,&quot;msg&quot;:&quot;fail&quot;&#125; PrintWriter out = response.getWriter(); out.println(jsonStr); out.flush(); out.close(); &#125;&#125; 3.9.2 get(url,params,fn,type)发送get方式的异步请求 1234567891011// 参数1：请求的url// 参数2：传递的参数// 参数3：回调函数// 参数4：服务器返回的数据的格式 （json,html,text,xml）$.get(&quot;CheckUserNameServlet&quot;,&#123;userName:name&#125;,function(res)&#123; if(res.code == 1000)&#123; $(&quot;#tipsLabel&quot;).replaceWith(&quot;&lt;label id=&#x27;tipsLabel&#x27;&gt;用户名可用！&lt;/label&gt;&quot;); &#125;else&#123; $(&quot;#tipsLabel&quot;).replaceWith(&quot;&lt;label id=&#x27;tipsLabel&#x27;&gt;用户名不可用！&lt;/label&gt;&quot;); &#125;&#125;,&quot;json&quot;); 3.9.3 post(url,params,fn,type)发送post方式的异步请求 1234567891011// 参数1：请求的url// 参数2：传递的参数// 参数3：回调函数// 参数4：服务器返回的数据的格式 （json,html,text,xml）$.post(&quot;CheckUserNameServlet&quot;,&#123;userName:name&#125;,function(res)&#123; if(res.code == 1000)&#123; $(&quot;#tipsLabel&quot;).replaceWith(&quot;&lt;label id=&#x27;tipsLabel&#x27;&gt;用户名可用！&lt;/label&gt;&quot;); &#125;else&#123; $(&quot;#tipsLabel&quot;).replaceWith(&quot;&lt;label id=&#x27;tipsLabel&#x27; &gt;用户名不可用！&lt;/label&gt;&quot;); &#125;&#125;,&quot;json&quot;);","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"}]},{"title":"day09-AJAX","slug":"day09-AJAX","date":"2022-09-16T15:30:37.000Z","updated":"2022-09-29T05:48:14.899Z","comments":true,"path":"2022/09/16/day09-AJAX/","link":"","permalink":"http://example.com/2022/09/16/day09-AJAX/","excerpt":"","text":"AJAX异步交互技术 一、AJAX简介1.1 概念 AJAX “Asynchronous JavaScript And XML” 异步JS与XML，指的是在网页使用JavaScript脚本实现前端与服务器的异步交互技术。 在不刷新前端网页的前提下实现和服务器的数据交互 ajax不是一种编程语言，而是使用JavaScript代码实现前端和后端异步数据交互的技术。 1.2 同步与异步 同步请求 异步请求 1.3 异步交互的使用场景 异步交互技术: 适用于网页中显示大量的数据，同时我们只想对一小部分数据进行更新(大部分数据是不更新)的场景 首页登录（系统首页有大量的信息显示，用户需要登录可以使用异步交互完成，避免首页刷新导致重新加载页面中的所有数据） 表单填写中：省市区联动 注册功能中：检测用户名是否可用 二、AJAX实现2.1 ajax异步交互的实现流程 2.2 ajax的代码实现2.2.1 ajax实现案例准备 创建java web工程 创建注册页面 regist.jsp 12345678910111213141516171819&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;用户注册&lt;/h3&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;p&gt;帐号：&lt;input type=&quot;text&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;检测&quot;/&gt; &lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot;/&gt;&lt;/p&gt; &lt;p&gt;确认密码：&lt;input type=&quot;password&quot;/&gt;&lt;/p&gt; &lt;p&gt;姓名：&lt;input type=&quot;text&quot;/&gt;&lt;/p&gt; &lt;p&gt;电话：&lt;input type=&quot;text&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交注册&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 创建检测用户名的Servlet类 123456789101112131415161718192021222324252627282930313233343536package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Description 检测注册页面输入的用户名是否可用 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/CheckUserNameServlet&quot;)public class CheckUserNameServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收用户名 String userName = request.getParameter(&quot;userName&quot;); //2.检查用户名是否存在（查数据库） // 测试规则：只要用户名不是以admin开头就都可以使用 boolean r = !userName.startsWith(&quot;admin&quot;); //3.响应 &#125;&#125; 2.2.2 创建ajax请求对象1. 判断浏览器 window.XMLHttpRequest 2. 创建AJAX对象 IE7+、FF、O、Safari、Chrome 1var ajaxReq = new XMLHttpRuquest(); IE5\\IE6 1var ajaxReq = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 2.2.3 封装ajax请求数据 open(method,url,asyn) method表示异步请求的请求方式 （GET|POST） url 异步请求的目标路径 asyn 是否异步（true异步，false同步） 封装参数： get请求，通过url传递参数 1ajaxReq.open(&quot;GET&quot;,&quot;url?key=value&amp;key2=value2&quot;,true); post请求，可以通过url传参，也可以通过请求正文传参 1ajaxReq.open(&quot;POST&quot;,&quot;url?key=value&amp;key2=value2&quot;,true); 1234//在封装请求数据时不设置参数ajaxReq.open(&quot;POST&quot;,&quot;url&quot;,true);//在发送请求时，使用请求正文传递参数ajaxReq.send(&quot;key1=value1&amp;key2=value2&quot;) 2.2.4 指定ajax回调函数 ajaxReq请求对象是有状态的，可以通过ajaxReq.readyState获取状态值 ajaxReq请求对象的不同状态值表示异步交互的不同阶段 ajaxReq.readyState &#x3D;&#x3D; 0 表示ajax请求对象完成创建但并未初始化 ajaxReq.readyState &#x3D;&#x3D; 1 表示ajax请求对象完成初始化但未发送请求 ajaxReq.readyState &#x3D;&#x3D; 2 表示ajax请求已经发送并到达服务器 ajaxReq.readyState &#x3D;&#x3D; 3 表示服务器正在处理ajax请求（通信….） ajaxReq.readyState &#x3D;&#x3D; 4 表示服务器正处理完成，ajax请求对象已经成功获取响应结果 指定回调函数： 123456789//只要ajax请求状态发送变化，就会触发这个回调函数的执行ajaxReq.onreadystatechange = callback;//回调函数：处理结果function callback()&#123; if(ajaxReq.readyState == 4)&#123; //获取结果 &#125;&#125; 2.2.5 发送ajax请求 通过ajax请求对象调用send(body) 如果请求方式为GET 1ajaxReq.send(null); 如果请求方式为POST 12ajaxReq.send(null);ajaxReq.send(&quot;key1=value1&amp;key2=value2&quot;) 2.2.6 Servlet类响应ajax请求123456//3.通过response的输出流、响应ajax请求response.setCharacterEncoding(&quot;utf-8&quot;);PrintWriter out = response.getWriter();out.println(str);out.flush();out.close(); 2.2.7 在回调函数中获取结果1234567891011121314function callback()&#123; //获取服务器响应结果的两个条件： //1.异步请求完成 ajaxReq.readyState == 4 //2.http状态为200 ajaxReq.status == 200 if(ajaxReq.readyState == 4 &amp;&amp; ajaxReq.status == 200)&#123; //获取结果 // 如果服务器响应的是文本数据（字符串），使用responseText属性接收 var result = ajaxReq.responseText; // 如果服务器响应的是XML文件，使用responseXML属性接收 // var doc = ajaxReq.responseXML; // 将获取的响应结果显示到网页的标签中 document.getElementById(&quot;tipsLabel&quot;).innerHTML = result; &#125;&#125; 2.2.8 验证用户名案例代码1.regist.jsp123456789101112131415161718192021&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/test.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;用户注册&lt;/h3&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;p&gt; 帐号：&lt;input type=&quot;text&quot; id=&quot;userName&quot;/&gt;&lt;label id=&quot;tipsLabel&quot;&gt;&lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;检测&quot; onclick=&quot;checkUserName()&quot;/&gt; &lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot;/&gt;&lt;/p&gt; &lt;p&gt;确认密码：&lt;input type=&quot;password&quot;/&gt;&lt;/p&gt; &lt;p&gt;姓名：&lt;input type=&quot;text&quot;/&gt;&lt;/p&gt; &lt;p&gt;电话：&lt;input type=&quot;text&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交注册&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 2.test.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var ajaxReq;function checkUserName()&#123; //发送ajax请求到CheckUserNameServlet，并将用户名传递 //1、创建ajax请求对象 if(window.XMLHttpRequest)&#123; ajaxReq = new XMLHttpRequest(); &#125;else&#123; ajaxReq = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; console.log(&quot;---------&quot;+ajaxReq.readyState); //2、封装ajax请求数据（初始化） var userName = document.getElementById(&quot;userName&quot;).value; var method = &quot;GET&quot;; var url = &quot;CheckUserNameServlet?userName=&quot;+userName; var async = true; ajaxReq.open(method,url,async); console.log(&quot;---------&quot;+ajaxReq.readyState); //3、指定ajax请求的回调函数 // ajaxReq请求对象是有状态的，可以通过ajaxReq.readyState获取状态值 // ajaxReq请求对象的不同状态值表示异步交互的不同阶段 // ajaxReq.readyState == 0 表示ajax请求对象完成创建但并未初始化 // ajaxReq.readyState == 1 表示ajax请求对象完成初始化但未发送请求 // ajaxReq.readyState == 2 表示ajax请求已经发送并到达服务器 // ajaxReq.readyState == 3 表示服务器正在处理ajax请求（通信....） // ajaxReq.readyState == 4 表示服务器正处理完成，ajax请求对象已经成功获取响应结果 // 只要ajax请求状态发送变化，就会触发这个回调函数的执行 ajaxReq.onreadystatechange = callback; //4、发送请求 ajaxReq.send(null);&#125;//回调函数：处理结果function callback()&#123; //获取服务器响应结果的两个条件： //1.异步请求完成 ajaxReq.readyState == 4 //2.http状态为200 ajaxReq.status == 200 if(ajaxReq.readyState == 4 &amp;&amp; ajaxReq.status == 200)&#123; //获取结果 // 如果服务器响应的是文本数据（字符串），使用responseText属性接收 var result = ajaxReq.responseText; // 如果服务器响应的是XML文件，使用responseXML属性接收 // var doc = ajaxReq.responseXML; // 将获取的响应结果显示到网页的标签中 document.getElementById(&quot;tipsLabel&quot;).innerHTML = result; &#125;&#125; 3.CheckUserNameServlet12345678910111213141516171819202122232425262728293031323334353637383940414243package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Description 检测注册页面输入的用户名是否可用 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/CheckUserNameServlet&quot;)public class CheckUserNameServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收用户名 String userName = request.getParameter(&quot;userName&quot;); //2.检查用户名是否存在（查数据库） // 测试规则：只要用户名不是以admin开头就都可以使用 boolean r = !userName.startsWith(&quot;admin&quot;); String str = r?&quot;&lt;label style=&#x27;color:green&#x27;&gt;用户名可用！&lt;/label&gt;&quot;:&quot;&lt;label style=&#x27;color:red&#x27;&gt;用户名不可用！&lt;/label&gt;&quot;; //3.通过response的输出流、响应ajax请求 response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); out.println(str); out.flush(); out.close(); &#125;&#125; 三、JSONAJAX 就是一种使用JavaScript在前端页面不刷新的情况下和服务器进行数据交互 3.1 JSON介绍 ajax既然是实现前后端之间异步通信的技术，必然要考虑如何将前端的数据提交到服务器，如何将服务器的数据响应到前端并且能够被前端识别。 JSON就是不同系统之间、前后端之间、不同语言之间进行数据交互所遵守的一种数据的格式。 3.2 JSON格式 对象和Map 转换成 &#123;key:value , key:value,...&#125; 数组和集合转换成[e1,e2,e3,...] JSON格式可以嵌套 3.3 JSON格式转换3.3.1 前端JS对象与JSON格式转换 JS对象转换成JSON格式字符串 12345//创建JS对象var obj = &#123;stuNum:&quot;10001&quot;,stuName:&quot;张三&quot;&#125;;obj.stuGender = &quot;男&quot;;//将JS对象转换成json格式字符串var jsonStr = JSON.stringify(obj); 将JSON格式字符串转换成JS对象 1var obj2 = eval(&quot;(&quot;+jsonStr+&quot;)&quot;); 3.3.2 后端Java对象与JSON格式转换 FASTJson GSon JackSon 将json格式字符串转换成Java对象 123//要求：json格式的字符串中的key 要和目标Java对象属性一致Gson gson = new Gson();Student student = gson.fromJson(str, Student.class); 将Java对象转换成JSON格式 12Student stu2 = new Student(&quot;10006&quot;,&quot;Lucy&quot;,&quot;女&quot;);String jsonStr = gson.toJson(stu2); 3.3.3 随堂案例代码1.前端test-json.jsp1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/test.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;测试前端JSON格式转换&lt;/h3&gt; &lt;input type=&quot;button&quot; value=&quot;测试&quot; onclick=&quot;testJson()&quot;/&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testJson()&#123; //1.将JS对象转换成JSON格式字符串 var obj = &#123;stuNum:&quot;10001&quot;,stuName:&quot;张三&quot;&#125;; obj.stuGender = &quot;男&quot;; var jsonStr = JSON.stringify(obj); //发送异步请求，将JSON格式的字符串提交到TestJsonServlet var ajaxReq; if(window.XMLHttpRequest)&#123; ajaxReq = new XMLHttpRequest(); &#125;else&#123; ajaxReq = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; ajaxReq.open(&quot;POST&quot;,&quot;TestJsonServlet&quot;,true); ajaxReq.onreadystatechange = function()&#123; if(ajaxReq.status==200 &amp;&amp; ajaxReq.readyState==4)&#123; var s = ajaxReq.responseText; //将接收的服务器的响应的JSON字符串转换成js对象 var stu = eval(&quot;(&quot;+s+&quot;)&quot;); console.log(stu.stuName); &#125; &#125;; //ajax采用的是POST请求，将json格式字符串通过请求正文提交 ajaxReq.send(jsonStr); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.后端TestJsonServlet 需要在项目中添加gson-2.8.9.jar依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.qfedu.servlets;import com.google.gson.Gson;import com.qfedu.dto.Student;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;/** * @Description 测试JSON转换 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/TestJsonServlet&quot;)public class TestJsonServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收请求正文 request.setCharacterEncoding(&quot;utf-8&quot;); ServletInputStream inputStream = request.getInputStream(); StringBuilder builder = new StringBuilder(); byte[] bs = new byte[1024]; int len = -1; while((len = inputStream.read(bs))!=-1)&#123; String s = new String(bs,0,len,&quot;utf-8&quot;); builder.append(s); &#125; String str = builder.toString(); System.out.println(str); //2.将接收的json字符串，转换成Java对象(Student) Gson gson = new Gson(); Student student = gson.fromJson(str, Student.class); System.out.println(student); //3.java对象转换成JSON格式 Student stu2 = new Student(&quot;10006&quot;,&quot;Lucy&quot;,&quot;女&quot;); String jsonStr = gson.toJson(stu2); //将json格式字符串响应给ajax请求 response.setContentType(&quot;application/json;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); out.println(jsonStr); out.flush(); out.close(); &#125;&#125;","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"}]},{"title":"day08-JSP","slug":"day08-JSP","date":"2022-09-16T15:30:17.000Z","updated":"2022-10-10T02:15:39.193Z","comments":true,"path":"2022/09/16/day08-JSP/","link":"","permalink":"http://example.com/2022/09/16/day08-JSP/","excerpt":"","text":"一、JSP概述1.1 Servlet使用的不足 Servlet是一个动态网页技术，客户端通过请求Servlet类可以相应给客户端一个动态网页，但是Servlet在使用过程中有什么不足之处呢？ 开发方式麻烦：继承HttpServlet父类、重写doGet&#x2F;doPost、Servlet配置 项目更新麻烦：Servlet类中的代码发生改变，需要重新编译、部署、启动Tomcat 网页呈现复杂：需要进行HTML标签拼接，同时要通过输出流逐行打印 协同开发困难：UI负责页面美化，但是页面是由Servlet类提供，如果UI不懂Java、则不能完成Servlet响应的页面的优化 1.2 JSP简介 JSP (Java Server Page) 基于Servlet技术的、运行在服务器之上、支持Java语言的动态网页技术。 背景：JSP简化了Servlet的设计，采用在HTML标签中嵌套代码的形式进行动态网页的呈现，用于高效开发web应用的动态网页。 作用：替换显示页面部分的Servlet（使用*.jsp网页文件替换*PageServlet.java类） 二、JSP入门案例 JSP入门案例流程： 2.1 案例准备2.1.1 创建数据库数据表 创建数据库 db_jsp 创建图书信息表 123456789create table books( book_id char(6) primary key, book_name varchar(50) not null, book_author varchar(20) not null, book_price DECIMAL(10,2), book_img_path varchar(100) not null, book_desc varchar(200), book_type int not null ); 2.1.2 创建web项目JSP必须依赖于服务器运行，因此只能在web应用中使用JSP技术 web项目名称jsp-demo1 2.1.3 完成JDBC准备 导入jar包：mysql驱动、druid.jar、apache commons dbutils 创建com.qfedu.jsp.utils包，在包中创建druid.properties文件配置连接池参数 123456789101112131415# 数据库连接信息driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/db_jsp?characterEncoding=utf8username=rootpassword=@QFedu123# 连接池属性# 连接池的初始化连接数&lt;创建数据库连接池时默认初始化的连接的个数&gt;initialSize=10# 连接池的最大连接数maxActive=50# 最小空闲连接数（当数据库连接使用率很低时，连接池中的连接会被释放一部分）minIdle=5# 超时等待时间(单位：ms)maxWait=30000 在utils包中连接池工具类DruidUtils 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.qfedu.jsp.utils;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.*;import java.io.InputStream;import java.sql.*;import java.util.Properties;/** * @Description 数据库连接池工具类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class DruidUtils &#123; private static DruidDataSource druidDataSource; static&#123; try &#123; InputStream is = DruidUtils.class.getResourceAsStream(&quot;druid.properties&quot;); Properties properties = new Properties(); properties.load(is); druidDataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取数据库连接池数据源对象 * @return */ public static DataSource getDataSource()&#123; return druidDataSource; &#125; /** * 从数据库连接池中获取数据库连接对象 * @return */ public static Connection getConnection()&#123; Connection connection = null; try &#123; connection = druidDataSource.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125;&#125; 2.2 完成案例的数据库操作2.2.1 创建实体类 创建com.qfedu.jsp.dto包 创建实体类 123456789101112131415161718package com.qfedu.jsp.dto;/** * @Description 图书信息实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Book &#123; private String bookId; private String bookName; private String bookAuthor; private double bookPrice; private String bookImgPath; private String bookDesc; private int bookType;&#125; 2.2.2 创建DAO类完成操作 创建com.qfedu.jsp.dao包 创建BookDAO类，完成查询操作 123456789101112131415161718192021222324252627282930package com.qfedu.jsp.dao;import com.qfedu.jsp.dto.Book;import com.qfedu.jsp.utils.DruidUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.sql.SQLException;import java.util.List;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookDAO &#123; public List&lt;Book&gt; listBooks()&#123; List&lt;Book&gt; bookList = null; try &#123; String sql = &quot;select book_id bookId,book_name bookName,book_author bookAuthor,book_price bookPrice,book_img_path bookImgPath,book_desc bookDesc,book_type bookType from books&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); bookList = queryRunner.query(sql, new BeanListHandler&lt;Book&gt;(Book.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return bookList; &#125; &#125; 2.3 JSP呈现动态网页2.3.1 创建BookListServlet 创建BookListServlet类,接收用户请求 调用BookDAO查询图书信息，并将数据转发到 book-list.jsp 1234567891011121314151617181920212223242526package com.qfedu.jsp.servlets;/** * @Description 接收客户端请求场、查询图书信息，将图书信息转发到一个JSP文件进行显示 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/BookListServlet&quot;)public class BookListServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.调用BookDAO查询图书信息 BookDAO bookDAO = new BookDAO(); List&lt;Book&gt; bookList = bookDAO.listBooks(); //2.将数据转发到book-list.jsp进行动态显示 request.setAttribute(&quot;bookList&quot;,bookList); request.getRequestDispatcher(&quot;book-list.jsp&quot;).forward(request,response); &#125;&#125; 2.3.2 创建JSP页面 在项目的web目录下右键 — 新建 — JSP — 输入名称book-list.jsp — OK 在book-list.jsp进行网页界面设计（HTML+CSS+JS） 12345678910111213141516171819202122232425262728293031&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table width=&quot;80%&quot; align=&quot;center&quot; border=&quot;1&quot; cellspacing=&quot;0&quot;&gt; &lt;caption&gt;图书信息列表&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;图书ID&lt;/th&gt; &lt;th&gt;图书名称&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;封面&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;th&gt;类型&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;10001&lt;/td&gt; &lt;td&gt;Java&lt;/td&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;11.11&lt;/td&gt; &lt;td&gt;files/aaa.jpg&lt;/td&gt; &lt;td&gt;这本书真香&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 2.3.3 在JSP页面中显示动态数据 在JSP页面文件中，通过Java代码接收图书信息，并遍历显示在HTML标签中 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;com.qfedu.jsp.dto.Book&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table width=&quot;80%&quot; align=&quot;center&quot; border=&quot;1&quot; cellspacing=&quot;0&quot;&gt; &lt;caption&gt;图书信息列表&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;图书ID&lt;/th&gt; &lt;th&gt;图书名称&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;封面&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;th&gt;类型&lt;/th&gt; &lt;/tr&gt; &lt;%-- 在JSP中可以写Java代码，但是代码必须写在&lt;%%&gt;符号中 --%&gt; &lt;% //1.通过Java代码，接收BookListServlet转发时传递的 图书信息集合的数据 List&lt;Book&gt; bookList = (List&lt;Book&gt;) request.getAttribute(&quot;bookList&quot;); for(int i=0; i&lt; bookList.size() ; i++)&#123; //book是java代码中的变量 Book book = bookList.get(i); %&gt; &lt;tr&gt; &lt;%-- 如果需要将JSP中java代码的变量显示在HTML标签中，则需要使用&lt;%=attr%&gt; --%&gt; &lt;td&gt;&lt;%=book.getBookId() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getBookName() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getBookAuthor() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getBookPrice() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getBookImgPath() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getBookDesc() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getBookType() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% &#125; %&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 三、JSP开发详解3.1 JSP和Servlet JSP和Servlet一样可以接受客户端请求，并响应一个动态网页。 JSP是对Servlet的一种高级封装，一个JSP文件底层就是一个Servlet类。 JSP文件需要依赖服务器运行，当客户端请求一个JSP文件时，JSP文件会在服务器中转换成Servlet来执行。 使用JSP的必要性： ​ 我们将动态网页显示使用JSP完成，在HTML标签中嵌入Java代码的形式开发动态网页更为便捷。 3.2 JSP开发的语法规则3.2.1 JSP文档规范 JSP文件和HTML文档一样是一个视图文件，JSP文件创建在项目的web目录 JSP文件以.jsp后缀名结尾 JSP文档内容结构： 在JSP文件的第一行需要通过 &lt;%@ page %&gt;声明使用java语言 JSP文件的主体内容是一个HTML文档，符合HTML的文档规范 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 3.2.2 Java脚本 JSP页面可以嵌入java代码，java代码就是这个页面的脚本 java代码：在jsp中的java代码必须写在&lt;% %&gt;中，代码可以写在JSP文件的任何位置，而且可以包含多段代码 123&lt;% java代码%&gt; 变量输出 1&lt;img src=&quot;&lt;%=attr %&gt;&quot;/&gt; 声明成员变量和方法： 1234567&lt;%! int i = 5;%&gt;&lt;%! public void method()&#123; System.out.println(&quot;hello&quot;); &#125; %&gt; 3.2.3 JSP注释 HTML文档注释 1&lt;!-- HTML文档注释：这种注释会出现在jsp编译之后的Java代码中 --&gt; JSP注释 1&lt;%-- JSP 注释： 这种注释不会出现在编译后的java代码 --%&gt; 3.3 JSP编译指令编译指令：在JSP文件转换成Java代码之后，编译成.class文件的过程中执行的指令 &lt;%@ page %&gt; : 声明当前JSP页面在web容器中的配置、引用； &lt;%@ include %&gt; : 在当前JSP中引用其他的资源（JSP\\HTML）作为当前JSP的一部分； &lt;%@ taglib %&gt; : 引用第三方标签库、扩展JSP文件中的标签； 3.3.1 &lt;%@ page%&gt; 标签属性 说明 示例 contentType 用于声明当前JSP文档的MIME类型和字符集编码 contentType&#x3D;”text&#x2F;html;charset&#x3D;UTF-8” language 定义JSP中所用的脚本语言类型，默认java language&#x3D;”java” import 声明当前JSP中的Java代码依赖的类 import&#x3D;”java.util.List” pageEncoding 声明当前JSP文档的解码格式 pageEncoding&#x3D;”UTF-8” errorPage 如果当前JSP出现异常则跳转到errorPage指向页面 errorPage&#x3D;”error.jsp” isErrorPage 定义当前页面是否可以作为错误页面 isErrorPage&#x3D;”true” 3.3.2 &lt;%@ include %&gt; 在当前JSP中引用其他的资源（JSP\\HTML）作为当前JSP的一部分，被引入的页面不会单独作为一个JSP编译，而是将引入的页面中的代码插入到当前JSP之后作为一个整体进行编译。 被引入的页面只需要是一个HTML片段即可。 静态引入：将被页面引入到当前JSP之后再进行整体的编译，被引入的页面不会单独编译。 header.jsp 1&lt;div style=&quot;height: 100px; background: deepskyblue&quot; &gt;header&lt;/div&gt; footer.jsp 1&lt;div style=&quot;height: 50px; background: lightgray&quot; &gt;footer&lt;/div&gt; index.jsp 12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot;java.util.Date&quot;%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%@ include file=&quot;header.jsp&quot;%&gt; &lt;div style=&quot;height: 400px; background: orange&quot;&gt;index&lt;/div&gt; &lt;%@ include file=&quot;footer.jsp&quot;%&gt; &lt;/body&gt;&lt;/html&gt; 3.3.3 &lt;%@ taglib %&gt; 引用第三方标签库、扩展JSP文件中的标签 12&lt;!--引入JSTL标签库--&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 3.4 JSP动作指令 在JSP文件中，除了支持标准的HTML标签库和编译指令之外，还支持JSP特有的动作指令（动作标签）。 动作指令：在JSP中以jsp:开头的、在JSP页面运行期间执行的指令。 3.4.1 jsp:include12&lt;%-- 动态引入 --%&gt;&lt;jsp:include page=&quot;test1.jsp&quot;/&gt; 动态引入JSP文件文件：被引入的JSP文件先单独编译执行，将执行的结果引入到当前JSP文件。 因为被引入的JSP页面需要独立的编译执行，因此被引入的页面需要是一个完整的JSP文件。 在动态引入的页面中不能访问主页面中定义的Java变量。 静态引入和动态引入的区别： 静态引入，使用&lt;%@include file=&quot;&quot;%&gt;编译指令将HTML或者JSP页面引入到当前文件，静态引入是先引入再执行，因此被引入的页面可以是一个HTML片段，也可在被引入的页面中访问主页面定义的Java变量； 动态引入，使用&lt;jsp:include page=&quot;&quot;/&gt;动作指令将JSP页面引入到当前文件，动态引入是先独立编译执行被引入的页面，将执行结果引入到当前页面，被引入的页面需要独立执行因此必须是一个完成的JSP，同时在被引入的JSP中不能访问主页面定义的Java变量。 3.4.2 jsp:userBean 在JSP页面中构造Java对象 12&lt;%-- 相当于 Book book = new Book(); --%&gt;&lt;jsp:useBean id=&quot;book&quot; class=&quot;com.qfedu.jsp.dto.Book&quot;&gt;&lt;/jsp:useBean&gt; id属性， 创建的对象的变量名 class属性，类的全限定名 3.4.3 jsp:setProperty 给创建的Java对象属性赋值 123&lt;%-- 相当于 book.setBookId(&quot;100001&quot;) --%&gt;&lt;jsp:setProperty name=&quot;book&quot; property=&quot;bookId&quot; value=&quot;100001&quot;&gt;&lt;/jsp:setProperty&gt;&lt;jsp:setProperty name=&quot;book&quot; property=&quot;bookName&quot; value=&quot;Java&quot;&gt;&lt;/jsp:setProperty&gt; name属性，对象的变量名 property属性，对象的属性名 values属性，属性的值 3.4.4 jsp:getProperty 获取创建的对象的值，并输出到网页 12&lt;%-- 相当于 book.getBookId()，并将获取的值输出到页面 --%&gt;&lt;jsp:getProperty name=&quot;book&quot; property=&quot;bookId&quot;/&gt; name属性，对象的变量名 property属性，对象的属性名 3.4.5 jsp:forward 用于转发客户端请求 1&lt;jsp:forward page=&quot;test2.jsp&quot;&gt;&lt;/jsp:forward&gt; 3.4.6 jsp:param 在JSP页面转发过程中进行参数传递 123456&lt;%-- 从当前JSP转发到另一个JSP --%&gt;&lt;jsp:forward page=&quot;test2.jsp&quot;&gt; &lt;%-- 转发的同时携带参数 --%&gt; &lt;jsp:param name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt; &lt;jsp:param name=&quot;sex&quot; value=&quot;nan&quot;/&gt;&lt;/jsp:forward&gt; 3.5 JSP九大内置对象 一个JSP文件在服务器上是转换成Java文件（Servlet类）编译执行的，我们在JSP文件中嵌入的Java代码都会转换到这个Java文件的方法中（_jspService）,因此这个方法的参数、方法中定义的变量以及当前类继承的父类中定义的变量，我们的代码都可以使用。 在JSP中编写Java代码可以不用创建、直接使用的对象我们称之为JSP内置对象。 对象名 类型 request javax.servlet.http.HttpServletRequest 表示客户端请求对象，用户获取HTTP请求信息 response javax.servlet.http.HttpServletResponse 表示服务器对客户端的响应对象，用于将JSP处理的数据响应给客户端 session javax.servlet.http.HttpSession 表示当前客户端与服务器的会话对象 application javax.servlet.ServletContext 当前web应用在服务器上的全局对象 config javax.servlet.ServletConfig 表示当前Servlet类的配置信息 pageContext javax.servlet.jsp.PageContext 当前JSP的上下文，可以获取当前JSP的任何信息 out javax.servlet.jsp.JspWriter 指向当前JSP文档的输出流 exception java.lang.Throwable 只有在设置了isErrorPage&#x3D;“true”的JSP可使用 page java.lang.Object 当前JSP转换的servlet类的实例，相当于this 3.6 JSP四大域对象 域对象——可以用来存取数据的对象 pageContext request session application 3.6.1 pageContext pageConext对象 只作用于当前JSP文件 3.6.2 request request作用于一次请求 3.6.3 session session对象作用于用户一次连接的多次请求 3.6.4 application application实际上就是servletContext对象，作用于一个web应用的所有用户 3.6.5 使用域对象传值示例 Servlet类 1234567891011121314151617181920212223242526272829package com.qfedu.jsp.servlets;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/TestServlet&quot;)public class TestServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.分别通过 request、session、application传值 request.setAttribute(&quot;key1&quot;,&quot;value1&quot;); HttpSession session = request.getSession(); session.setAttribute(&quot;key2&quot;,&quot;value2&quot;); ServletContext application = getServletContext(); application.setAttribute(&quot;key3&quot;,&quot;value3&quot;); //2.转发到test3.jsp request.getRequestDispatcher(&quot;test3.jsp&quot;).forward(request,response); &#125;&#125; JSP页面 12345678910111213141516171819&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Test3&lt;hr/&gt;&lt;% String s1 = (String) request.getAttribute(&quot;key1&quot;); String s2 = (String) session.getAttribute(&quot;key2&quot;); String s3 = (String) application.getAttribute(&quot;key3&quot;);%&gt;request取出的数据:&lt;%=s1%&gt; &lt;br/&gt;session取出的数据:&lt;%=s2%&gt; &lt;br/&gt;application取出的数据:&lt;%=s3%&gt; &lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 3.7 JSP开发应用 JSP负责项目中的视图呈现 Servlet负责接收、处理用户请求 Servlet类查询的数据转发并传递给JSP页面进行显示 注意：当将进行页面显示的Servlet类转换成jsp文件之后，要修改对应跳转的路径；同时注意修改登录过滤器的放行路径，以及未登录时要跳转到login.jsp（而不是原来的LoginPageServlet） 四、EL表达式 思考问题：JSP相较于Servlet来说，在动态网页的数据渲染方面要便捷很多，但是依然要进行HTML和Java代码的混合编程，代码的可读性和维护性依然有待提高，能不能做HTML和Java代码的完全分离呢？ 4.1 什么是EL? Expression Language 表达式语言，应用于JSP页面，可以更简单、便捷的获取page、request、session、application等作用域的值，进行渲染。 EL表达式就是替代以下代码的作用： pageContext.getAttribute(“key”); request.getAttribute(“key”); session.getAttribute(“key”); application.getAttribute(“key”); EL表达式使用示例： Servlet类: 123456789101112131415161718192021222324/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/TestServlet&quot;)public class TestServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.传递数据 request.setAttribute(&quot;str&quot;,&quot;Hello EL!&quot;); //2.转发到JSP页面 request.getRequestDispatcher(&quot;test.jsp&quot;).forward(request,response); &#125;&#125; JSP文件： 12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%-- 使用Java代码接收数据 --%&gt; &lt;% String s = (String) request.getAttribute(&quot;str&quot;); %&gt; Java脚本获取的数据：&lt;%=s %&gt; &lt;%-- 通过EL获取并显示TestServlet传递的数据 --%&gt; EL表达式获取的数据：$&#123;str&#125; &lt;/body&gt;&lt;/html&gt; 4.2 EL表达式应用4.2.1 实体类1234567891011121314151617181920package com.qfedu.dto;/** * @Description 图书信息实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Book &#123; private String bookId; private String bookName; private String bookAuthor; private double bookPrice; //无参构造器 //全参构造器 //toString //get和set方法&#125; 4.2.2 TestServlet类 在TestServlet类传递各种数据，并转发到test.jsp页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.qfedu.servlets;import com.qfedu.dto.Book;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/TestServlet&quot;)public class TestServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.传递数据 //简单类型 request.setAttribute(&quot;key1&quot;,123); //字符串 request.setAttribute(&quot;key2&quot;,&quot;Hello EL!&quot;); //对象 request.setAttribute(&quot;key3&quot;,new Book(&quot;1001&quot;,&quot;Java&quot;,&quot;亮亮&quot;,20.00)); //数组 String[] arr = &#123;&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;&#125;; request.setAttribute(&quot;key4&quot;,arr); //集合 List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); bookList.add(new Book(&quot;1001&quot;,&quot;Java&quot;,&quot;亮亮&quot;,20.00)); bookList.add(new Book(&quot;1002&quot;,&quot;C++&quot;,&quot;张三&quot;,21.00)); bookList.add(new Book(&quot;1003&quot;,&quot;Python&quot;,&quot;李四&quot;,22.00)); request.setAttribute(&quot;key5&quot;,bookList); //Map Map&lt;String,Book&gt; map = new HashMap&lt;&gt;(); map.put(&quot;a1001&quot;,new Book(&quot;1001&quot;,&quot;Java&quot;,&quot;亮亮&quot;,20.00)); map.put(&quot;a1002&quot;,new Book(&quot;1002&quot;,&quot;C++&quot;,&quot;张三&quot;,21.00)); map.put(&quot;a1003&quot;,new Book(&quot;1003&quot;,&quot;Python&quot;,&quot;李四&quot;,22.00)); request.setAttribute(&quot;key6&quot;,map); //2.转发到JSP页面 request.getRequestDispatcher(&quot;test.jsp&quot;).forward(request,response); &#125;&#125; 4.2.3 test.jsp 在test.jsp页面通过EL表达式获取各种类型数据 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;%-- 1.接收简单类型及字符串 $&#123;key&#125; --%&gt; $&#123;key1&#125;&lt;br/&gt; $&#123;key2&#125;&lt;br/&gt;&lt;%-- 2.接收对象数据 $&#123;key&#125;获取对象的toString方法输出， 我们可以通过 $&#123;key.attrName&#125;获取对象属性值，通过反射调用类中属性的get方法获取属性值 因此传递到JSP页面、使用EL表达式获取属性值的对象必须提供get方法 --%&gt; $&#123;key3&#125;&lt;br/&gt; $&#123;key3.bookId&#125;&lt;br/&gt; $&#123;key3.bookName&#125;&lt;br/&gt; $&#123;key3.bookAuthor&#125;&lt;br/&gt; $&#123;key3.bookPrice&#125;&lt;br/&gt;&lt;%-- 3.接收数组数据 $&#123;key[index]&#125; --%&gt; $&#123;key4[0]&#125;-$&#123;key4[1]&#125;-$&#123;key4[2]&#125;&lt;br/&gt;&lt;%-- 4.接收集合中的数据：$&#123;key[index]&#125; 如何集合中的元素是对象 ，可以进一步使用 $&#123;key[index].attrName&#125; 获取集合中对象的属性--%&gt; $&#123;key5[0].bookName&#125;- $&#123;key5[0].bookAuthor&#125;&lt;br/&gt; $&#123;key5[1].bookName&#125;- $&#123;key5[1].bookAuthor&#125;&lt;br/&gt; $&#123;key5[2].bookName&#125;- $&#123;key5[2].bookAuthor&#125;&lt;br/&gt;&lt;%-- 5.接收Map中的数据: 使用$&#123;key&#125;获取整个map 使用$&#123;key.mapKey&#125; 根据可以获取元素 如果map中的key是以数字开头，可以使用$&#123;key[&#x27;mapKey&#x27;]&#125; 如果map中的value是对象，我们还可以进一步使用 $&#123;key.mapKey.attrName&#125;获取对象属性值--%&gt; $&#123;key6[&#x27;a1001&#x27;]&#125;&lt;br/&gt; $&#123;key6.a1001&#125;&lt;br/&gt; $&#123;key6.a1001.bookName&#125;&lt;br/&gt; &lt;/body&gt;&lt;/html&gt; 4.3 EL访问域对象 如果从Servlet分别使用request、session、application同时向JSP页面传递数据，并且key都相同；那么在JSP页面直接使用${key}获取的是什么数据呢？ 如何能够获取我们想要访问的域对象中的数据呢？ 4.3.1 ${key}获取哪个域对象的数据呢？ 四个域对象的访问从小到大依次是：pageContext–&gt;request–&gt;session–&gt;application 如果没有指定域对象，${key}默认获取最小域对象中的数据 4.3.2 如何使用EL获取指定域对象数据？ 在EL表达式中，分别为四个域对象各自取了一个名字 pageContext对象 —&gt; pageScope request对象—&gt;requestScope session对象—&gt;sessionScope application对象—&gt;applicationScope 在JSP中如果多个域对象都有相同的key，可以通过$&#123;***Scope.key&#125;来获取指定域对象中数据，如果获取不到则返回””，显示到页面为空白 1$&#123;sessionScope.key&#125; 4.4 EL的隐式对象 EL语法中提供的隐藏对象——隐式对象 除了四个域对象pageScope、requestScope、sessionScope、applicationScope之外，EL中还提供了另外七个隐式对象，分别用于获取不同的数据 隐式对象 说明 param 获取Rquest对象的参数，返回String，$&#123;param.key&#125;等价于request.getParameter(&quot;key&quot;) paramValues 获取Rquest对象传递的所有的参数值，返回字符串集合 $&#123;paramValues&#125;等价于request.getParameterValues() header 获取HTTP请求头 $&#123;header.contentPosition&#125; headerValues 获取HTTP请求头中所有的值 initParam 获取上下文初始化参数 pageContext 获取当前页面的pageContext对象： $&#123;pageContext.request.contextPath&#125;当前web项目在服务器的访问路径 cookie 获取cookie中的值，${cookie.username} 4.5 EL的运算符EL表达式不能能够从域对象获取数据，同时可以对取出的数据进行算术运算、关系比较、逻辑运算等运算 4.5.1 算术运算 运算符 描述&#x2F;示例 + $&#123;key1+key2&#125; 表示根据key1获取的值然后加上key2获取的值，显示到网页 - 减法 * 乘法 &#x2F; or div 除法， $&#123;key/4&#125; 等价于 $&#123;key div 4&#125; % or mod 取模 4.5.2 关系比较 运算符 描述&#x2F;示例 == or eq $&#123;key == v&#125; 表示比较根据key获取的值是否等于v，返回结果为true&#x2F;false等价于 $&#123;key eq v&#125; != or ne 不等于 &gt; or gt 大于 &lt; or lt 小于 &gt;= or ge 大于等于 &lt;= or le 小于等于 4.5.3 逻辑运算 运算符 描述&#x2F;示例 &amp;&amp; or and 逻辑与,用于连接两个条件 &#96; ! or not 逻辑非 4.5.4 判空 运算符 描述&#x2F;示例 empty $&#123;empty key&#125; 如果key对应取出的值为空，则返回true 五、JSTL 如果EL表达式在JSP页面中获取的集合中的元素个数不确定，我们该如何将集合中的数据全部显示呢？ 5.1 JSTL简介 JSTL (JSP Standard Tag Library) JSP标准标签库，用于扩展JSP中的标签，能够为JSP页面提供流程控制、类型转换等功能的标签。 作用：在JSP中通常是JSTL+EL的组合来进行数据的提取及渲染。 JSTL标签库提供了多类标签： c ，核心标签库，提供流程控制的标签 fmt，转换标签库，提供了日期、数值类型转换的标签 sql fn x 5.2 JSTL的引入步骤 需要在JSP中引用JSTL标签库之后，才可以使用JSTL提供的标签 下载JSTL标签库的依赖jar https://mvnrepository.com/ 将jar文件引入到当前web项目 在需要使用JSTL标签的JSP文件，通过&lt;%@taglib%&gt;引入JSTL标签库（JSTL包含多种标签，每种标签需要单独引入） 1234&lt;!--引入JSTL的核心标签库--&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;!--引入JSTL的转换标签库--&gt;&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt; 5.3 JSTL核心标签库 c标签，主要用于完成JSP页面中逻辑控制&#x2F;流程控制 分支 循环 5.3.1 c:if &lt;c:if test=&quot;EL表达式条件&quot;&gt; ​ html &lt;/c:if&gt; 1234567&lt;%-- 如果test属性的el表达式返回的为true，则显示c:if标签包含的HTML --%&gt;&lt;c:if test=&quot;$&#123;score &gt;= 60&#125;&quot;&gt; &lt;label style=&quot;color: green&quot;&gt;通过&lt;/label&gt;&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;score &lt; 60&#125;&quot;&gt; &lt;label style=&quot;color: red&quot;&gt;不通过&lt;/label&gt;&lt;/c:if&gt; 5.3.2 c:choose c:choose为多分支语句，可以包含多个c:when和一个c:otherwise ,寻找并执行第一个条件成立的c:when，如果所有c:when的条件都不成立则执行c:otherwise 1234567891011121314151617&lt;c:choose&gt; &lt;c:when test=&quot;$&#123;score&gt;=90&#125;&quot;&gt; &lt;label style=&quot;color: green&quot;&gt;优秀&lt;/label&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;score&gt;=80&#125;&quot;&gt; &lt;label style=&quot;color: green&quot;&gt;良好&lt;/label&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;score&gt;=70&#125;&quot;&gt; &lt;label style=&quot;color: green&quot;&gt;中等&lt;/label&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;score&gt;=60&#125;&quot;&gt; &lt;label style=&quot;color: green&quot;&gt;及格&lt;/label&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;label style=&quot;color: red&quot;&gt;不及格&lt;/label&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; 5.3.3 c:forEach 迭代标签、循环标签 123456789101112131415161718192021222324 &lt;%-- 遍历传递过来的集合中的图书信息，显示在一个表格中 --%&gt;&lt;table align=&quot;center&quot; border=&quot;1&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;th&gt;图书编号&lt;/th&gt; &lt;th&gt;图书名称&lt;/th&gt; &lt;th&gt;图书作者&lt;/th&gt; &lt;th&gt;图书价格&lt;/th&gt; &lt;/tr&gt; &lt;%-- 获取传递过来的集合，集合中有几个图书信息，table就显示几行 items 指定要遍历的集合 var 指定从集合中每次取出的数据的变量 begin 指定从集合中的哪个元素开始显示，0表示第一个 end 指定取到哪个索引对应的集合元素 step 指定元素的间隔个数（默认为1，依次取出所有元素） --%&gt; &lt;c:forEach items=&quot;$&#123;bookList&#125;&quot; var=&quot;book&quot; begin=&quot;1&quot; end=&quot;4&quot; step=&quot;2&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.bookId&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.bookName&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.bookAuthor&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.bookPrice&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; 5.4 JSTL转换标签 fmt标签，提供了用于日期、数字等类型数据的格式转换的标签 12345678&lt;%-- 格式化数字输出 --%&gt;&lt;fmt:formatNumber value=&quot;$&#123;num&#125;&quot; pattern=&quot;#.0000&quot;&gt;&lt;/fmt:formatNumber&gt;&lt;br/&gt;&lt;fmt:formatNumber value=&quot;$&#123;num&#125;&quot; type=&quot;currency&quot;&gt;&lt;/fmt:formatNumber&gt;&lt;br/&gt;&lt;%-- 格式化日期输出 --%&gt;&lt;fmt:formatDate value=&quot;$&#123;date&#125;&quot; pattern=&quot;yyyy-MM-dd&quot;&gt;&lt;/fmt:formatDate&gt;&lt;br/&gt;&lt;fmt:formatDate value=&quot;$&#123;date&#125;&quot; pattern=&quot;hh:mm:ss&quot;&gt;&lt;/fmt:formatDate&gt;&lt;br/&gt;&lt;fmt:formatDate value=&quot;$&#123;date&#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;&gt;&lt;/fmt:formatDate&gt;&lt;br/&gt; 六、Servlet和JSP的综合案例 图书信息管理系统：管理员登录，对图书信息进行管理 管理员登录 添加图书信息 图书信息列表 修改图书信息 删除图书信息 6.1 书城后台管理系统业务流程 6.2 项目的MVC分层架构将项目中实现不同业务的代码进行分离: 视图View — jsp负责进行客户端的页面呈现 控制器Controller — servlet负责接收用户请求，调用service进行处理，根据处理结果进行流程跳转 模型Model — service对数据的业务处理、DAO对数据的持久化操作 6.3 数据库设计 根据项目业务功能抽象数据实体 管理员 图书 提取实体的数据项 管理员（ID，登录名，登录密码，真实姓名，性别，电话，备注） 图书（编号，名称，作者，价格，封面图片，描述，库存，分类…） 使用三范式约束的实体数据项（???） E-R图 数据库建模 建库建表 12345678910111213141516171819202122create database db_bookmall;create table users( user_id int primary key auto_increment, user_name varchar(40) not null unique, user_pwd varchar(40) not null, real_name varchar(20) not null, user_gender char(2) not null, user_tel char(11) not null unique, user_desc varchar(200));create table books( book_id char(6) primary key, book_name varchar(50) not null, book_author varchar(20) not null, book_price DECIMAL(10,2), book_img_path varchar(100) not null, book_desc varchar(200), book_stcok int not null, book_type int not null ); 6.4 web项目环境搭建 创建web项目 搭建JDBC环境 驱动 连接池 DBUtils 6.5 数据库访问实现6.5.1 管理员登录的数据库操作 根据登录名查询用户信息 （根据用户名查询用户，将查询出来的用户的密码和输入的密码进行对别） 创建实体类 123456789101112131415161718package com.qfedu.bookmall.ms.dto;/** * @Description 管理员实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class User &#123; private int userId; private String userName; private String userPwd; private String realName; private String userGender; private String userTel; private String userDesc; //....&#125; 创建DAO类实现数据库操作 12345678910111213141516171819202122232425262728293031323334package com.qfedu.bookmall.ms.dao;import com.qfedu.bookmall.ms.dto.User;import com.qfedu.bookmall.ms.utils.DruidUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import java.sql.SQLException;/** * @Description 用于实现管理员的数据库操作 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class UserDAO &#123; /** * 根据管理员登录名查询管理员信息 * @param userName * @return */ public User selectUserByUserName(String userName)&#123; User user = null; try &#123; String sql = &quot;select user_id userId,user_name userName,user_pwd userPwd,real_name realName,user_gender userGender,user_tel userTel,user_desc userDesc from users where user_name=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); user = queryRunner.query(sql, new BeanHandler&lt;User&gt;(User.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return user; &#125;&#125; 6.5.2 图书管理的数据库操作 添加图书信息 查询所有图书信息 根据图书ID删除一个图书信息 根据图书ID查询一个图书信息 根据图书ID修改一个图书信息 创建图书实体类 12345678910111213141516171819package com.qfedu.bookmall.ms.dto;/** * @Description 图书信息实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Book &#123; private String bookId; private String bookName; private String bookAuthor; private double bookPrice; private String bookImgPath; private String bookDesc; private int bookStock; private int bookType;&#125; 创建DAO类完成数据库操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.qfedu.bookmall.ms.dao;import com.qfedu.bookmall.ms.dto.Book;import com.qfedu.bookmall.ms.utils.DruidUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.sql.SQLException;import java.util.List;/** * @Description 完成图书信息的数据库操作 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookDAO &#123; /** * 添加图书信息 * @param book * @return */ public int insertBook(Book book)&#123; int i = 0; try &#123; String sql = &quot;insert into books(book_id,book_name,book_author,book_price,book_img_path,book_desc,book_stcok,book_type) values(?,?,?,?,?,?,?,?)&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); //给SQL中的参数赋值 Object[] params = &#123;book.getBookId(),book.getBookName(),book.getBookAuthor(),book.getBookPrice(),book.getBookImgPath(),book.getBookDesc(),book.getBookStock(),book.getBookType()&#125;; i = queryRunner.update(sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i; &#125; /** * 查询所有图书信息 * @return */ public List&lt;Book&gt; selectBooks()&#123; List&lt;Book&gt; bookList = null; try &#123; String sql = &quot;select book_id bookId,book_name bookName,book_author bookAuthor,book_price bookPrice,book_img_path bookImgPath,book_desc bookDesc,book_stcok bookStock,book_type bookType from books&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); bookList = queryRunner.query(sql, new BeanListHandler&lt;Book&gt;(Book.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return bookList; &#125; /** * 根据图书ID删除一个图书信息 * @param bookId * @return */ public int deleteBook(String bookId)&#123; int i = 0; try &#123; String sql = &quot;delete from books where book_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); i = queryRunner.update(sql, bookId); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i; &#125; /** * 根据图书ID查询一个图书信息 */ public Book selectBookByBookId(String bookId)&#123; Book book = null; try &#123; String sql = &quot;select book_id bookId,book_name bookName,book_author bookAuthor,book_price bookPrice,book_img_path bookImgPath,book_desc bookDesc,book_stcok bookStock,book_type bookType from books where book_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); book = queryRunner.query(sql, new BeanHandler&lt;Book&gt;(Book.class),bookId); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return book; &#125; /** * 根据图书ID修改一个图书信息 * @param book * @return */ public int updateBook(Book book)&#123; int i = 0; try &#123; String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_img_path=?,book_desc=?,book_stcok=?,book_type=? where book_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); Object[] params = &#123;book.getBookName(),book.getBookAuthor(),book.getBookPrice(),book.getBookImgPath(),book.getBookDesc(),book.getBookStock(),book.getBookType(),book.getBookId()&#125;; i = queryRunner.update(sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i; &#125;&#125; 6.6 网页设计 login.html index.html prompt.html book-add.html book-list.html book-modify.html 6.7 业务层实现6.7.1 管理员登录业务12345678910111213141516171819202122232425262728293031package com.qfedu.bookmall.ms.service;import com.qfedu.bookmall.ms.dao.UserDAO;import com.qfedu.bookmall.ms.dto.User;/** * @Description 管理员相关业务实现 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class UserService &#123; /** * 管理员登录业务：根据账号密码验证管理登录，验证通过返回user对象，否则返回null * @param userName * @param userPwd * @return */ public User checkLogin(String userName, String userPwd)&#123; //1.根据userName查询管理员信息 UserDAO userDAO = new UserDAO(); User user = userDAO.selectUserByUserName(userName); //2.判断密码 if(user != null &amp;&amp; user.getUserPwd() .equals(userPwd))&#123; return user; &#125;else&#123; return null; &#125; &#125; &#125; 6.7.2 图书管理业务实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.qfedu.bookmall.ms.service;import com.qfedu.bookmall.ms.dao.BookDAO;import com.qfedu.bookmall.ms.dto.Book;import java.util.List;/** * @Description 图书管理的业务实现 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookService &#123; private BookDAO bookDAO = new BookDAO(); /** * 添加图书业务实现 * @param book * @return */ public boolean saveBook(Book book)&#123; int i = bookDAO.insertBook(book); return i&gt;0?true:false; &#125; /** * 删除图书业务实现 * @param bookId * @return */ public boolean deleteBook(String bookId)&#123; int i = bookDAO.deleteBook(bookId); return i&gt;0?true:false; &#125; /** * 根据ID查询一个图书的业务实现 * @param bookId * @return */ public Book getBook(String bookId)&#123; Book book = bookDAO.selectBookByBookId(bookId); return book; &#125; /** * 修改图书业务实现 * @param book * @return */ public boolean modifyBook(Book book)&#123; int i = bookDAO.updateBook(book); return i&gt;0?true:false; &#125; /** * 查询所有图书信息 * @return */ public List&lt;Book&gt; listBooks()&#123; List&lt;Book&gt; bookList = bookDAO.selectBooks(); return bookList; &#125;&#125; 6.8 功能流程实现6.8.1 创建JSP及Servlet类 在项目创建所需的JSP文件，将设计好的HTML整合到JSP中 创建servlets包，在servlets中创建业务流程实现所需的Servlet类 6.8.2 管理员登录 login.jsp —&gt; 提交账号和密码到LoginCheckServlet LoginCheckServlet —&gt; 接收账号和密码进行校验，根据校验跳转 login.jsp —&gt; 显示登录失败时传递的提示信息 6.8.3 添加图书 index.jsp —&gt; 点击添加图书菜单，显示book-add.jsp book-add.jsp —&gt; 提交数据到BookSaveServlet（表单中有文件上传） BookSaveServlet —&gt; 在Servlet前添加 @MultipartConfig注解 prompt.jsp —&gt; 显示提示信息 注意：如果添加的中文出现乱码则添加编码过滤器 6.8.4 图书列表 index.jsp —-&gt; 点击图书列表向BookListServlet发送请求 BookListServlet —&gt;查询图书信息，转发传递到book-list.jsp book-list.jsp —&gt; JSTL+EL遍历显示图书信息 （需要在项目中引入jstl的2个jar文件） 6.8.5 删除图书 book-list.jsp—&gt; 显示图书列表时，将图书id和删除按钮绑定，点击删除时将当前图书的id传递到BookDeleteServlet BookDeleteServlet —&gt; 获取图书ID，删除图书信息，进行提示 6.8.6 修改图书 book-list.jsp —&gt; 点击修改，将图书ID传递到BookQueryServlet BookQueryServlet —&gt; 查询要修改的图书的原始信息 book-modify.jsp —&gt; 显示BookQueryServlet传递的图书的原始信息,修改之后提交到BookUpdateServlet红色标注表示显示图书原始信息、紫色标注表示提交修改 BookUpdateServlet—&gt; 接收修改后的数据，执行修改，并提示 七、分页功能实现7.1 分页概念 分页是web应用开发中非常重要的一个业务实现。数据库中的数据可能很多（成千上万、几十万、上百万都又可能），不能将这些数据全部查询出来并显示到列表页面。一般我们需要为用户提供翻页功能，例如一次显示10行&#x2F;20行，然后点击下一页查看接下来的10行&#x2F;20行。 7.2 分页实现思路 7.3 分页代码实现7.3.1 BookDAO 分页查询数据 123456789101112131415161718/*** 分页查询图书信息* @param start 查询数据的起始行索引* @param limit 最多返回的数据记录数（每页显示的条数）* @return 返回的集合中只包含一页的数据*/public List&lt;Book&gt; selectBooks(int start,int limit)&#123; List&lt;Book&gt; bookList = null; try &#123; String sql = &quot;select book_id bookId,book_name bookName,book_author bookAuthor,book_price bookPrice,book_img_path bookImgPath,book_desc bookDesc,book_stcok bookStock,book_type bookType from books limit ?,?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); bookList = queryRunner.query(sql, new BeanListHandler&lt;Book&gt;(Book.class),start,limit); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return bookList;&#125; 查询总记录数 123456789101112131415/*** 查询图书的总记录数* @return*/public long selectBookCount()&#123; long count = 0; try &#123; String sql = &quot;select count(1) from books&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); count = queryRunner.query(sql,new ScalarHandler&lt;Long&gt;()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count;&#125; 7.3.2 BookService 根据页码、每页条数查询当前页的数据 根据每页条数计算总页数 12345678910111213141516171819202122232425/** * 分页查询图书信息 * @param pageNum 页码 * @param pageSize 每页显示的条数 * @return */public List&lt;Book&gt; listBooksByPage( int pageNum,int pageSize)&#123; int start = (pageNum-1)*pageSize; int limit = pageSize; List&lt;Book&gt; bookList = bookDAO.selectBooks(start,limit); return bookList;&#125;/** * 查询图书总页数 * @param pageSize 每页显示的条数 * @return */public int getPageCount(int pageSize)&#123; //1.查询总记录 long count = bookDAO.selectBookCount(); //2.根据总记录数和每页显示的条数，计算总页数 long pageCount = count%pageSize == 0 ? count/pageSize: count/pageSize+1; return (int)pageCount;&#125; 7.3.3 BookListServlet1.接收页码 pageNum 2.定义每页显示条数 pageSize 3.查询当前页数据 bookList 4.查询总记录数 pageCount 5.转发到列表页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.qfedu.bookmall.ms.servlets;import com.qfedu.bookmall.ms.dto.Book;import com.qfedu.bookmall.ms.service.BookService;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;/** * @Description 分页查询图书信息 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/BookListServlet&quot;)public class BookListServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收客户端传递的页码 // (如果客户端没有传递页码，则默认页码为1，如果传递了则使用客户端传递的页码) String num = request.getParameter(&quot;pageNum&quot;); int pageNum = num==null? 1: Integer.parseInt( num ); //2.定义pageSize int pageSize = 10; //3.调用BookService查询这一页的图书信息 BookService bookService = new BookService(); List&lt;Book&gt; bookList = bookService.listBooksByPage(pageNum,pageSize); //4.调用BookService查询图书的总页数 int pageCount = bookService.getPageCount(pageSize); //5.将查询到的当前页数据的集合、当前页码、总页数 转发到book-list.jsp request.setAttribute(&quot;bookList&quot;,bookList); request.setAttribute(&quot;pageNum&quot;,pageNum); request.setAttribute(&quot;pageCount&quot;,pageCount); request.getRequestDispatcher(&quot;book-list.jsp&quot;).forward(request,response); &#125;&#125; 7.4 book-list.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;图书信息列表&lt;/h3&gt; &lt;table width=&quot;90%&quot; align=&quot;center&quot; border=&quot;1&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;封面&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;库存&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;th&gt;类型&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;bookList&#125;&quot; var=&quot;book&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.bookId&#125;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;$&#123;book.bookImgPath&#125;&quot; height=&quot;50&quot;&gt;&lt;/td&gt; &lt;td&gt;$&#123;book.bookName&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.bookAuthor&#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatNumber value=&quot;$&#123;book.bookPrice&#125;&quot; type=&quot;currency&quot; /&gt;&lt;/td&gt; &lt;td&gt;$&#123;book.bookStock&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.bookDesc&#125;&lt;/td&gt; &lt;td&gt; &lt;c:if test=&quot;$&#123;book.bookType ==1&#125;&quot;&gt;原创&lt;/c:if&gt; &lt;c:if test=&quot;$&#123;book.bookType ==2&#125;&quot;&gt;翻译&lt;/c:if&gt; &lt;/td&gt; &lt;td&gt; &lt;a href=&quot;BookQueryServlet?bookId=$&#123;book.bookId&#125;&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;BookDeleteServlet?bookId=$&#123;book.bookId&#125;&quot; onclick=&quot;javascript:return confirm(&#x27;你确定删除吗？&#x27;)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;!-- 显示分页效果及页码切换 --&gt; &lt;tr height=&quot;50&quot;&gt; &lt;td colspan=&quot;9&quot; align=&quot;center&quot;&gt; &lt;!--显示首页、上一页：如果当前页就是第一页，则不显示超链接--&gt; &lt;c:if test=&quot;$&#123;pageNum ==1 &#125;&quot;&gt; &lt;label style=&quot;color:gray&quot;&gt;首页&lt;/label&gt; &lt;label style=&quot;color:gray&quot;&gt;上一页&lt;/label&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pageNum &gt; 1 &#125;&quot;&gt; &lt;a href=&quot;BookListServlet?pageNum=1&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;BookListServlet?pageNum=$&#123;pageNum-1&#125;&quot;&gt;上一页&lt;/a&gt; &lt;/c:if&gt; &lt;!-- 显示页码 和总页数 --&gt; 当前第$&#123;pageNum&#125;页/共$&#123;pageCount&#125;页 &lt;!-- 显示下一页 和 尾页 --&gt; &lt;c:if test=&quot;$&#123;pageNum &lt; pageCount&#125;&quot;&gt; &lt;a href=&quot;BookListServlet?pageNum=$&#123;pageNum+1&#125;&quot;&gt;下一页&lt;/a&gt; &lt;a href=&quot;BookListServlet?pageNum=$&#123;pageCount&#125;&quot;&gt;尾页&lt;/a&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pageNum == pageCount&#125;&quot;&gt; &lt;label style=&quot;color:gray&quot;&gt;下一页&lt;/label&gt; &lt;label style=&quot;color:gray&quot;&gt;尾页&lt;/label&gt; &lt;/c:if&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 7.4 PageHelper封装 思考： 分页操作在Service查询页面数据及总页码都属同一个分页业务，为什么要携程两个方法呢？能不能在一个方法完成呢？ Servlet类主要负责流程控制，在上述代码实现过程中也涉及到了分页业务，不可理。该如何解决呢？ 7.4.1 PageHelper封装思路 7.4.2 创建分页帮助类PageHelper123456789101112131415161718192021222324package com.qfedu.bookmall.ms.utils;import java.util.List;/** * @Description 分页帮助类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class PageHelper&lt;T&gt; &#123; //存放页面数据的List集合 public List&lt;T&gt; list; //存放当前页码 public int pageNum; //存放总页数 public int pageCount; //无参构造器 //全参构造器 //get和set&#125; 7.4.3 BookService1234567891011121314151617181920212223/** * 分页查询图书信息 * @param pageNum 页码 * @param pageSize 每页显示的条数 * @return */public PageHelper&lt;Book&gt; listBooksByPage( int pageNum,int pageSize)&#123; //1.查询当前页码的数据 int start = (pageNum-1)*pageSize; int limit = pageSize; List&lt;Book&gt; bookList = bookDAO.selectBooks(start,limit); //2.查询并计算图书总页数 //a.查询总记录 long count = bookDAO.selectBookCount(); //b.根据总记录数和每页显示的条数，计算总页数 long pageCount = count%pageSize == 0 ? count/pageSize: count/pageSize+1; //3.将分页数据都放到一个PageHelper对象 PageHelper&lt;Book&gt; bookPageHelper = new PageHelper&lt;Book&gt;(bookList, pageNum, (int)pageCount); return bookPageHelper;&#125; 7.4.4 BookListServlet12345678910111213141516171819202122232425262728293031/** * @Description 分页查询图书信息 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/BookListServlet&quot;)public class BookListServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收客户端传递的页码 // (如果客户端没有传递页码，则默认页码为1，如果传递了则使用客户端传递的页码) String num = request.getParameter(&quot;pageNum&quot;); int pageNum = num==null? 1: Integer.parseInt( num ); //2.定义pageSize int pageSize = 10; //3.调用BookService查询这一页的图书信息 BookService bookService = new BookService(); PageHelper&lt;Book&gt; bookPageHelper = bookService.listBooksByPage(pageNum, pageSize); //5.将查询到的bookPageHelper(当前页数据的集合、当前页码、总页数) 转发到book-list.jsp request.setAttribute(&quot;bookPageHelper&quot;,bookPageHelper); request.getRequestDispatcher(&quot;book-list.jsp&quot;).forward(request,response); &#125;&#125; 7.4.5 book-list.jsp book-list.jsp 页面的数据都从bookPageHelper对象获取","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://example.com/tags/JSP/"}]},{"title":"day07-Servlet","slug":"day07-Servlet","date":"2022-09-16T15:30:01.000Z","updated":"2022-09-28T11:37:23.405Z","comments":true,"path":"2022/09/16/day07-Servlet/","link":"","permalink":"http://example.com/2022/09/16/day07-Servlet/","excerpt":"","text":"一、web服务器 思考：我们设计好的的网页如何才能够让互联网用户通过浏览器访问呢？ 1.1 什么是web服务器？ web服务器就是web项目的容器，我们将开发好的web项目部署到web容器中，才能使用网络中的用户通过浏览器进行访问。 1.2 静态资源和动态资源 web项目中的资源根据其特性可以分为两类： 静态网页：网页界面中的数据始终保持不变（HTML&#x2F;CSS&#x2F;JS&#x2F;图片） 动态网页：网页中的数据根据用户不同的请求可以会发生变化，也就是说网页中的数据是由程序根据用户的请求意图动态产生的 1.3 常用服务器产品 Tomcat（Apache开源，主流的web服务器之一，多应用于Javaweb项目开发） Jetty（运行效率高于Tomcat） WebLogic (Oracle，收费) WebSpere(IBM) Nginx（web静态资源服务器） 1.4 Tomcat简介Tomcat是Apache开源组织（apache.org）共享的Jakarta项目中的一个核心向，Tomcat开源免费、支持Java中的动态网页技术Servlet和JSP规范，因此Java开发者多使用Tomcat. Tomcat目前最新版本是10.1（alpha），在企业主流使用8.5和9，我们的学习主要基于8.5.72版本；各个版本之间的最大区别就是对于JavaEE版本及Servlet规范的支持、依赖的JDK版本。Tomcat8.x全面支持Servlet3.x规范及JavaEE4规范。 Tomcat基于其先进的技术、稳定的性能深受Java开发者的青睐。 Tomcat官网：https://tomcat.apache.org/ 1.5 Tomcat的安装1.5.1 下载(Tomcat v8.5.72)下载页面地址：https://tomcat.apache.org/download-80.cgi 1.5.2 解压安装 如果下载的是压缩包，则解压即可使用 解压注意事项： 建议解压的目标目录层级不要多 不建议解压到中文目中 1.5.3 Tomcat的目录结构 bin 该目录存放的是可执行的二进制文件(startup.bat用于启动Tomcat、shutdown.bat用于停止Tomcat) conf 存放的是Tomcat的配置文件（server.xml可以配置Tomcat的端口，web.xml） lib 此目录存放了Tomcat服务器运行web项目所需的基础类库 logs 存放Tomcat服务器的运行日志、记录了服务器启动、运行异常及关闭等操作的记录 temp 临时目录，存放Tomcat运行过程中产生的临时文件 webapps 存放Tomcat管理的web项目的目录，此目录中默认部署了Tomcat管理器等几个web项目 work Tomcat可以运行动态网页，动态网页就是在服务器上将数据加载到网页生成的页面，此目录就是存放Tomcat生成的文件 1.6 Tomcat启动和关闭方式1：双击运行...\\apache-tomcat-8.5.72\\bin\\starup.bat 关闭窗口，服务器就关闭了 方式2：双击运行...\\apache-tomcat-8.5.72\\bin\\tomcat8.exe 关闭窗口，服务器就关闭了 方式3：双击运行...\\apache-tomcat-8.5.72\\bin\\tomcat8w.exe (这种方式启动服务器之后，如果关闭了窗口，服务器依然在运行，我们就不能重复启动) Tomcat无法启动： Tomcat是基于Java语言的web服务器，它的运行需要依赖JDK，因此在安装Tomcat之前要确保计算机上安装了JDK并正确配置环境变量（特别是JAVA_HOME这个一定要配置正确） 1.7 web项目部署 web项目部署：将web项目交给Tomcat管理，当用户访问Tomcat时，Tomcat可以将web项目中的资源响应给用户浏览器。 方式1：直接将web项目拷贝到Tomcat的webapps目录 （访问路径就是项目名） 方式2：将web项目的路径配置到Tomcat中 拷贝web项目的路径 E:\\JavaWeb\\workspace\\html\\demo1 在Tomcat的conf目录中Catalina\\localhost创建一个xml文件（xml文件名可以自定义，建议和项目名称一致） 在xml文件中如下配置： path配置web项目的访问路径 docBase配置web项目的目录路径 1&lt;Context path=&quot;/demo1&quot; docBase=&quot;E:\\JavaWeb\\workspace\\html\\demo1&quot;&gt;&lt;/Context&gt; 1.8 浏览器访问web服务器 部署项目完成之后，建议可以重启一次Tomcat 打开浏览器输入网址：http://host-ip:tomcat-port/web-Path/index.html http:// web服务的HTTP传输协议 host-ip 服务器所在计算机的IP tomcat-port Tomcat服务器占用的网络端口（默认8080，可以在conf/server.xml中修改端口），如果tomcat端口为80，则可以省略 web-Path Tomcat中部署的web项目的访问路径 如果是直接将项目拷贝到 tomcat的 webapps中，并且没有进行其他配置，这个路径就是项目文件夹名称 如果是通过在Catalina\\localhost配置xml文件的形式部署项目，则项目的访问路径就是Context标签path属性的值 示例： http://192.168.155.1:8080/wolf/index.html http://192.168.155.1:8080/demo1/hw_login.html 1.9 Tomcat服务器请求响应流程 1.10 Tomcat端口配置 Tomcat默认端口是8080，我们可以通过修改conf/server.xml配置文件，修改服务器端口； 端口可以是1~65535中的数字，但是2000以下的很多端口被系统服务绑定，建议不要使用； 如果将服务器端口修改为80，则浏览器访问的时候无需添加端口号http://192.168.155.1/wolf/index.html 1234&lt;!--conf/server.xml 69行--&gt;&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 二、HTTP协议 web服务器可以接受浏览器的请求，并将服务器中的web项目资源响应给浏览器，浏览器与服务器之间进行网络通信遵循HTTP协议。 2.1 什么是HTTP协议？超文本传输协议（HTTP，HyperText Transfer Protocol） （ 浏览器—-&gt; web服务器） 网络中的通信协议： TCP协议，基于连接的安全传输协议 （客户端和服务器先建立连接，再通过连接发送数据） UDP协议，基于广播&#x2F;分发的非安全传输协议 （不会建立网络连接） HTTP超文本传输协议是运行于TCP协议的基础之上、基于请求与响应模式、无状态的应用层协议，是互联网中应用最为广泛的一种网络协议。 2.2 HTTP协议特点 基于连接通信：当浏览器与服务器进行通信时，会首先建立网络连接，通过网络连接进行通信 短连接：在HTTP1.0中，浏览器向服务器发送请求，建立连接，但是这个连接只作用于浏览器和服务器的一次请求响应，这次请求响应完成之后则断开连接。 长连接：在HTTP1.1中，浏览器请求与服务器建立连接、进行请求和响应之后，会等待几秒钟，在这几秒内如果浏览器有新的请求，则直接使用之前的这个连接进行请求和数据响应，如果过了几秒钟没有新的请求，则将连接断开。 请求与响应模式：首先由浏览器向服务器发送请求，服务器再对请求进行响应，如果没有浏览器的请求服务器是不会主动向浏览器进行响应的。 无状态：服务器不会感知同一个客户端的多次请求（就是当服务器接收到客户端请求之后，不能识别这个客户端是否请求我） 简单灵活：实现简便、可以传输不同类型的数据（客户端—-文件\\文本—-&gt;服务器） 2.3 HTTP协议通信规则 通信协议：客户端与服务器之间共同遵守的规则 HTTP协议是就请求和响应模式，浏览器向服务器发送请求时，需要准守HTTP请求规则，服务器对浏览器进行响应时也遵守HTTP响应规则。 2.3.1 http请求规则 说明：当在浏览器中发送请求时，浏览器已经实现了HTTP请求协议，基于这个协议发送请求的。 通过浏览器查看步骤（这种方式没法查看到所有的HTTP请求内容）： 打开浏览器 F12打开调试窗口、点击 network 在浏览器输入网址进行访问 在network窗口中查看请求头信息（Request Headers） 通过自定义的HTTP服务器，接收浏览器请求，查看HTTP请求规则： 自定义HTTP服务器 12345678910111213141516171819202122232425262728293031323334package com.qfedu.http.request;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.ServerSocket;import java.net.Socket;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */public class MyHttpServer &#123; public static void main(String[] args) throws IOException &#123; //创建一个网络服务器（可以通过浏览器请求这个服务） ServerSocket serverSocket = new ServerSocket(9999); //当浏览器请求我这个服务器之后，就建立网络连接（socket对象） Socket socket = serverSocket.accept(); //通过socket对象的输入流， InputStream inputStream = socket.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); //读取 浏览器发送的 HTTP请求 String content = null; while( (content = reader.readLine())!=null)&#123; System.out.println(content); &#125; //暂时未浏览器请求进行响应 &#125;&#125; HTTP请求内容： 2.3.2 http响应规则 自定义“浏览器”查看HTTP响应规则 自定义“浏览器” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.qfedu.http.response;import jdk.internal.util.xml.impl.Input;import java.io.*;import java.net.Socket;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */public class MyBrowser &#123; public static void main(String[] args) throws IOException &#123; //将上一个案例中浏览器发送给 MyHttpServer的 http请求内容，发送给百度 // 1.向百度服务器发送链接请求 Socket socket = new Socket(&quot;www.baidu.com&quot;, 80); // 2.通过链接中的输出流，将HTTP请求内容发送给百度 OutputStream outputStream = socket.getOutputStream(); PrintWriter out = new PrintWriter(outputStream); out.println(&quot;GET /s HTTP/1.1&quot;); out.println(&quot;Host: www.baidu.com:80&quot;); out.println(&quot;Connection: keep-alive&quot;); out.println(&quot;sec-ch-ua: \\&quot;Google Chrome\\&quot;;v=\\&quot;95\\&quot;, \\&quot;Chromium\\&quot;;v=\\&quot;95\\&quot;, \\&quot;;Not A Brand\\&quot;;v=\\&quot;99\\&quot;&quot;); out.println(&quot;sec-ch-ua-mobile: ?0&quot;); out.println(&quot;sec-ch-ua-platform: \\&quot;Windows\\&quot;&quot;); out.println(&quot;Upgrade-Insecure-Requests: 1&quot;); out.println(&quot;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36&quot;); out.println(&quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;); out.println(&quot;Sec-Fetch-Site: none&quot;); out.println(&quot;Sec-Fetch-Mode: navigate&quot;); out.println(&quot;Sec-Fetch-User: ?1&quot;); out.println(&quot;Sec-Fetch-Dest: document&quot;); out.println(&quot;Accept-Encoding: gzip, deflate, br&quot;); out.println(&quot;Accept-Language: zh-CN,zh;q=0.9&quot;); out.println(&quot;&quot;); out.flush(); //3.通过输入流接受百度的响应数据（HTTP响应规则） BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); String responseContent = null; while( (responseContent = reader.readLine())!=null)&#123; System.out.println(responseContent); &#125; &#125;&#125; HTTP响应内容 使用自定义HTTP服务器响应浏览器请求（遵循HTTP响应规则） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.qfedu.http.request;import java.io.*;import java.net.ServerSocket;import java.net.Socket;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */public class MyHttpServer &#123; public static void main(String[] args) throws IOException &#123; //创建一个网络服务器（可以通过浏览器请求这个服务） ServerSocket serverSocket = new ServerSocket(9999); //当浏览器请求我这个服务器之后，就建立网络连接（socket对象） Socket socket = serverSocket.accept(); //通过socket对象的输入流， InputStream inputStream = socket.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); //读取 浏览器发送的 HTTP请求 String content = null; while( !&quot;&quot; .equals(content = reader.readLine()))&#123; System.out.println(content); &#125; // 自定义HTTP服务器响应浏览器 PrintWriter out = new PrintWriter(socket.getOutputStream()); out.println(&quot;HTTP/1.1 200 OK&quot;); out.println(&quot;Connection: keep-alive&quot;); out.println(&quot;Content-Length: 154&quot;); out.println(&quot;Content-Type: text/html;charset=utf-8&quot;); out.println(&quot;Date: Sun, 07 Nov 2021 17:52:42 GMT&quot;); out.println(&quot;Location: https://www.baidu.com/&quot;); out.println(&quot;P3p: CP=\\&quot; OTI DSP COR IVA OUR IND COM \\&quot;&quot;); out.println(&quot;P3p: CP=\\&quot; OTI DSP COR IVA OUR IND COM \\&quot;&quot;); out.println(&quot;Server: BWS/1.1&quot;); out.println(&quot;X-Frame-Options: sameorigin&quot;); out.println(&quot;X-Ua-Compatible: IE=Edge,chrome=1&quot;); out.println(&quot;&quot;); out.println(&quot;&lt;!DOCTYPE html&gt;&quot;); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;title&gt;这是自定义服务器响应的页面&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;label style=&#x27;color:red&#x27;&gt;这是自定义服务器响应的内容&lt;/label&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); out.close(); &#125;&#125; 2.4 HTTP响应状态码 当浏览器向服务器发送请求、服务器对浏览器进行响应时，会响应给浏览器一个状态码,不同的状态码表示服务器对请求的不同处理。 2.4.1 响应状态码分类 1xx 表示浏览器请求服务器，服务器未做任何操作 2xx 表示服务器正常响应，并且响应成功 3xx 表示服务器只对浏览器的请求进行了部分处理，通知浏览器进行下一步操作 4xx 表示浏览器端（客户端）错误：404、401 5xx 表示服务器端资源错误 2.4.2 常见状态码 200 表示响应成功 302 表示服务器临时重定向 304 表示服务器资源没有变化 404 访问的资源不存在 500 访问的服务器端资源错误 三、Servlet基础使用3.1 Servlet简介 问题：浏览器可以通过http协议请求web服务器，访问web服务器上的web资源，web资源又分为静态资源和动态资源，静态资源可以直接存储在web服务器上供浏览器访问，动态资源该如何访问呢 ？ Servlet是服务器端的Java程序、能够接收HTTP请求、处理HTTP请求、并对HTTP请求进行响应的动态网页技术。 Servlet是JavaEE（JavaWeb）规范的一个重要组成部分。 Servlet的作用： 接收客户端的HTTP请求（浏览器） 根据用户请求进行数据处理 动态生成网页（网页中的数据是根据客户端请求动态改变的） 将生成的包含动态数据的网页响应给客户端 3.2 创建Java web工程 Servlet是JavaEE规范的一部分，Servlet的开发需要依赖JavaEE环境，之前创建的单纯的Java应用已经不能满足Servlet开发所需的环境需求，我们要创建Java web工程。 Java工程 ： 只引入了JDK的标准库（JavaSE） Java web工程：引入了Java企业级开发环境（JavaEE） File—&gt;New—&gt;Project… 选择Java Enterprise 如何配置Tomcat ? 点击New按钮，选择Tomcat Server 配置Tomcat服务器 选择 web application项目框架及版本 输入项目名称 Java web工程目录 3.3 创建Servlet类 Servlet是一个Java程序，是一个能够接收HTTP请求的Java类，因此需要实现HTTP协议。 在JavaEE库中有一个类 javax.servlet.http.HttpServlet实现了HTTP协议，我们创建的类只要继承这个 HttpServlet类，就实现了HTTP协议，就能够接受HTTP请求。 创建一个类继承javax.servlet.http.HttpServlet； 继承HttpServlet的类就能够接收HTTP请求，我们把这样的类称之为Servlet类，类以***Servlet格式命名； 在我们创建的Servlet类中，重写doPost&#x2F;doGet用于处理用户不同的请求 3.4 配置Servlet类的URL Servlet创建完成之后，需要配置url访问路径，然后将web项目运行在Tomcat之上，就能够通过配置的url访问Servlet类。Servlet自3.0规范开始支持两种配置方式： 基于web.xml配置文件进行配置 基于注解配置 3.4.1 基于web.xml配置Servlet 打开Java web工程中web/WEB-INF/web.xml文件 配置如下： 123456789101112131415161718&lt;!-- 配置BookListServlet类的访问路径 --&gt;&lt;!-- servlet标签： 配置类路径 --&gt;&lt;servlet&gt; &lt;!-- 配置与servlet-mapping标签的匹配表示，理论上可以是任意字符串， 只要多个servlet标签的servlet-name不重复就可以，实际开发中建议使用当前Servlet类 --&gt; &lt;servlet-name&gt;BookListServlet&lt;/servlet-name&gt; &lt;!--Servlet类路径--&gt; &lt;servlet-class&gt;com.qfedu.test1.BookListServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- servlet-mapping标签：配置url--&gt;&lt;servlet-mapping&gt; &lt;!--servlet-mapping标签的servlet-name属性与对应的 servlet标签的servlet-name属性一致--&gt; &lt;servlet-name&gt;BookListServlet&lt;/servlet-name&gt; &lt;!-- url-pattern配置Servlet的访问路径，必须以 / 开头 --&gt; &lt;url-pattern&gt;/book-list&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3.4.2 基于注解配置Servlet 在创建的Servlet类上添加@WebServlet注解，在注解后的参数中配置url，url也必须以/开头 1234567891011121314151617181920/** * @Description 根据图书ID查询一个图书信息 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/book-query&quot;)public class BookQueryServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;BookQueryServlet--------doPost&quot;); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;BookQueryServlet--------doGet&quot;); &#125;&#125; 3.5 IDEA部署web项目 通过IDEA，将java web项目部署到Tomcat中并运行Tomcat。 3.5.1 配置服务器 File—Settings 3.5.2 部署web项目 将web项目部署到Tomcat 点击IDEA右上角： 添加Tomcat服务器 部署项目 配置web项目的访问路径 3.5.3 启动Tomcat如果在创建web项目时选择了web服务器，则直接点击IDEA右上角运行即可： 播放按钮：直接运行 甲壳虫：debug运行 3.5.4 Tomcat启动完成工作 构建web项目 将web项目拷贝到Tomcat 启动Tomcat 打开浏览器，访问当前项目首页 3.6 浏览器访问测试 通过浏览器发送HTTP请求，访问tomcat中web项目中的Servlet类 3.7 GET请求与POST请求 Servlet类中的doGet和doPost是用来处理浏览器不同请求方式的HTTP请求，在HTTP协议中，HTTP请求有多种请求方式（get\\post\\delete\\put\\option等），不同请求方式传递的数据是不同的。 Servlet中的doGet方法用于处理客户端的get方式请求 Servlet中的doPost方法用于处理客户端的post方式请求 3.7.1 GET请求 使用Get方式请求服务器，传递的参数会拼接到URL后面，以?分隔url和参数,多个参数以&amp;符号分开； 12345&lt;form action=&quot;https://www.baidu.com&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;id&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;get提交&quot;/&gt;&lt;br/&gt;&lt;/form&gt; get方式是明文提交、提交的数据量小、安全性较差； get方式传输效率较高，浏览器地址栏输入网址默认采用get方式提交 get方式提交数据的场景： 浏览器地址栏 网页中的超链接 1&lt;a href=&quot;http://localhost:80/demo1/book-query&quot;&gt;请求BookQueryServlet&lt;/a&gt; form表单 method&#x3D;”get”提交 3.7.2 POST请求 使用POST方式请求服务器，参数是通过请求正文进行传递的（request body）； 12345&lt;form action=&quot;http://localhost:9999&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;id&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;POST提交&quot;/&gt;&lt;br/&gt;&lt;/form&gt; POST使用密文传递数据，数据量大，安全性高； POST以牺牲传输效率为代价保障了安全性，因此性能较get低。 POST提交数据的场景：form表单 method&#x3D;”post”提交 3.8 Servlet响应动态网页 案例：根据客户端请求的bookId,动态查询图书信息，生成HTML文档，响应给客户端 流程图 实现代码： 1234567891011121314151617package com.qfedu.test1.dto;/** * @Description 图书实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Book &#123; private String bookId; private String bookName; private String bookAuthor; private double bookPrice; private String bookImgPath; //无参构造器 //全参构造器 //get 和 set方法&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.qfedu.test1;import com.qfedu.test1.dto.Book;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.HashMap;import java.util.Map;/** * @Description 根据图书ID查询一个图书信息 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/book-query&quot;)public class BookQueryServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;BookQueryServlet--------doPost&quot;); &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;BookQueryServlet--------doGet&quot;); //动态生成HTML // 1.接收到浏览器请求时传递的图书ID (bookId) String bid = request.getParameter(&quot;bookId&quot;); // 2.根据bid查询数据库图书表(伪代码) Map&lt;String, Book&gt; bookMap = new HashMap&lt;&gt;(); bookMap.put(&quot;1001&quot;,new Book(&quot;1001&quot;,&quot;Java&quot;,&quot;张三&quot;,55.66,&quot;&quot;)); bookMap.put(&quot;1002&quot;,new Book(&quot;1002&quot;,&quot;C++&quot;,&quot;李四&quot;,33.44,&quot;&quot;)); bookMap.put(&quot;1003&quot;,new Book(&quot;1003&quot;,&quot;Python&quot;,&quot;王五&quot;,44.55,&quot;&quot;)); // book就是根据用户请求查询到的动态数据 Book book = bookMap.get(bid); // 3.将查询到图书信息生成网页，将网页响应给浏览器：通过IO流（输出流）向浏览器响应一个网页数据 // 这个out对象，就是用于响应浏览器的输出流，通过这个输出流写出什么数据，浏览器就可以接受到什么数据 // a.设置响应头 response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html&quot;); // b.通过输出流响应网页数据 PrintWriter out = response.getWriter(); out.println(&quot;&lt;!DOCTYPE html&gt;&quot;); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&lt;meta charset=&#x27;utf-8&#x27;&gt;&lt;title&gt;这是Servlet响应的网页&lt;/title&gt;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;table style=&#x27;border:1px deepskublue solid; width:1000px;&#x27; align=&#x27;center&#x27; border=&#x27;1&#x27; cellspacing=&#x27;0&#x27;&gt;&quot;); out.println(&quot;&lt;tr&gt;&lt;th&gt;图书编号&lt;/th&gt;&lt;th&gt;图书名称&lt;/th&gt;&lt;th&gt;图书作者&lt;/th&gt;&lt;th&gt;图书价格&lt;/th&gt;&lt;th&gt;图书封面&lt;/th&gt;&lt;/tr&gt;&quot;); out.println(&quot;&lt;tr&gt;&quot;); out.println(&quot;&lt;td&gt;&quot;+book.getBookId()+&quot;&lt;/td&gt;&quot;); out.println(&quot;&lt;td&gt;&quot;+book.getBookName()+&quot;&lt;/td&gt;&quot;); out.println(&quot;&lt;td&gt;&quot;+book.getBookAuthor()+&quot;&lt;/td&gt;&quot;); out.println(&quot;&lt;td&gt;&quot;+book.getBookPrice()+&quot;&lt;/td&gt;&quot;); out.println(&quot;&lt;td&gt;&quot;+book.getBookImgPath()+&quot;&lt;/td&gt;&quot;); out.println(&quot;&lt;/tr&gt;&quot;); out.println(&quot;&lt;/table&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); out.close(); &#125;&#125; 四、Servlet原理解析4.1 ServletAPI核心类与接口 4.2 Servlet类处理请求的流程准备工作： 新建一个Javaweb工程：servlet-demo2 新建一个Servlet类：TestServlet 12345创建servlet类的步骤：1.创建一个命名为 **Servlet2.继承javax.servlet.http.HttpServlet类3.重写doGet和doPost方法4.配置当前Servlet类的访问路径 12345678&lt;servlet&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.qfedu.servlets.TestServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/test&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 为了测试Servlet处理请求的流程，我们重写了从HttpServlet继承的多个方法： init service(ServletRequest,ServletResponse) service(HttpServletRequest,HttpServletResponse) doGet doPost destroy 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.qfedu.servlets;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 * * 创建servlet类的步骤： * 1.创建一个命名为 **Servlet * 2.继承javax.servlet.http.HttpServlet类 * 3.重写doGet和doPost方法 * 4.配置当前Servlet类的访问路径 */public class TestServlet extends HttpServlet &#123; @Override public void init(ServletConfig config) throws ServletException &#123; System.out.println(&quot;------------init&quot;); super.init(config); &#125; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; System.out.println(&quot;------------Servlet接口定义的service&quot;); super.service(req, res); &#125; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;------------HttpServlet类定义的service&quot;); super.service(req, resp); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;------------doGet&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;------------doPost&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;------------destroy&quot;); super.destroy(); &#125;&#125; Servlet请求处理流程 4.3 Servlet实例的生命周期[重点] 当客户端的请求到达Tomcat，Tomcat会创建一个线程来接收、处理、响应客户端请求，客户端在请求某个Servlet类时，线程需要通过这个Servlet类的实例来调用service方法、调用doGet&#x2F;doPost..方法来处理响应请求，这个Servlet类的实例是何时创建、何时销毁的呢？ Servlet实例的生命周期指的是一个Servlet类的实例从创建到销毁的过程。 Servlet类是单实例多线程的，一个Servlet类自始至终只会创建一个对象； 如果当前Servlet类没有配置 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;: 当客户端第一次请求Servlet时，创建当前Servlet类的实例，然后使用这个实例调用service(ServletRequest, ServletResponse)方法——service(HttpServletRequest, HttpServletResponse)方法——doGet&#x2F;doPost处理客户端请求;当客户端请求再次到达时将不会重新创建Servlet实例，直接使用第一次创建的实例调用方法进行响应； 如果当前Servlet类配置了 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;: 当服务器启动时就会创建Servlet类的实例，无论客户端第一次请求这个Servlet类，还是再次请求都不会创建Servlet类实例，直接使用服务器启动时创建的Servlet实例来接收、处理、响应客户端请求； 当服务器关闭时，Serlvet类的实例会被销毁。 配置load-on-startup的两种方式： xml配置 12345678910&lt;servlet&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.qfedu.servlets.TestServlet&lt;/servlet-class&gt; &lt;!--如果有多个Servlet都配置了load-on-startup，里面的数字就是在服务器中创建实例的顺序--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/test&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 注解配置： 1@WebServlet(value = &quot;/test&quot;,loadOnStartup = 1) 4.4 线程安全问题 因为Servlet实例是单例模式，当多个客户端并发访问同一个Servlet类时，Tomcat会创建多个线程，多个线程会使用同一个Servlet实例，有可能会导致线程安全问题，如何保证线程安全呢？ 4.4.1 方案1：实现SingleThreadModel接口 我们可以让Servlet类实现SingleThreadModel接口，每个线程都会创建servlet实例，避免了多线程使用通过Servlet实例的请求，但是使用这种方式会导致对客户端的请求响应效率变低，增加了服务器因频繁创建和销毁Servlet实例的开销，因此此种方式不建议使用，已经过时。 4.4.2 方案2：使用synchronized同步锁123456@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123; synchronized (this) &#123; // 业务代码 &#125;&#125; 4.4.3 建议：在Servlet实例中尽量不使用成员变量 如果将变量定义为成员变量，则这个变量在多个线程中是共享的，就有可能因为多个线程同时修改这个变量导致并发问题，因此我们可以将变量定义在处理业务的doXX方法中，定义为局部变量之后，每个线程都有属于自己的局部变量。 五、Servlet开发技术 Servlet动态网页技术，为客户端请求提供动态响应： Servlet如何接收客户端请求 Servlet如何为客户端提供响应 5.1 HttpServletRequest对象 我们在Servlet类中的doGet&#x2F;doPost&#x2F;doXX 方法中通过 request 对象接收客户端请求信息. 客户端向服务器发送的请求信息都会被封装到request对象，request（HttpServletRequest类）提供了多个方法可以用于获取http请求中的数据。 5.1.1 接收请求数据 5.1.2 request对象常用方法接收请求行数据 123456789101112//getMethod:获取客户端请求方式String method = request.getMethod();//getRequestURL: 获取客户端的请求URL（不包含url上的参数）String url = request.getRequestURL().toString();//getParameter : 获取请求行中url参数，根据参数的key获取参数的value// 如果客户端是通过输入框提交数据，则参数要和输入框的name属性值一致String p1 = request.getParameter(&quot;k1&quot;);//getProtocol ：获取客户端提交数据的协议及版本String protocol = request.getProtocol(); 接收请求头数据 12345678//getHeaderNames ：获取请求头中所有的keyEnumeration&lt;String&gt; en = request.getHeaderNames();while(en.hasMoreElements())&#123; String key = en.nextElement(); //getHeader ： 根据请求头中的key获取对应value String value = request.getHeader(key); System.out.println(key+&quot;:&quot;+value);&#125; 接收请求正文数据 1234567// 获取请求正文// getInputStream ：获取客户端请求的输入流ServletInputStream inputStream = request.getInputStream();BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));// 从输入流中读取请求正文String s = reader.readLine();System.out.println(s); 5.1.3 request对象接收表单数据案例 图书添加操作：需要从图书添加页面提交数据到Servlet book-add.html 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;提交图书&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;http://localhost/demo3/BookAddServlet&quot; method=&quot;get&quot;&gt; &lt;p&gt;图书编号：&lt;input type=&quot;text&quot; name=&quot;bookId&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书作者：&lt;input type=&quot;text&quot; name=&quot;bookAuthor&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书价格：&lt;input type=&quot;text&quot; name=&quot;bookPrice&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Get提交&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;hr/&gt; &lt;form action=&quot;http://localhost/demo3/BookAddServlet&quot; method=&quot;post&quot;&gt; &lt;p&gt;图书编号：&lt;input type=&quot;text&quot; name=&quot;bookId&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书作者：&lt;input type=&quot;text&quot; name=&quot;bookAuthor&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书价格：&lt;input type=&quot;text&quot; name=&quot;bookPrice&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Post提交&quot;/&gt;&lt;/p&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; BookAddServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;/** * @Description 添加图书 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/BookAddServlet&quot;)public class BookAddServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //getParameter 方法参数字符串 必须要和 form表单中输入框的name属性一致 // 此方法获取的客户端提交的数据一律为String类型，根据需要可以进行类型转换 int id = Integer.parseInt(request.getParameter(&quot;bookId&quot;));//5 String name = request.getParameter(&quot;bookName&quot;); String author = request.getParameter(&quot;bookAuthor&quot;); double price = Double.parseDouble(request.getParameter(&quot;bookPrice&quot;)); System.out.println(&quot;图书编号:&quot;+id); System.out.println(&quot;图书名称:&quot;+name); System.out.println(&quot;图书作者:&quot;+author); System.out.println(&quot;图书价格:&quot;+price); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 如果页面采用form表单post方式提交数据，数据是通过 请求正文 传递的 // 1.我们可以通过请求正文获取数据 //ServletInputStream inputStream = request.getInputStream(); //BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); //String s = reader.readLine(); //System.out.println(&quot;请求正文数据：&quot;+s); // 2.form表单post方式提交的数据，也可以通过request对象的getParameter方法接收， // 之前是不能打开request输入流 int id = Integer.parseInt(request.getParameter(&quot;bookId&quot;));//5 String name = request.getParameter(&quot;bookName&quot;); String author = request.getParameter(&quot;bookAuthor&quot;); double price = Double.parseDouble(request.getParameter(&quot;bookPrice&quot;)); System.out.println(&quot;图书编号:&quot;+id); System.out.println(&quot;图书名称:&quot;+name); System.out.println(&quot;图书作者:&quot;+author); System.out.println(&quot;图书价格:&quot;+price); &#125;&#125; 5.1.4 request对象处理中文乱码问题 客户端向服务器的Servlet类提交数据中包含中文，可能会出现中文乱码问题 1. 为什么会产生乱码问题？ 客户端提交的数据通过网络发送到服务器，传输的过程数据数据通常会进行编码，服务器会对数据进行解码；如果服务器使用的解码方式与网页的原始编码不一致，将会导致服务器的解码出现乱码 2.get方式提交数据的乱码问题 get方式提交的数据会拼接在请求行的URL后面进行传递，不同的浏览器处理方式是不一样的，有的浏览器会进行编码，有的浏览器则直接提交； 数据到达服务器之后，服务器会根据参数的编码方式对参数进行解码，如果没有编码则服务器直接接受，如果进行了服务器能够解析的编码，服务也会进行转换。 结论：GET方式提交的请求行参数，是通过服务器进行处理的。 解决方案：在Tomcat的conf&#x2F;server.xml中配置URL的编码方式 123&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;utf-8&quot; /&gt; 3.post方式提交数据的乱码问题 post方式提交表单数据是通过请求正文进行传递的，会对数据进行编码；Tomcat会对URL传递的参数进行解码，但是不能对请求正文进行解码，因此需要我们在Servlet类中接收数据之前对客户端提交的请求数据进行编码设置: request.setCharacterEncoding(&quot;utf-8&quot;); 页面表单提交数据-post方式提交： 1234567&lt;form action=&quot;http://localhost/demo3/BookAddServlet&quot; method=&quot;post&quot;&gt; &lt;p&gt;图书编号：&lt;input type=&quot;text&quot; name=&quot;bookId&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书作者：&lt;input type=&quot;text&quot; name=&quot;bookAuthor&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书价格：&lt;input type=&quot;text&quot; name=&quot;bookPrice&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Post提交&quot;/&gt;&lt;/p&gt;&lt;/form&gt; Servlet类对post提交的数据进行编码设置： 123456789101112protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //在servlet中接收数据之间，通过request对象设置http请求数据的编码方式 request.setCharacterEncoding(&quot;utf-8&quot;); int id = Integer.parseInt(request.getParameter(&quot;bookId&quot;)); String name = request.getParameter(&quot;bookName&quot;); String author = request.getParameter(&quot;bookAuthor&quot;); double price = Double.parseDouble(request.getParameter(&quot;bookPrice&quot;));&#125; 5.2 HttpServletResponse对象 Servlet类中doGet&#x2F;doPost&#x2F;doXX等方法都有一个HttpServletResponse对象，用于响应客户端请求 5.2.1 response对象常用方法1234567891011121314151617181920//【设置响应状态行】//setStatus : 设置状态行中的状态码response.setStatus(200);//【设置响应头】//setContentType: 设置响应头中的Content-Type属性，设置响应客户端的数据格式response.setContentType(&quot;text/html&quot;); //等价于： response.setHeader(&quot;Content-Type&quot;,&quot;text/html&quot;);//setContentLength：设置响应客户端的数据长度（一般无需设置）response.setContentLength(1024); //等价于：//setHeader ： 设置其他的响应头属性response.setHeader(&quot;Connection&quot;,&quot;keep-alive&quot;);//【设置响应正文】//setCharacterEncoding：设置响应客户端的数据编码格式response.setCharacterEncoding(&quot;utf-8&quot;);// 通过response对象获取输出流出// 字节流（如果要响应文件数据给客户端，则需要使用字节流）ServletOutputStream outputStream = response.getOutputStream();// 字符流（如果响应文本数据-HTML文档，则使用字符流）PrintWriter out = response.getWriter(); 5.2.2 查询成绩案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.Enumeration;/** * @Description 查询成绩 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/gradeQuery&quot;)public class GradeQueryServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;~~~~~~~~~~~~~~~doGet&quot;); //1.接收学号和课程编号 String stuNum = request.getParameter(&quot;stuNum&quot;); String curseId = request.getParameter(&quot;curseId&quot;); //2.查询数据库 int grade = 95; //3.通过response响应浏览器 response.setStatus(200); response.setContentType(&quot;text/html&quot;); response.setHeader(&quot;Connection&quot;,&quot;keep-alive&quot;); //【设置响应正文】 //setCharacterEncoding：设置响应客户端的数据编码格式 response.setCharacterEncoding(&quot;utf-8&quot;); // 通过response对象获取输出流出 PrintWriter out = response.getWriter(); //通过流写出的数据，就会以响应正文的形式传输给客户端浏览器，如果浏览器可以识别数据，则直接显示 out.println(&quot;&lt;!DOCTYPE html&gt;&quot;); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;meta charset=&#x27;utf-8&#x27;&gt;&quot;); out.println(&quot;&lt;title&gt;学生成绩查询结果&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;div style=&#x27;padding:50px; font-size:50px; text-align:center; border:1px gray solid; margin:auto&#x27;&gt;&quot;); out.println(&quot;&lt;label&gt;您的成绩为：&lt;/label&gt;&quot;); out.println(&quot;&lt;label style=&#x27;color:red&#x27;&gt;&quot;+grade+&quot;&lt;/label&gt;&quot;); out.println(&quot;&lt;/div&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); out.close(); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取请求正文 // getInputStream ：获取客户端请求的输入流 ServletInputStream inputStream = request.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); // 从输入流中读取请求正文 String s = reader.readLine(); System.out.println(s); &#125;&#125; 5.3 Servlet动态网页案例 学生信息管理系统： 学生登录 学生查询成绩 5.3.1 案例流程分析 5.3.2 项目环境搭建 数据库环境准备: 创建一个名为db_sgms，然后创建如下数据表： 12345678910111213141516171819202122-- 学生信息表create table students( stu_num char(5) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, stu_pwd varchar(20) not null);-- 课程信息表create table courses( course_id char(6) primary key, course_name varchar(50) not null);-- 学生成绩表create table grades( gid int primary key auto_increment, snum char(5) not null, cid char(6) not null, score int not null); 创建一个Java web工程: servlet-demo4 搭建JDBC环境 导入JDBC所需的驱动jar、数据库连接池jar、DBUtils.jar 在web&#x2F;WEB-INF创建lib目录 将三个jar包拷贝到lib目录 选择拷贝到lib目录三个jar文件—-右键—-Add as library 配置连接池信息 在项目中创建com.qfedu.sgms.utils包 在包中创建druid.properties配置druid连接池信息 123456789101112131415# 数据库连接信息driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/db_sgms?characterEncoding=utf8username=rootpassword=@QFedu123# 连接池属性# 连接池的初始化连接数&lt;创建数据库连接池时默认初始化的连接的个数&gt;initialSize=10# 连接池的最大连接数maxActive=50# 最小空闲连接数（当数据库连接使用率很低时，连接池中的连接会被释放一部分）minIdle=5# 超时等待时间(单位：ms)maxWait=30000 在utils包中创建连接池工具类：DruidUtils 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.qfedu.sgms.utils;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.*;import java.io.InputStream;import java.sql.*;import java.util.Properties;/** * @Description 数据库连接池工具类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class DruidUtils &#123; private static DruidDataSource druidDataSource; static&#123; try &#123; InputStream is = DruidUtils.class.getResourceAsStream(&quot;druid.properties&quot;); Properties properties = new Properties(); properties.load(is); druidDataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取数据库连接池数据源对象 * @return */ public static DataSource getDataSource()&#123; return druidDataSource; &#125; /** * 从数据库连接池中获取数据库连接对象 * @return */ public static Connection getConnection()&#123; Connection connection = null; try &#123; connection = druidDataSource.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125;&#125; 5.3.3 完成数据库操作 根据项目业务流程图，完成需要数据库操作 学生登录实现： 根据输入的学号和密码查询学生信息，如果查询到了说明学号密码输入正确，登录成功； 根据输入的学号查询学生，如果查询到了说明学号正确，再比较输入的密码和查询出来的密码是否一致，如果一致则登录成功； 查询成绩： 根据学号和课程号从成绩表中查询成绩 根据学号和密码查询学生 创建实体类 Student类 12345678910111213141516package com.qfedu.sgms.dto;/** * @Description 学生信息实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Student &#123; private String stuNum; private String stuName; private String stuGender; private int stuAge; private String stuPwd;&#125; 创建DAO，完成对应数据库操作 123456789101112131415161718192021222324252627282930313233package com.qfedu.sgms.dao;import com.qfedu.sgms.dto.Student;import com.qfedu.sgms.utils.DruidUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */public class StudentDAO &#123; /** * 根据学号和密码查询学生信息 * @param stuNum * @param stuPwd * @return 如果学号密码正确返回Student，否则返回null */ public Student queryStudentByNumAndPwd(String stuNum,String stuPwd)&#123; Student student = null; try&#123; String sql = &quot;select stu_num stuNum,stu_name stuName,stu_gender stuGender,stu_age stuAge,stu_pwd stuPwd from students where stu_num=? and stu_pwd=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); student = queryRunner.query(sql,new BeanHandler&lt;Student&gt;(Student.class),stuNum,stuPwd); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return student; &#125;&#125; 根据学号、课程号查询成绩 创建实体类 Grade类 12345678910111213141516package com.qfedu.sgms.dto;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Grade &#123; private String snum; private String sname; //此属性在成绩表中没有，但是关联学生信息可以查询 private String cid; private String cname; //此属性在成绩表也没有，但是关联课程表可以查询 private int score;&#125; 创建GradeDAO查询成绩 12345678910111213141516171819202122232425262728293031323334package com.qfedu.sgms.dao;import com.qfedu.sgms.dto.Grade;import com.qfedu.sgms.utils.DruidUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */public class GradeDAO &#123; /** * 根据学号和课程号查询这个学生这门课的成绩 * @param snum * @param cid * @return */ public Grade queryGradeBySnumAndCid(String snum,String cid)&#123; Grade grade = null; try&#123; //注意查询出的列名要取别名，和grade对象的属性一致 String sql = &quot;select s.stu_num snum,s.stu_name sname,c.course_id cid,c.course_name cname ,g.score score from students s INNER JOIN grades g INNER JOIN courses c on s.stu_num = g.snum and g.cid = c.course_id where s.stu_num=? and c.course_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); grade = queryRunner.query(sql,new BeanHandler&lt;Grade&gt;(Grade.class),snum,cid); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return grade; &#125;&#125; 5.3.4 实现LoginPageServlet登录界面 LoginPageServlet就是为用户提供一个登陆页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.qfedu.sgms.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/login&quot;)public class LoginPageServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //响应一个登录界面 response.setStatus(200); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;!DOCTYPE html&gt;&quot;); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;meta charset=&#x27;utf-8&#x27;&gt;&quot;); out.println(&quot;&lt;title&gt;学生成绩查询系统-登录&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;form action=&#x27;&#x27; method=&#x27;post&#x27;&gt;&quot;); out.println(&quot;&lt;h3&gt;学生成绩查询系统—学生登录&lt;/h3&gt;&quot;); out.println(&quot;&lt;p&gt;学号：&lt;input type=&#x27;text&#x27; name=&#x27;stuNum&#x27; placeholder=&#x27;学生学号&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;p&gt;密码：&lt;input type=&#x27;password&#x27; name=&#x27;stuPwd&#x27; placeholder=&#x27;登录密码&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;p&gt;&lt;input type=&#x27;submit&#x27; value=&#x27;登录&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;/form&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); out.close(); &#125;&#125; 5.3.5 实现CheckServlet验证登录 CheckServlet接收用户在页面中输入学号和密码、调用StudentDAO查询验证 创建CheckServlet类 修改LoginPageServlet中的 form表单action属性为CheckServlet的访问路径 12// 点击登录之后跳转到另一个CheckServlet，在一个项目中action的值可以只写 CheckServlet的urlout.println(&quot;&lt;form action=&#x27;CheckServlet&#x27; method=&#x27;post&#x27;&gt;&quot;); 在CheckServlet类验证客户端提交的学号和密码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.qfedu.sgms.servlets;import com.qfedu.sgms.dao.StudentDAO;import com.qfedu.sgms.dto.Student;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Description 验证学生登录 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/CheckServlet&quot;)public class CheckServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 接收学号和密码 request.setCharacterEncoding(&quot;utf-8&quot;); String num = request.getParameter(&quot;stuNum&quot;); String pwd = request.getParameter(&quot;stuPwd&quot;); //2.调用StudentDAO中的方法，根据学号和密码查询学生 StudentDAO studentDAO = new StudentDAO(); Student student = studentDAO.queryStudentByNumAndPwd(num, pwd); //3.判断查询结果，响应客户端 response.setStatus(200); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;!DOCTYPE html&gt;&quot;); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;meta charset=&#x27;utf-8&#x27;&gt;&quot;); //根据登录验证的不同结果响应给客户端不同的页面 if(student == null)&#123; //登录失败：响应客户端登录页面 out.println(&quot;&lt;title&gt;学生成绩查询系统-登录&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); //点击登录之后跳转到另一个CheckServlet，在一个项目中action的值可以只写CheckServlet的url out.println(&quot;&lt;form action=&#x27;CheckServlet&#x27; method=&#x27;post&#x27;&gt;&quot;); out.println(&quot;&lt;h3&gt;学生成绩查询系统—学生登录&lt;/h3&gt;&quot;); out.println(&quot;&lt;p&gt;学号：&lt;input type=&#x27;text&#x27; name=&#x27;stuNum&#x27; placeholder=&#x27;学生学号&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;p&gt;密码：&lt;input type=&#x27;password&#x27; name=&#x27;stuPwd&#x27; placeholder=&#x27;登录密码&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;p&gt;&lt;input type=&#x27;submit&#x27; value=&#x27;登录&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;/form&gt;&quot;); &#125;else&#123; //登录成功：响应客户端系统的主页 out.println(&quot;&lt;title&gt;学生成绩查询系统-主页面&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;登录成功！&quot;); &#125; out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); out.close(); &#125;&#125; 5.3.6 业务与视图分离 通过上个步骤CheckServlet的实现，我们发现一些问题： 如果登录验证失败，需要响应登录页面，登录界面已经在LoginPageServlet中写过，在CheckServlet又写了一遍，不满足我们代码复用性原则，不便于代码维护； 在CheckServlet中，业务代码与视图代码混在一起，不满足单一原则的编程规范 业务与视图分离： CheckServlet只负责学生登录校验的业务处理； 如果登录成功需要呈现主界面，可以创建单独的IndexPageServlet来响应主页面； 如果登录失败需要呈现登录界面，可以重复使用LoginPageServlet来响应登录页面； 5.3.7 实现IndexPageServlet主页面 IndexPageServlet显示成绩查询的主页面，并且能够输入学号和课程号查询成绩 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.qfedu.sgms.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Description 提供登录成功之后的主页面 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/IndexPageServlet&quot;)public class IndexPageServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //响应一个登录界面 response.setStatus(200); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;!DOCTYPE html&gt;&quot;); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;meta charset=&#x27;utf-8&#x27;&gt;&quot;); out.println(&quot;&lt;title&gt;学生成绩查询系统-主页面&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;table border=&#x27;1&#x27; width=&#x27;100%&#x27; height=&#x27;700&#x27;&gt;&quot;); out.println(&quot;&lt;tr height=&#x27;100&#x27;&gt;&lt;td colspan=&#x27;2&#x27;&gt;&lt;label&gt;学生成绩查询系统欢迎您！&lt;/label&gt;&lt;/td&gt;&lt;/tr&gt;&quot;); out.println(&quot;&lt;tr&gt;&quot;); out.println(&quot;&lt;td width=&#x27;200&#x27;&gt;2-1&lt;/td&gt;&quot;); out.println(&quot;&lt;td align=&#x27;center&#x27; valign=&#x27;top&#x27;&gt;&quot;); //查询成绩的表单 out.println(&quot;&lt;form action=&#x27;GradeQueryServlet&#x27; method=&#x27;post&#x27;&gt;&quot;); out.println(&quot;&lt;h3&gt;查询成绩&lt;/h3&gt;&quot;); out.println(&quot;&lt;p&gt;学号：&lt;input type=&#x27;text&#x27; name=&#x27;stuNum&#x27; placeholder=&#x27;学生学号&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;p&gt;课程：&lt;input type=&#x27;text&#x27; name=&#x27;courseId&#x27; placeholder=&#x27;课程编号&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;p&gt;&lt;input type=&#x27;submit&#x27; value=&#x27;查询&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;/form&gt;&quot;); out.println(&quot;&lt;/td&gt;&quot;); out.println(&quot;&lt;/tr&gt;&quot;); out.println(&quot;&lt;/table&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); out.close(); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; 5.3.8 登录失败转发到LoginPageServlet CheckServlet转发到LoginPageServlet，并传递参数 123456789101112//3.判断查询结果，响应客户端//根据登录验证的不同结果响应给客户端不同的页面if(student == null)&#123; //登录失败：响应客户端登录页面,提示“登录失败，学号或密码错误！” //转发到下一个Servlet是可以通过request传递数据过去的 request.setAttribute(&quot;tips&quot;,&quot;登录失败，学号或密码错误！&quot;); //转发到LoginPageServlet：在当前Servlet类的doPost方法转到，也会转发到下一个Servelt的doPost request.getRequestDispatcher(&quot;login&quot;).forward(request,response);&#125;else&#123; //登录成功：响应客户端系统的主页&#125; LoginPageServlet接收参数响应登录页面 12345678910111213141516171819202122 @Overrideprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;-----doPost&quot;); //1. doPost调用doGet doGet(request,response);&#125;@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;-----doGet&quot;); //2.接收从CheckServlet传递的提示信息 String tips = (String) request.getAttribute(&quot;tips&quot;); //响应一个登录界面 //...代码省略 //显示提示信息 if(tips != null)&#123; out.println(&quot;&lt;label style=&#x27;color:red&#x27;&gt;&quot;+tips+&quot;&lt;/label&gt;&quot;); &#125; //...代码省略&#125; 5.3.9 登录成功重定向IndexPageServlet CheckServlet重定向IndexPageServlet 1234567891011121314//3.判断查询结果，响应客户端//根据登录验证的不同结果响应给客户端不同的页面if(student == null)&#123; //登录失败：响应客户端登录页面,提示“登录失败，学号或密码错误！” //转发到下一个Servlet是可以通过request传递数据过去的 request.setAttribute(&quot;tips&quot;,&quot;登录失败，学号或密码错误！&quot;); //转发到LoginPageServlet：在当前Servlet类的doPost方法转到，也会转发到下一个Servelt的doPost request.getRequestDispatcher(&quot;login&quot;).forward(request,response);&#125;else&#123; //登录成功：响应客户端系统的主页 //重定向到IndexPageServlet：无需传递参数到IndexPageServlet，所以我们可以使用重定向 response.sendRedirect(&quot;IndexPageServlet&quot;);&#125; 5.3.10 实现GradeQueryServlet查询成绩 GradeQueryServlet接收客户端输入的学号、课程ID，查询成绩 创建GradeQueryServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.qfedu.sgms.servlets;import com.qfedu.sgms.dao.GradeDAO;import com.qfedu.sgms.dto.Grade;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Description 根据客户端传递的学号、课程号查询成绩 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/GradeQueryServlet&quot;)public class GradeQueryServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //如果允许客户端get和post方式提交，我们可以在doGet中调用doPost,业务代码写在doPost doPost(request,response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收客户端输入的学号、课程ID String snum = request.getParameter(&quot;stuNum&quot;); String cid = request.getParameter(&quot;courseId&quot;); //2.调用GradeDAO中的方法根据学号、课程号查询成绩 GradeDAO gradeDAO = new GradeDAO(); Grade grade = gradeDAO.queryGradeBySnumAndCid(snum, cid); //3.查询到成绩之后，将成绩传递到GradePageServlet // 由GradePageServlet响应给浏览器一个页面，并把成绩显示出来 request.setAttribute(&quot;grage&quot;,grade); request.getRequestDispatcher(&quot;GradePageServlet&quot;).forward(request,response); &#125; &#125; 修改IndexPageServlet响应的主页面，form标签的action属性为GradeQueryServlet 直接修改到 5.3.7 的代码 5.3.11 实现GradePageServlet显示成绩 GradePageServle响应给客户端一个成绩结果页面，并显示成绩 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.qfedu.sgms.servlets;import com.qfedu.sgms.dto.Grade;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Description 成绩查询结果页面 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/GradePageServlet&quot;)public class GradePageServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收转发时传递的成绩 Grade grade = (Grade) request.getAttribute(&quot;grade&quot;); //2.设置响应头 response.setStatus(200); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); //3.响应成绩结果页面 PrintWriter out = response.getWriter(); out.println(&quot;&lt;!DOCTYPE html&gt;&quot;); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;meta charset=&#x27;utf-8&#x27;&gt;&quot;); out.println(&quot;&lt;title&gt;学生成绩查询系统&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;table border=&#x27;1&#x27; width=&#x27;100%&#x27; height=&#x27;700&#x27;&gt;&quot;); out.println(&quot;&lt;tr height=&#x27;100&#x27;&gt;&lt;td colspan=&#x27;2&#x27;&gt;&lt;label&gt;学生成绩查询系统欢迎您！&lt;/label&gt;&lt;/td&gt;&lt;/tr&gt;&quot;); out.println(&quot;&lt;tr&gt;&quot;); out.println(&quot;&lt;td width=&#x27;200&#x27;&gt;2-1&lt;/td&gt;&quot;); out.println(&quot;&lt;td align=&#x27;center&#x27; valign=&#x27;top&#x27;&gt;&quot;); //查询成绩的表单 ： 修改action属性为 GradeQueryServlet out.println(&quot;&lt;h3&gt;查询结果&lt;/h3&gt;&quot;); if(grade != null)&#123; out.println(&quot;&lt;table width=&#x27;200&#x27; border=&#x27;1&#x27; cellspacing=&#x27;0&#x27;&gt;&quot;); out.println(&quot;&lt;tr&gt;&lt;td&gt;学号&lt;/td&gt;&lt;td&gt;&quot;+grade.getSnum()+&quot;&lt;/td&gt;&lt;/tr&gt;&quot;); out.println(&quot;&lt;tr&gt;&lt;td&gt;姓名&lt;/td&gt;&lt;td&gt;&quot;+grade.getSname()+&quot;&lt;/td&gt;&lt;/tr&gt;&quot;); out.println(&quot;&lt;tr&gt;&lt;td&gt;课程ID&lt;/td&gt;&lt;td&gt;&quot;+grade.getCid()+&quot;&lt;/td&gt;&lt;/tr&gt;&quot;); out.println(&quot;&lt;tr&gt;&lt;td&gt;课程名&lt;/td&gt;&lt;td&gt;&quot;+grade.getCname()+&quot;&lt;/td&gt;&lt;/tr&gt;&quot;); out.println(&quot;&lt;tr&gt;&lt;td&gt;成绩&lt;/td&gt;&lt;td&gt;&lt;label style=&#x27;color:red;font-weight:bold&#x27;&gt;&quot;+grade.getScore()+&quot;&lt;/label&gt;&lt;/td&gt;&lt;/tr&gt;&quot;); out.println(&quot;&lt;/table&gt;&quot;); &#125;else&#123; out.println(&quot;&lt;label style=&#x27;color:red;font-weight:bold;font-size:20px&#x27;&gt;学号或课程号有误!&lt;/label&gt;&quot;); &#125; out.println(&quot;&lt;a href=&#x27;IndexPageServlet&#x27;&gt;继续查询&lt;/a&gt;&quot;); out.println(&quot;&lt;/td&gt;&quot;); out.println(&quot;&lt;/tr&gt;&quot;); out.println(&quot;&lt;/table&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); out.close(); &#125;&#125; 5.4 转发和重定向 当客户端请求到了某个Servlet类之后，Servlet类进行处理，但是并不使用这个Servlet来响应客户端，而是要使用另一个Servlet来响应。 5.4.1 转发1. 转发跳转流程 2. 转发的特点 转发是在服务器端，两个Servlet之间的请求行为； 浏览器只对服务器进行了一次请求； 浏览器的地址不会改变，浏览器请求ServletA，ServletA转到ServletB由ServletB响应浏览器，浏览器显示的是ServletA的访问地址； 转发过程中，可以通过request对象传递数据； 3. 转发的代码实现 ServletA 转发到 ServletB 在ServletA中： request.getRequestDispatcher(“ServletB的URL“).forward(request,response); 4. 数据传递 ServletA 转发到 ServletB，并传递参数 传数据 1234567//ServletA：在转发操作之前，将需要传递给ServletB的参数设置到request对象中，可以传递不同类型数据//设置转发传递的数据request.setAttribute(&quot;stuNum&quot;,&quot;10001&quot;);request.setAttribute(&quot;stuAge&quot;,21); //如果直接给简单类型数据，则会自动装箱为对应的封装类对象request.setAttribute(&quot;stu&quot;,new Student(...));//转发request.getRequestDispatcher(&quot;ServletB的URL&quot;).forward(request,response); 取数据 12345//ServletB：在ServletB的doGet/doPost方法中，通过request对象获取ServletA传递的参数//Object obj = request.getAttribute(String key);String snum = (String)request.getAttribute(&quot;stuNum&quot;);int sage = (Integer)request.getAttribute(&quot;stuAge&quot;);Student stu = (Studennt)request.getAttribute(&quot;stu&quot;); 5.4.2 重定向1. 重定向跳转流程 客户端请求ServletA，ServletA响应给客户端一个新的请求地址ServletB，让客户端重新向ServeltB发送请求。 2. 重定向特点 重定向是客户端的行为 浏览器对服务器发送了两次请求； 重定向是由浏览器再次发送请求，浏览器地址会改变为转发的地址； 不能通过request对象将ServletA中的数据传递给ServletB 如果ServletA重定向到ServletB的时候有数据要传递到ServletB该如何实现？——url传值 3. 重定向代码实现 在ServletA中 response.sendRedirect(“ServletB访问URL“); 4. 数据传递12//ServletA：在响应浏览器重定向地址的时候，在URL声明参数response.sendRedirect(&quot;ServletB?key=value&quot;); 12//ServletB: 获取浏览器请求的参数String value = request.getParameter(&quot;key&quot;); 5.5 状态管理5.5.1 现有问题 http请求是无状态的，不能保存客户每次提交的信息； 客户端发送一个新的请求达到服务器，服务器无法知道此客户端是否曾经请求过服务器，两次请求之间是没有联系的； 如果用户在访问系统的主页面（主页面需要登录之后才可以访问），需要访问之前请求提交的数据该如何实现？ 5.5.2 状态管理实现 将浏览器与服务器之间的多次交互作为一个整体处理，通过服务器数据存储和浏览器数据存储集合的形式实现状态管理： 客户端状态管理：cookie技术 （在浏览器缓存数据） 服务器状态管理：session技术（在服务器存储用户信息，基于cookie） 5.6 Cookie的使用5.6.1 什么是Cookie？ Cookie是在浏览器访问web服务器上的某个资源时，由web服务器在响应浏览器时通过响应头附带的传送给浏览器并存储在浏览器端的一小段数据； 一旦web浏览器保存了来自于某个服务器的Cookie，那么当浏览器再次访问这个服务器的时候，会通过请求头将cookie传递给web服务器； 浏览器访问服务器的时候，只会携带由当前服务器存储在客户端的cookie； Cookie中缓存的数据数据是以键值对形式存储的（name-value）。 5.6.2 Cookie的使用案例流程图： 创建一个Java web工程：servlet-demo5 修改web项目在服务器上的访问路径为/demo5： 创建两个Servlet类，分别为FirstServlet和SecondServlet 1. 写Cookie到浏览器 创建cookie Cookie cookie = new Cookie(&quot;key1&quot;, &quot;value1&quot;); 设置cookie cookie.setMaxAge(24*60*60); 写cookie response.addCookie(cookie); 服务器可以同时写多个Cookie存储到客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Description 写Cookie * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/FirstServlet&quot;)public class FirstServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //向浏览器存储一个Cookie // 1. 创建Cookie对象 （javax.servlet.http.Cookie） Cookie cookie = new Cookie(&quot;key1&quot;, &quot;value1&quot;); // 设置cookie生命周期 // 情况1：如果设置&gt;0的值，表示设置cookie有效时间（单位s） // 情况2：如果参数=0，表示浏览器关闭销毁cookie // 情况3：如果参数=-1，表示内存存储 cookie.setMaxAge(24*60*60); // 2. 将cookie对象添加到HTTP响应头，写Cookie到客户端 response.addCookie(cookie); //响应浏览器一个界面 //a.设置响应头 response.setStatus(200); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); //b.响应正文 PrintWriter out = response.getWriter(); out.println(&quot;&lt;!DOCTYPE html&gt;&quot;); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;meta charset=&#x27;utf-8&#x27;&gt;&quot;); out.println(&quot;&lt;title&gt;&lt;/title&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;a href=&#x27;SecondServlet&#x27;&gt;请求SecondServlet&lt;/a&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); out.close(); &#125;&#125; 2. 服务器读取Cookie 通过request对象获取所有cookie： Cookie[] cookies = request.getCookies(); 获取Cookie对象的key： String key = cookie.getName(); 获取Cookie对象的value：String value = cookie.getValue(); 123456789101112131415161718192021222324252627282930313233343536package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Description 读Cookie * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/SecondServlet&quot;)public class SecondServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 读取cookie: 当客户端再次请求服务器时，通过request将cookie传递到服务器 // 通过request对象获取浏览器传递的cookie Cookie[] cookies = request.getCookies(); for (Cookie cookie: cookies) &#123; String key = cookie.getName(); String value = cookie.getValue(); System.out.println(key+&quot;对应的值：&quot;+value); &#125; // SecondServlet暂时不响应浏览器 &#125;&#125; 5.6.3 Cookie的优点和限制优点： 可以灵活的配置过期规则 简洁，cookie中存储的是最简单的键值对格式的文本数据 数据的持久性，保存到浏览器中的cookie在过期之前是持久存储的 限制： 存储数据的大小，大多浏览器支持4k、8k的数据存储 用户可以通过浏览器设置禁用Cookie，因此限制了cookie的使用场景（如果一定要使用cookie，可以检查浏览器cookie是否可用，如果不可用提醒用户设置开启cookie） cookie是存储在客户端浏览器中的，有被纂改的风险，有潜在的安全隐患 5.7 HttpSession对象5.7.1 Session概述 Session对象，就是当浏览器向服务器发送请求建立连接后，由服务器创建的存储在服务器端的用于记录用户状态对象。 5.7.2 Session特性 服务器会为每个客户端连接分配一个Session对象，存储在服务器上； 同一个浏览器发送多次请求，同属于一次会话，共享同一个Session对象； 5.7.3 Session原理问题：HTTP请求时无状态的，那么同一个浏览器的多次请求为什么能够使用同一个Session对象，如何实现的？ 结论：借助于Cookie让浏览器多次请求共享同一个Session Session原理： 当客户端浏览器(第一次)请求服务器时，服务器会为当前客户端连接创建一个Session对象，同时将sessionID通过Cookie响应给客户端，并存储在客户端； 当客户端端再次请求服务器的时候，会通过请求头携带存储sessionID的cookie，服务器接收请求之后获取cookie中的sessionID，通过这个sessionID获取第一次连接时创建Session对象。 5.7.4 获取Session对象 当用户连接到服务器时，服务器会为这个用户连接创建一个session对象，在Servlet类中可以通过request对象调用getSession()方法获取当前用户连接的Session对象。 1234567// session对象是 javax.servlet.http.HttpSession接口的对象//1.获取session对象// getSession() : 获取当前用户连接HttpSession session = request.getSession();// getId() : 获取sessionIDString sessionId = session.getId(); 5.7.5 Session对象数据操作1.向session对象存储数据123//2.将数据保存到session对象，session对象的数据结构底层维护的就是一个Map，可以存放多个键值对session.setAttribute(&quot;key1&quot;,&quot;Hello QF!&quot;);session.setAttribute(&quot;key2&quot;,&quot;Java&quot;); 2.从session对象获取数据123//3.从session对象中取数据，根据key获取valueString s1 = (String) session.getAttribute(&quot;key1&quot;);System.out.println(&quot;SecondServlet:&quot;+s1); 3.修改session对象数据12//4.修改session数据，如果key存在，则表示修改session中这个key的值session.setAttribute(&quot;key1&quot;,&quot;千锋武汉！&quot;); 4.删除session对象数据12//5.删除session中 key1的键值对session.removeAttribute(&quot;key1&quot;); 5.7.6 session对象失效 一个客户端的多次请求正常情况下获取到的是同一个session对象，也是正式因为多次请求获取的是同一个session对象才实现了session中存储的用户状态可以作用于请求。 如果session失效，将会导致session失效的后的请求无法获取之前的session对象，也就是说多次请求获取的不是同一个session。 导致session失效的原因有2种： 客户端禁用Cookie，或者客户端在两次请求之间清除了cookie，将导致下一次请求无法获取上一次请求创建的Cookie； session是有生命周期的，当客户端请求服务器建立连接之后，服务器会为此会话创建session对象，如果客户端的两次请求时间间隔&gt;session过期时间（默认30min），服务器会将之前创建的session对象销毁； session失效解决方案： 如果客户端禁用了Cookie：不能通过cookie来记录、传递sessionId， 我们可以通过重写URL，使用url传递sessionID（在url上追加sessionId） 如果session过期：我们可以根据系统的需求灵活设置session的生命周期或者手动销毁session对象 123456//设置session对象的过期时间（单位:s）//设置session过期时间10s：当客户端的两次请求时间&gt;10s,session将会被销毁session.setMaxInactiveInterval(10);//手动销毁session对象session.invalidate(); 5.7.7 使用session实现用户登录验证 在一个软件系统中，有很多资源是需要用户登录之后才可以请求访问的（受限资源） 步骤： 当用户登录成功之后，将用户信息保存到当前用户连接的session对象中； 12345678//CheckServlet//当学生登录成功，将学生信息存储到sessionHttpSession session = request.getSession();session.setAttribute(&quot;stu&quot;,student);//重定向到IndexPageServletresponse.sendRedirect(&quot;IndexPageServlet&quot;); 当用户访问受限资源时，先检查session中是否有用户信息： 如果有用户信息则表示当前用户已经登录，可以继续访问 如果session中没有用户信息，表示用户未登录或session过期，则跳转到登录页面，提示用户登录。 123456789HttpSession session = request.getSession();Student stu = (Student) session.getAttribute(&quot;stu&quot;);if(stu == null)&#123; //从session没有获取stu,则提示重新登录 request.setAttribute(&quot;tips&quot;,&quot;请先登录！&quot;); request.getRequestDispatcher(&quot;login&quot;).forward(request,response);&#125;else&#123; //响应&#125; 5.7.8 request与session的区别 request对象用于获取用户的请求数据，作用于浏览器和服务器的一次请求； session对象用于记录当前用户的状态，作用于一个客户端的多次请求； 场景1：浏览器请求ServletA，ServletA转发到ServletC ServletC与ServletA同属于一次请求，共享同一个request对象，都可以通过request获取浏览器提交的数据 场景2：浏览器请求ServletB，ServletB重定向到ServletD 重定向到ServletD，ServletB与ServletD是浏览器的两次请求，ServletD中的request与ServletB是不同的对象 5.8 ServletContext对象5.8.1 ServletContext对象介绍 HttpServletRequest对象作用于一次用户请求，获取用户数据 HttpSession对象作用于一个用户的多次请求，实现数据共享 ServletContext对象作用域整个web项目，实现多个用户之间的数据共享 ServletContext是Javaweb项目的全局对象，包含当前web项目在web服务器中的信息，同时它也是一个域对象，可以实现访问当前web项目的所有用户之间的数据共享。 5.8.2 通过ServletContext对象获取web应用信息12345678910//ServletContext对象 —— Servlet上下文对象//1.获取ServletContext对象ServletContext servletContext = getServletContext();//2.通过ServletContext对象获取当前web应用的上下文路径// 就是当前web应用在web服务器上的访问路径String contextPath = servletContext.getContextPath();//3.通过ServletContext对象获取web项目中的目录在 服务器上的绝对路径String realPath = servletContext.getRealPath(&quot;/files&quot;); 5.8.3 通过ServletContext对象实现全局数据共享12345678//1.将数据存储到全局对象servletContext.setAttribute(&quot;ckey&quot;,value);//2.根据key从全局对象取数据Object v = servletContext.getAttribute(&quot;ckey&quot;);//3.从全局对象移出数据servletContext.removeAttribute(&quot;ckey&quot;); 5.8.4 ServletContext对象特性 ServletContext是当前web项目的全局上下文对象，可以被多个用户请求共享； ServletContext在服务器启动的时候创建，当服务器关闭或者将项目从服务器移出时销毁ServletContext对象； ServletContext可以实现 在线人数统计等需要全局存储的场景。 5.8.5 通过ServletContext对象获取全局参数 在web.xml可以配置当前web应用的全局参数，在服务器启动的时候会加载web.xml 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 配置上下文参数 ： 键值对 --&gt; &lt;context-param&gt; &lt;param-name&gt;key1&lt;/param-name&gt; &lt;param-value&gt;HelloWorld&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;key2&lt;/param-name&gt; &lt;param-value&gt;wahaha&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; 在Servlet类中，可以通过ServletContext对象读取初始化参数： 123456//通过ServletContext对象获取web.xml中配置的全局参数// getInitParameterNames()：获取web.xml中全局参数所有的key[key1,key2]Enumeration&lt;String&gt; keys = servletContext.getInitParameterNames();// getInitParameter(key): 根据key获取valueString v1 = servletContext.getInitParameter(&quot;key1&quot;); 5.9 ServletConfig对象 ServletConfig对象表示的一个Servlet在web服务器的配置信息 Servlet类通过web.xml配置方式可以配置Servlet类的初始化参数： 123456789101112131415161718&lt;!-- xml方式配置Servlet，可以配置当前Servlet的初始化参数 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.qfedu.servlets.TestServlet&lt;/servlet-class&gt; &lt;!-- Servlet类的初始化参数 --&gt; &lt;init-param&gt; &lt;param-name&gt;key3&lt;/param-name&gt; &lt;param-value&gt;hahaha&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;key4&lt;/param-name&gt; &lt;param-value&gt;hehehe&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/TestServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在TestServlet类中获取当前类的ServletConfig对象，并通过对象获取类路径、加载初始化参数 123456789101112131415//1.获取ServletConfig对象//getServletConfig() : 获取当前Servlet类的ServletConfig对象ServletConfig servletConfig = getServletConfig();//2.通过ServletConfig获取当前Servlet类路径String servletName = servletConfig.getServletName();//3.通过ServletConfig对象加载当前Servlet类的初始化参数//getInitParameterNames 获取当前Servlet所有初始化参数的keyEnumeration&lt;String&gt; names = servletConfig.getInitParameterNames();//getInitParameter 根据key获取valueString v3 = servletConfig.getInitParameter(&quot;key3&quot;);System.out.println(&quot;TestServlet:&quot;+v3); 六、过滤器6.1 过滤器介绍 过滤器(Filter)是位于客户端与服务器资源之间的一道过滤技术，可以在客户端请求到达目标资源之前进行预处理业务。 过滤器作用 执行多个Servlet公共的代码，解决了代码的冗余性问题，提高代码复用性（例如首先资源的登录验证）； 6.2 过滤器使用6.2.1 创建过滤器 在doFilter编写过滤业务规则，如果允许继续访问，则通过filterChain.doFilter(servletRequest,servletResponse);让客户端请求继续访问；如果不允许通行则可以通过servletResponse直接响应客户端（转发、重定向）。 1234567891011121314151617181920212223242526272829303132333435package com.qfedu.filters;import javax.servlet.*;import java.io.IOException;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 * 1.创建一个类实现javax.servlet.Filter接口 * 2.实现Filter接口中的init、doFilter、destroy抽象方法 * init 是过滤器初始化方法，用于获取过滤器的初始化参数等 * destory 是过滤器的销毁方法，用以释放资源 * doFilter 方法 用于定义过滤器的业务 * 3.在doFilter实现过滤器业务 */public class MyFilter01 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;~~~~~~MyFilter01&quot;); //放行:运行继续执行浏览器请求的目标资源 filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 6.2.2 配置过滤器 配置过滤器拦截哪些服务器资源 xml配置 123456789&lt;filter&gt; &lt;filter-name&gt;MyFilter01&lt;/filter-name&gt; &lt;filter-class&gt;com.qfedu.filters.MyFilter01&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;MyFilter01&lt;/filter-name&gt; &lt;!--过滤器的拦截规则--&gt; &lt;url-pattern&gt;/FirstServlet&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注解配置：在过滤器类添加@WebFilter注解 1234@WebFilter(&quot;/*&quot;)public class MyFilter01 implements Filter &#123; //...&#125; 6.2.3 过滤器路径配置规则精确过滤： 配置过滤器拦截指定的请求url 例如：&#x2F;FirstServlet，&#x2F;index.html 后缀过滤： 配置过滤器拦截指定的后缀的请求url 例如：*.jpg 、 *.html 通配符过滤： &#x2F;* 拦截所有请求 &#x2F;aaa&#x2F;bbb&#x2F;* 拦截项目名后 demo8/aaa/bbb/FirstServlet 或者 demo8/aaa/bbb/a.html 6.3 前置过滤器与后置过滤器 根据过滤器在目标资源执行的时机，我们可以将过滤器分为三类： 前置过滤器：过滤器在目标资源之前执行 后置过滤器：过滤器在目标资源之后执行 环绕过滤器：执行目标资源之前会执行过滤器，目标资源执行之后还会执行过滤器 如何设置前置、后置、环绕过滤器？ 在过滤器的doFilter方法中，写在放行代码（filterChain.doFilter(...)）业务会在目标资源执行之前执行，写在放行代码后面的业务，则会在目标资源执行之后执行 1234567891011121314151617181920@WebFilter(&quot;/FirstServlet&quot;)public class MyFilter01 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;~~~~~~before&quot;); //放行:运行继续执行浏览器请求的目标资源 filterChain.doFilter(servletRequest,servletResponse); System.out.println(&quot;~~~~~~after&quot;); &#125; @Override public void destroy() &#123; &#125;&#125; 6.4 过滤器链6.4.1 过滤器链介绍 在同一个服务器资源（Servlet类）上可以添加多个过滤器，当用户请求资源时，会依次执行每一个过滤器，然后再执行目标资源，再依次通过过滤器响应客户端请求。 6.4.2 过滤器的优先级 过滤器优先级：在一个web项目中如果配置多个过滤器，多个过滤器的先后执行顺序 如果多个过滤器都是使用注解配置的，则按照过滤器类的名称字符串的字典顺序执行； 如果多个过滤器都是在web.xml中配置的，则按照web.xml配置的先后顺序执行； web.xml中配置的过滤器优先级高于注解配置； 如果同一个过滤器通过注解及web.xml两种方式都进行了配置，过滤器会执行多次。 6.5 过滤器应用案例6.5.1 编码过滤器123456789101112131415161718192021222324252627282930package com.qfedu.utils;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;/** * @Description 编码过滤器 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebFilter(&quot;/*&quot;)public class EncodingFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; //对request请求数据进行编码设置 servletRequest.setCharacterEncoding(&quot;utf-8&quot;); //请求放行 filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 6.5.2 登录验证过滤器1.实现流程 2.登录过滤器代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.qfedu.sgms.utils;import com.qfedu.sgms.dto.Student;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;/** * @Description 登录验证过滤器 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebFilter(&quot;/*&quot;)public class LoginFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; //1.因为此过滤器会拦截所有用户请求（包括受限资源和非受限资源） // 所以当一个用户请求被拦截之后，我们需要知道这个请求的路径 // a.将ServletRequest转换成 HttpServletRequest HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; // b.通过request对象获取用户的请求路径 String uri = request.getRequestURI(); // ---- /demo4/IndexPageServlet // c.截取uri最后一个/后的路径，即为请求路径 String requestPath = uri.substring( uri.lastIndexOf(&quot;/&quot;)+1 ); System.out.println(&quot;requestPath:&quot;+requestPath); //2.判断：如果请求路径是非受限资源则直接放行，如果是受限资源则需要验证用户是否登录 if(&quot;CheckServlet&quot;.equals(requestPath) || &quot;login&quot;.equals(requestPath))&#123; //放行 filterChain.doFilter(servletRequest, servletResponse); &#125;else&#123; //进入else代码，表示此请求是受限资源，需要验证用户是否登录 //3.判断session中是否有用户信息，如果有则表示用户已经登录——放行 // 如果没有则表示用户未登录，转发到登录页面，提示请先登录 HttpSession session = request.getSession(); Student stu = (Student) session.getAttribute(&quot;stu&quot;); if(stu != null)&#123; filterChain.doFilter(servletRequest, servletResponse); &#125;else&#123; //转到到登录页面 request.setAttribute(&quot;tips&quot;,&quot;请先登录！&quot;); request.getRequestDispatcher(&quot;login&quot;).forward(request,response); &#125; &#125; &#125; @Override public void destroy() &#123; &#125;&#125; 七、Servlet应用7.1 文件上传 客户端提交文件（图片&#x2F;ppt&#x2F;doc&#x2F;md…）到Servlet类，Servlet类该如何接收并保存文件呢 ？ 7.1.1 文件上传案例流程 7.1.2 准备工作 创建一个Java web工程：serlvet-demo9 在web工程的 web 目录创建一个 book-add.html的网页文档，提供图书添加界面 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图书添加页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;添加图书信息&lt;/h3&gt; &lt;form action=&quot;&quot; method=&quot;&quot;&gt; &lt;p&gt;图书编号：&lt;input type=&quot;text&quot; name=&quot;bookId&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书封面：&lt;input type=&quot;file&quot; name=&quot;bookImg&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 创建BookSaveServlet类： 1234567891011121314151617181920212223242526272829package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Description 接收图书信息并保存 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/BookSaveServlet&quot;)public class BookSaveServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; 创建图书实体类：Book 123456789101112/** * @Description 图书信息实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Book &#123; private String bookId; private String bookName; private String bookImgPath; &#125; 创建保存图书信息操作的DAO类：BookDAO 7.1.3 文件上传实现1.前端提交文件 表单post方式提交数据 设置表单的enctype&#x3D;”multipart&#x2F;form-data”，不对表单数据进行编码 1234567891011121314&lt;!--当form表单数据提交时，浏览器会对表单数据进行编码，然后提交；当表单中存在文件的时候，要设置不编码传输通过form表单的enctype属性设置表单数据的压缩方式：- application/x-www-form-urlencoded 在发送前编码所有字符（默认）- text/plain 将表单数据空格转换成+，不对特殊字符进行编码- multipart/form-data 不对表单数据进行编码--&gt;&lt;form action=&quot;BookSaveServlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt;图书编号：&lt;input type=&quot;text&quot; name=&quot;bookId&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书封面：&lt;input type=&quot;file&quot; name=&quot;bookImg&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/p&gt;&lt;/form&gt; 2.Servlet类接收文件 在Servlet类前添加@MultipartConfig注解，赋予当前Servlet类处理未编码提交的数据的能力； 通过request对象调用getPart(key)或者getParts()方法接收文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.MultipartConfig;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.Part;import java.io.IOException;import java.util.Collection;/** * @Description 接收图书信息并保存 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/BookSaveServlet&quot;)@MultipartConfigpublic class BookSaveServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置utf-8编码 request.setCharacterEncoding(&quot;utf-8&quot;); //2.接收普通文本//当网页提交数据的表单设置了enctype=&quot;multipart/form-data&quot;之后不能直接使用getParameter接收文本数据 //需要在当前serlvet类添加 @MultipartConfig 用于处理非压缩提交的数据 String id = request.getParameter(&quot;bookId&quot;); String name = request.getParameter(&quot;bookName&quot;); System.out.println(&quot;id:&quot;+id ); System.out.println(&quot;name:&quot;+name ); //3. 接收表单提交的图片 // getPart(&quot;输入框name属性&quot;): 接收表单中的文件 Part bookImg = request.getPart(&quot;bookImg&quot;); System.out.println(bookImg); // getParts(): 接收表单中所有文件 //Collection&lt;Part&gt; parts = request.getParts(); //4.保存图片 &#125;&#125; 3.保存图片 在web工程的web目录下新建一个files目录（保存文件的目录如果不在web服务器上，用户将无法访问） 在files目录先放一个任意的文件（空的目录在进行项目部署的时候不会在web服务器中创建） 123456789101112131415161718192021//4.保存图片// a.获取files目录在web服务器上的路径（不是工作空间的路径）ServletContext servletContext = getServletContext();String dir = servletContext.getRealPath(&quot;/files&quot;);// b.给上传的文件重命名 （不同用户有可能上传相同名称的图片，如果不重命名将导致文件覆盖）// 文件重命名后缀名不能改变String header = bookImg.getHeader(&quot;Content-Disposition&quot;); //form-data; name=&quot;bookImg&quot;; filename=&quot;千锋武汉（横版）.jpg&quot;// 截取上传的文件的后缀名int begin = header.lastIndexOf(&quot;.&quot;);int end = header.lastIndexOf(&quot;\\&quot;&quot;);String ext = header.substring(begin, end);// 取名（时间毫秒数、UUID、雪花算法）String fileName = UUID.randomUUID().toString()+ext;//c.存储文件到目录bookImg.write(dir+&quot;\\\\&quot;+fileName);//5.将图书信息保存到数据库: 保存到数据库的是图片的访问路径（不是绝对路径）Book book = new Book(id, name, &quot;files/&quot; + fileName);//调用BookDAO 将book对象保存到数据库 7.2 文件下载 客户端向服务器发送请求，服务器将客户端请求的文件响应给客户端。 7.2.1 文件下载案例流程 7.2.2 案例准备工作 在项目的files目录添加几个待下载的图片 创建文件下载的Servlet类FileDownloadServlet 创建文件列表的静态网页：在web目录下创建file-list.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;files/img01.png&quot; height=&quot;100&quot;/&gt;&lt;br/&gt; &lt;a href=&quot;FileDownloadServlet?fileName=img01.png&quot;&gt;下载&lt;/a&gt;&lt;br/&gt; &lt;img src=&quot;files/img02.png&quot; height=&quot;100&quot;/&gt;&lt;br/&gt; &lt;a href=&quot;FileDownloadServlet?fileName=img02.png&quot;&gt;下载&lt;/a&gt;&lt;br/&gt; &lt;img src=&quot;files/img03.png&quot; height=&quot;100&quot;/&gt;&lt;br/&gt; &lt;a href=&quot;FileDownloadServlet?fileName=img03.png&quot;&gt;下载&lt;/a&gt;&lt;br/&gt; &lt;/body&gt;&lt;/html&gt; 7.2.3 文件下载实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.qfedu.servlets;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/FileDownloadServlet&quot;)public class FileDownloadServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收客户端传递过来的文件名（即为要下载的文件） String fileName = request.getParameter(&quot;fileName&quot;); //img01.png //2.获取存储文件的files目录路径 ServletContext servletContext = getServletContext(); String dir = servletContext.getRealPath(&quot;/files&quot;); // 拼接要下载的文件路径 String filePath = dir+&quot;\\\\&quot;+fileName; //3.设置响应头 //设置响应的类型如果浏览器无法识别则会提示另存为 response.setContentType(&quot;application/image&quot;); response.addHeader(&quot;Content-Disposition&quot;,&quot;attachment; fileName=&quot;+fileName); //4. 通过IO流将文件数据响应给浏览器（文件是二进制数据，所以获取字节流） ServletOutputStream outputStream = response.getOutputStream(); // 读取服务文件，写给客户端 FileInputStream fis = new FileInputStream(filePath); byte[] bs = new byte[1024]; int len = -1; while( (len = fis.read(bs))!=-1)&#123; outputStream.write(bs,0,len); &#125; outputStream.close(); fis.close(); &#125;&#125; 7.3 验证码7.3.1 什么是验证码？ 在应用系统用户登录、用户注册的功能中，使用验证码用于避免客户端通过暴力破解的形式获取用户信息，提高用户信息的安全性。 7.3.2 验证码生成流程 7.3.3 验证码生成实现 创建新的Javaweb工程：servlet-demo10 项目的web目录创建login.html,提供登录界面视图： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;用户登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;p&gt;账号：&lt;input type=&quot;text&quot; name=&quot;userName&quot;/&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;userPwd&quot;/&gt;&lt;/p&gt; &lt;p&gt; 验证码： &lt;input type=&quot;text&quot; name=&quot;userCode&quot; maxlength=&quot;4&quot;/&gt; &lt;img src=&quot;&quot; height=&quot;30&quot; width=&quot;100&quot; /&gt; &lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 创建生成验证码的Servlet类：ValidateCodeServlet 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.qfedu.servlets;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;/** * @Description 生成验证码图片 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/ValidateCodeServlet&quot;)public class ValidateCodeServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //接收客户端请求，生成一个验证码图片，响应给客户端 // 使用Java中提供的 awt 工具包动态生成一个验证码图片 //1.创建一张图片 int width = 300; //验证码宽度 int height = 90; //验证码高度 BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2.绘制图片 , 从图片对象中获取绘制图片的 “笔” Graphics2D pen = image.createGraphics(); //a.绘制背景 pen.setColor(getRandomColor()); //fillRect: 绘制实心矩形 pen.fillRect(0,0,width,height); //b.绘制验证码字符串 int letterNum = 4; //验证码图片上的字符的个数 int space = 20; // 验证码图片上两个字母之间的空隙 int letterWidth = ( width-(letterNum+1)*space )/letterNum; //计算每个字母占据的宽度 //for循环每循环一次，绘制一个字母 （小写字母的ascii码 97-122） Random random = new Random(); for(int i=0; i&lt;letterNum ; i++)&#123; //随机生成一个小写字母： int ascii = random.nextInt(26) + 97; //97-122 byte[] bs = &#123;(byte)ascii&#125;; String letter = new String(bs); //drawString: 绘制字母 pen.setColor(getRandomColor()); pen.setFont( new Font(&quot;Gulim&quot;,Font.BOLD,70) ); pen.drawString(letter, space+(letterWidth+space)*i,height-space); &#125; // 为了让图片不是那么容易被程序识别，可以绘制干扰线、干扰图形 //图片绘制完成之后，将图片通过 response的输出流响应到客户端 ImageIO.write(image,&quot;png&quot;,response.getOutputStream()); &#125; /** * 产生一种随机颜色 */ private Color getRandomColor()&#123; Random random = new Random(); int r = random.nextInt(256); int g = random.nextInt(256); int b = random.nextInt(256); Color color = new Color(r, g, b); return color; &#125;&#125; 修改登录页面验证码图片的src属性，请求验证码Servlet类 1&lt;img src=&quot;ValidateCodeServlet&quot; height=&quot;30&quot; width=&quot;100&quot; /&gt; 7.3.4 点击验证码图片切换验证码 点击验证码图片，触发JS代码，重新请求验证码Servlet类 7.3.5 验证码验证流程 7.3.6 验证流程实现 在ValidateCodeServlet中生成验证码时，将验证码存入到session ValidateCodeServlet 创建验证用户登录的Servlet类LoginCheckServlet 修改登录页面提交数据到LoginCheckServlet login.html 在 LoginCheckServlet中接收用户输入的帐号、密码、验证码，对验证码进行校验 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;/** * @Description 校验验证码 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/LoginCheckServlet&quot;)public class LoginCheckServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收帐号、密码、验证码 String userName = request.getParameter(&quot;userName&quot;); String userPwd = request.getParameter(&quot;userPwd&quot;); String userCode = request.getParameter(&quot;userCode&quot;); //2.从session取出生成验证码时存储的正确的验证码 HttpSession session = request.getSession(); String vCode = (String) session.getAttribute(&quot;vCode&quot;); //3.将用户输入的验证码和从session取出的正确的验证码进行对比 if(userCode.equals(vCode))&#123; //验证码正确,继续校验帐号和密码 //... System.out.println(&quot;---验证码正确&quot;); &#125;else&#123; //验证码错误,转发到登录页面，并提示验证码错误 //（在此案例中登录页面是用html实现的，不能显示提示信息） System.out.println(&quot;---验证码错误&quot;); &#125; &#125;&#125;","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://example.com/tags/Servlet/"}]},{"title":"day06-JavaScript","slug":"day06-JavaScript","date":"2022-09-16T15:29:39.000Z","updated":"2022-10-06T03:16:18.355Z","comments":true,"path":"2022/09/16/day06-JavaScript/","link":"","permalink":"http://example.com/2022/09/16/day06-JavaScript/","excerpt":"","text":"HTML 决定了网页中的内容 CSS 决定网页内容的显示效果 JavaScript 决定了网页中标签的功能及动态效果 一、JavaScript介绍1.1 JavaScript简介 JavaScript是一种基于对象的、事件驱动型的、解释型的脚本语言 基于对象：（区别于面向对象），JavaScript和Java语言一样可以通过对象调用方法 obj.fn() 事件驱动：网页文档中的HTML标签事件触发JavaScript代码执行 解释型：边解释边执行（不会先对网页进行编译生成中间文件） 脚本语言：JavaScript不会独立运行，依赖于网页文件（HTML文档）存在 （通俗的理解为js要写在网页中） 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .btnStyle&#123; width: 200px; height: 35px; background: lightcoral; border: none; border-radius: 5px; color: white; font-weight: bold; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test()&#123; alert(&quot;Hello World!&quot;); //弹窗提示 var m = 10/0; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;测试按钮&quot; class=&quot;btnStyle&quot; onclick=&quot;test()&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 1.2 JavaScript的发展史 JS是一种嵌入在网页中的脚本语言，网页是通过浏览器加载并显示的，因此JS的执行是在浏览器中完成的；对于浏览器而言，它能够执行JS代码，在浏览器中内置了JavaScript解释器（JavaScript引擎） JavaScript是在1995年由一个知名的浏览器厂商Netscape（网景）公司的Brench Eich，基于网景导航者浏览器设计开发而来的，这个脚本语言最开始命名为LiveScript，后来基于Netscape与sun公司的合作以及LiveScript知名度比较低，后来就改名为JavaScript。 JavaScript的设计是为了完成网页文件的交互功能。 JavaScript是基于ECMAScript标准设计的，截止到2012，ECMAScript5.1标准已经普及；2015年，ECMAScript6的标准发布，目前大部分浏览器兼容ES6，但是为了保证浏览器对JavaScript普适性的支持，在JavaScript学习和使用中，更多的使用ES5标准规定的语法。 1.3 JavaScript作用 JS设计的目的是实现网页的交互能力 1.3.1 JS可以干什么？ 可以动态改变网页中HTML标签的属性 可以动态改变网页中HTML标签的样式 可以对用户输入的数据进行合法性校验（格式检查） 可以动态操作（新增HTML标签、删除HTML标签、修改HTML标签）网页中的HTML标签 可以实现页面数据的异步通信 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test()&#123; //操作HTML标签的属性 document.getElementById(&quot;img1&quot;).width = 200; document.getElementById(&quot;img1&quot;).height = 200; //操作HTML标签的样式 document.getElementById(&quot;img1&quot;).style.borderRadius = &quot;50%&quot;; //移出HTML标签（DOM操作） document.getElementById(&quot;img1&quot;).remove(); //数据的异步交互 &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=&quot;img1&quot; src=&quot;imgs/img01.png&quot; width=&quot;&quot;/&gt; &lt;br/&gt; &lt;input type=&quot;button&quot; value=&quot;测试按钮&quot; onclick=&quot;test()&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 1.3.2 JS不能干什么？ JS虽然是在用户的浏览器中执行，但是JS不能访问用户的本地文件； JS不能操作来自于不同服务的网页文档 二、第一个JavaScript程序2.1 JavaScript写在哪里？ JS代码写在HTML文档的script标签中，script可以写在HTML文档的任何位置，通常写在body标签后，或者body标签中的最后面，并且一个HTML文档中支持多个script标签 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //JS代码 &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; // JS代码 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JS代码也可以单独写在一个后缀名为.js的文件中，在HTML文档中通过script标签引用此JS文件 JavaScript代码写在JS文件中 引用JS文件的script标签不能自定义JS代码 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- script标签可以引用一个JS文件，也可以自定义JS代码实现： 1.如果script用来引用一个JS文件，script必须为双标签 2.script标签用来引用JS文件之后，则当前script标签中就不能再自定义JS代码 3.如果引用JS文件，还要进行自定JS代码实现，需要重新写一个script标签 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/test.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; //自定义JS代码 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.2 JavaScript函数（方法）定义 我们将实现某个功能的JavaScript代码定义在一个函数中 函数的定义语法： 123function &lt;fnName&gt;([参数])&#123; //Javascript代码&#125; 示例：（js&#x2F;test.js） 1234function test()&#123; //相当于Java程序中 System.out.println(&quot;Hello World!&quot;); 浏览器控制台输出 console.log(&quot;Hello World!&quot;);&#125; 2.3 JavaScript函数如何运行 通过HTML文档中的事件触发 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/test.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;test()&quot;&gt;测试按钮&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 2.4 查看浏览器的控制台输出 主流的浏览器点击F12按键 三、JavaScript基础语法 变量、数据类型 表达式、流程控制 3.1 变量与数据类型3.1.1 数据类型 Java是强类型语言：存储不同类型的值的变量声明时，需要声明为不同的类型 12int i = 5;String s = &quot;abc&quot; ; JavaScript是弱类型语言： 变量无论存储什么类型的值，我们一律使用var进行变量类型声明 一个变量可以设置不同类型的值 变量声明使用统一var类型，但是变量中存储的值是有类型的 1234567var i = 5; i = &quot;hello&quot;;var s = &quot;abc&quot;;var i = 5;var j = &quot;5&quot;;console.log(i+1); //输出 6console.log(j+1); //输出 51 3.1.2 变量 在JS代码如果要使用一个变量，需要先声明 声明一个变量需要指定其类型，所有变量都可以使用 var 如果一个变量只完成声明而没有初始化（赋初始值），则会输出undefined 3.1.3 不同类型变量值的初始化 字符串 1234var s = &quot;hello&quot;;var s = &#x27;hello&#x27;;var s = &quot;My name is &#x27;ergou&#x27;&quot;;var s = &#x27;My name is &quot;ergou&quot;&#x27;; 数字 123var i = 12; //整数var j = 3.14; //小数var k = 10e5; //科学计数法 布尔 12var b1 = true;var b2 = false; 数组 1234567var arr1 = new Array(); // JS中创建数组是不需要指定长度的arr1[0] = &quot;aaa&quot;;arr1[1] = &quot;bbb&quot;;var arr2 = new Array(&quot;aaa&quot;,&quot;bbb&quot;);var arr3 = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;]; 对象 123// JS中&#123;&#125;就表示对象类型，JS对象的属性名可以直接定义，并且对象的属性支持扩展//1.定义stu对象有两个属性var stu = &#123;stuNum:&quot;10001&quot;,stuName:&quot;王二狗&quot;&#125;;//2.对象号之后扩展一个属性stu.stuGender = &quot;男&quot;; undefined和null 如果一个变量只声明，没有初始化，输出undefined（undefined表示变量没有值） 通过将一个变量值设置为null来清空一个变量的值 12var i; //如果直接输出，输出为 undefinedi = &quot;aaa&quot;;i = null; //将i的值设置null，来清空i变量 3.2 表达式(运算符) 表达式就是由变量和运算符组合而成的代码 3.2.1 算术运算符 进行算术运算 +、-、*、&#x2F;除法、%取模 ++ 、– 3.2.2 赋值运算符 将值赋值给变量 &#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D; 1int i = 5;i+=3; //===&gt; i = i+3; 3.2.3 字符串拼接+12//1.如果+的两端都是数值，+就表示算术运算符//2.如果+有一端是字符串类型值，+就表示字符串拼接var = i+j; 3.2.4 关系运算符 用于比较两个值的大小关系 &gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、&#x3D;&#x3D; 、!&#x3D;、&#x3D;&#x3D;&#x3D;(绝对等于：值和类型都相同) 3.2.5 逻辑运算符 与或非，用于连接两个逻辑条件 &amp;&amp; 与 ||或 ! 非 3.2.6 三目运算符1// 当条件成立时，将v1的值赋值给变量i，如果条件不成立，则将v2赋值给变量ivar i = 条件?v1:v2; 3.3 流程控制3.3.1 分支语句 当满足不同的条件时，执行不同的代码块 if语句 单分支 123if(条件)&#123; //代码：当条件成立时执行代码&#125; 双分支 1234567//如果条件成立则执行代码1，不成立则执行代码2 //程序员的浪漫：世界上最遥远的距离不仅是生与死的距离，还有我的if你在else，永远相伴但不相见if(条件)&#123; //代码1 &#125;else&#123; //代码2&#125; 多分支 12345678910111213141516//当条件1成立，则执行代码1，不在判断后续条件//当条件1不成立，则判断条件2，条件2成立，则执行代码2，条件2不成立则继续判断条件3....直到找到第一个成立的条件//如果所有的条件都不成立，则执行else代码块 if(条件1)&#123; //代码1&#125;else if(条件2)&#123; //代码2&#125;else if(条件3)&#123; //代码3&#125;...&#123; //...&#125;else if(条件n)&#123; //代码n&#125;else&#123; //代码m&#125; switch语句 如果case代码后面没有break：当变量n的值与某个case的值相等时，从当前case的代码开始执行，直到遇到break关键字，如果没有break则会从当前case的位置一直执行到switch代码块结束 12345678910111213141516171819//判断 变量n 的值是否等于v1，如果相等则执行代码1；如果不相等则判断 变量n 的值是否等于v2//哪个case后面的值与 变量n相等，就执行哪个case的代码，如果所有case的值与n都不相等，则执行default的值switch(n)&#123; case v1: 代码1; break; case v2: 代码2; break; case v3: 代码3; break; ... case vN: 代码N; break; default: 代码M;&#125; 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;test1()&quot;&gt;测试按钮&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test1()&#123; var n = 5; switch(n)&#123; case 1: console.log(&quot;春天&quot;); break; case 2: console.log(&quot;夏天&quot;); break; case 3: console.log(&quot;秋天&quot;); break; case 4: console.log(&quot;冬天&quot;); break; default: console.log(&quot;未知季节&quot;); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.3.2 循环语句 当满足特定条件时，重复执行同一个代码块 for循环 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testFor()&quot;&gt;测试FOR&lt;/button&gt; &lt;button onclick=&quot;testForIn()&quot;&gt;测试ForIn&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testFor()&#123; for(var i=0 ; i&lt;10 ; i++) &#123; console.log(&quot;★&quot;); &#125; &#125; //遍历JS对象和数组 function testForIn()&#123; var stu = &#123;stuNum:&quot;10001&quot;,stuName:&quot;张三&quot;,stuGender:&quot;男&quot;&#125;; //1.遍历对象的属性名 for(v in stu)&#123; //根据对象属性名，从对象中获取属性值 console.log(v+&quot;：&quot;+stu[v]); &#125; //2. 遍历数组的索引 var arr = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;]; for(i in arr)&#123; //根据索引从数组中获取值 console.log(arr[i]); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; while循环 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testWhile()&quot;&gt;测试while&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testWhile()&#123; //注意：while循环，需要根据业务在循环体中修改循环条件变量 var i = 0; while(i&lt;10)&#123; console.log(i+&quot;★&quot;); i++; &#125; //do while ： 无论条件是否成立，都先执行一次循环体代码 // 然后判断条件是否成立，如果成立则继续执行下一次 var j = 10; do&#123; console.log(&quot;☆&quot;); j++; &#125;while(j&lt;10); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.3.3 break 和 continue break 和 continue都可以用来中断&#x2F;终端循环: break终止循环：跳出循环 continue中止循环：停止本次循环体的执行，进入到下一次循环 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testBreakAndContinue()&quot;&gt;测试break和continue的区别&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testBreakAndContinue()&#123; // break终止循环：跳出循环 for (var i = 1; i &lt;= 10; i++) &#123; if(i == 5)&#123; break; &#125; console.log(&quot;~~~~&quot;+i); &#125; // continue中止循环：停止本次循环体的执行，进入到下一次循环 for (var i = 1; i &lt;= 10; i++) &#123; if(i == 5)&#123; continue; &#125; console.log(&quot;----&quot;+i); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.4 JavaScript错误处理 当JS引擎执行JS代码的过程中，因为代码错误、数据错误、系统资源等问题都可能导致JS执行过程中的异常 JS中的异常处理机制： try：检查其包含的JS代码是否出现错误 catch：处理JS中的错误（异常） finally：无论是否有异常，finally里面的代码总会执行 throw：用于创建自定义错误 JS异常处理语法： 123456789101112try&#123; if(n &gt;= 0)&#123; var age = n; &#125;else&#123; throw &quot;年龄不合法，不能为负数&quot;; &#125; //JS代码 try会检查JS代码是否出现错误，一旦出现错误就停止JS代码的执行，将错误提交给JS引擎&#125;catch(e)&#123; //异常处理代码 JS引擎一旦检测到错误，就停止try中代码的执行，进入到catch代码的执行，进行异常处理&#125;finally&#123; //代码， 无论try中的JS代码是否出现异常，finally里面的代码总会执行 （通常在finally做一些释放资源的工作）&#125; JS错误处理示例： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testError()&quot;&gt;测试错误处理&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testError()&#123; try&#123; console.log(&quot;--------------try&quot;); var m = 10; var n = 2; if(n!=0)&#123; var k = m/n; //JS中变量提升：将变量的声明提升至最全面 &#125;else&#123; throw &quot;n的值不能为0&quot;; //创建自定义错误 （这个地方有错误） &#125; console.log(&quot;K的值为：&quot;+k); &#125;catch(e)&#123; console.log(e); &#125;finally&#123; console.log(&quot;--------------finally&quot;); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 四、JavaScript对象 基于对象——通过对象完成属性、方法的调用 4.1 JavaScript对象创建 在Java中，先定义类，通过类的构造器创建对象，创建的这个类的对象具有类中定义的属性，并且能够调用这个类中定义的方法。 在JS中对象如何创建？ 直接通过{}创建对象 通过构造器创建对象 4.1.1 直接创建JS对象1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS对象&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testObj()&quot;&gt;创建JS对象&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testObj()&#123; //创建对象:通过&#123;&#125;创建对象 //1.定义对象属性：可以直接在&#123;&#125;中指定对象的属性 //2.定义对象方法:也可以直接在&#123;&#125;中定义当前对象的方法 var obj = &#123; id:&quot;101&quot;, name:&quot;zhangsan&quot;, test1:function()&#123; console.log(&quot;----test1&quot;); &#125; &#125;; //通过【对象.属性名】可以调用对象属性 //通过【对象.方法名(参数)】可以调用对象方法 console.log(obj.id); obj.test1(); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.1.2 使用JS构造函数创建对象 在JS中没有类的概念，但是可以定义构造器 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS对象&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testObj2()&quot;&gt;使用构造函数创建JS对象&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; //1.自定义JS构造函数 function Student(num,name)&#123; //1-1.定义属性 this.stuNum = num; this.stuName = name; //1-2.定义方法 this.method1 = function(a)&#123; console.log(&quot;Student---method1:&quot;+a); &#125; this.method2 = myMethod2; &#125; function myMethod2()&#123; console.log(&quot;Student---method2&quot;); &#125; function testObj2()&#123; //2.使用构造函数创建JS对象:通过构造函数创建的对象可以调用构造器中的属性和方法 var s1 = new Student(&quot;1001&quot;,&quot;张三&quot;); console.log(s1); s1.method1(&quot;wahaha&quot;); s1.method2(); var s2 = new Student(&quot;1002&quot;,&quot;李四&quot;); console.log(s2) s2.method1(&quot;hehehe&quot;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.2 JavaScript扩展属性 扩展属性——对象本没有某个属性，但是我们可以对其进行新增 4.2.1 对象扩展属性当对象创建好之后，我们可以通过对象.新属性=属性值;语法给当前对象新增属性，这个新增的属性只有当前对象才可以调用，即使通过同一个构造器创建的其他对象也没有这个属性。 1234567891011121314//定义构造函数，有两个属性function Student(num,name)&#123; this.stuNum = num; this.stuName = name;&#125;function testObj2()&#123; //通过Student构造函数，创建了第一个对象 var s1 = new Student(&quot;1001&quot;,&quot;张三&quot;); //给s1对象扩展 stuGender 属性 s1.stuGender = &quot;男&quot;; console.log(s1); //通过Student构造函数，创建了第二个对象，s1扩展的属性s2是没有 var s2 = new Student(&quot;1002&quot;,&quot;李四&quot;); console.log(s2)&#125; 4.2.2 构造函数扩展属性针对构造器方式创建JS对象，我们还可以扩展构造器的属性，当扩展构造器属性之后，此构造器创建的所有对象都有这个属性。 123456789101112131415161718//定义构造函数，有两个属性function Student(num,name)&#123; this.stuNum = num; this.stuName = name;&#125;function testObj2()&#123; //【构造器扩展属性: 构造器名.prototype.新属性名 = 属性值;】 Student.prototype.stuGender = &quot;男&quot;; //通过Student构造器创建的对象，都有扩展的stuGender属性 var s1 = new Student(&quot;1001&quot;,&quot;张三&quot;); console.log(s1); //输出对象看不到 stuGender属性 console.log(s1.stuGender); // 但是可以通过对象调用stuGender属性 var s2 = new Student(&quot;1002&quot;,&quot;李四&quot;); console.log(s2); console.log(s2.stuGender);&#125; 五、JavaScript内置对象5.1 内置对象介绍5.1.1 什么是JS内置对象？ JS中我们可以自定义构造器，通过自定义构造器创建JS对象。 JavaScript引擎预定义了一些构造器，并且在构造器中定义了能够完成特定功能的函数，通过这些构造器我们可以直接创建对象，创建的对象就可以可以调用函数完成功能。 JS内置对象：就是通过JavaScript预定义构造器创建的对象。 5.1.2 JavaScript中提供了哪些构造器？ 构造器 说明 Array JavaScript中的数组(集合)，在此构造器中定义了可以对数据进行操作的函数 String 字符串，其中定义了对字符串进行截取、分隔、正则校验等操作的函数、 Date 日期，包含对日期进行操作函数 Math 数学，其中定义了数学运算绝对值、三角函数、四舍五入等操作的函数 Number 数值，包含对数值进行操作的函数 RegExp 正则表达式，用于对字符串进行正则校验 Boolean 布尔 Object 通用对象 Error 用于异常处理的错误对象 Functions 顶层对象，Functions属性–全局属性，Functions函数–全局函数 Events 事件对象 例如按钮发生了点击事件 5.2 String对象 String 构造器创建的对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;内置对象&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testString()&quot;&gt;测试String&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testString()&#123; //1.创建String对象 var str1 = &quot;www.qfedu.com&quot;; var str2 = new String(&quot;www.TAOBAO.com&quot;); //2.属性 // length属性获取当前字符串的长度 var len = str1.length; //3.常用函数 // charAt : 获取str1中索引为3的字符（索引从0开始） var c = str1.charAt(3); // indexOf: 获取str1中第一次出现&quot;edu&quot;的索引 var i = str1.indexOf(&quot;edu&quot;); // lastIndexOf: 获取str2中最后一个“o”的索引 var j = str2.lastIndexOf(&quot;o&quot;); // split :分隔字符串，将str1用&quot;.&quot;分隔成多个字符串，存放到arr中 var arr = str1.split(&quot;.&quot;); // substring : 从str1字符串索引为4的位置开始截取，直到str1结束 var s1 = str1.substring(4); // 从str1字符串索引为4的位置开始截取(包含)，直到索引为9的位置(不包含) var s2 = str1.substring(4,9); //substr:从str1字符串索引为4的位置开始截取(包含),一共截取5个字符 var s3 = str1.substr(4,5); // toUpperCase : 将str2所有字母都转大写 var s4 = str2.toUpperCase(); //toLowerCase : 将str2所有字母都转小写 var s5 = str2.toLowerCase(); //match : 判断str3字符串的格式是否匹配reg的规则，如果不匹配则返回值为null var str3 = &quot;1303030330&quot;; //假设str3是用户在页面输入的手机号 var reg = &quot;^1[3,5,7,8]\\\\d&#123;9&#125;$&quot;; //手机号码的规则（正则表达式） var b = str3.match(reg); console.log(b); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5.3 RegExp对象（正则） 专门用于对字符串的格式进行规则的检查（规则：通过正则表达式体现） 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testRegExp()&quot;&gt;测试RegExp&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testRegExp()&#123; //String对象的match函数进行正则校验 var str1 = &quot;1303030330&quot;; var reg1 = &quot;^1[3,5,7,8]\\\\d&#123;9&#125;$&quot;; //match函数：如果校验匹配返回字符串，不匹配返回null var r = str1.match(reg1); console.log(r); //------------------------------------------------------------------ //RegExp对象的test函数进行正则校验 var str = &quot;1303030330&quot;; // 一个RegExp对象就是一个正则规则 var reg = new RegExp(&quot;^1[3578]\\\\d&#123;9&#125;$&quot;); //test 函数：如果匹配返回true，不匹配返回false var b = reg.test(str); console.log(b); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 正则表达式： 特殊符号： 符号 作用 \\d 任意数字 ，相当于[0-9] \\s 空白字符 \\b 单词便捷 \\u???? 匹配unicode字符 区间 表达式 说明 [0-9] 从0到9的任意数字 [0123456789] [13579] 表示1、3、5、7、9中任意一个数字 [a-z] 从a到z的任意一个小写字母 [A-Z] 从A到Z的任意一个大写字母 [a-zA-Z] 任意一个字母 [0-9a-zA-Z] 任意字母和数字 量词 量词 作用 a+ 至少一个a a* 0~n个a a? 0~1个a a{m} m个a a{m,n} m~n个 5.4 Math Math中提供的函数（静态函数），可以通过Math.直接调用 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;内置对象-Math&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testMath()&quot;&gt;测试Math&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testMath()&#123; //1.常量属性 var e = Math.E; var pi = Math.PI; //2.“静态”数学函数 //random : 随机产生一个[0,1)小数 var num = Math.random()*10; //round : 对参数进行四舍五入得到一个整数 var i = Math.round(num); //0-10 //floor：只舍不入，获取比参数小的最大整数 var j = Math.floor(num); //0-9 //ceil: 只入不舍，获取大于等于参数的最小整数 var k = Math.ceil(num); // abs : 获取参数的绝对值 var m = Math.abs(-5); //sqrt : 获取参数的平方根 var n = Math.sqrt(9); console.log(n); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5.5 Array对象 数组，存放一组相同类型数据的数据结构 在JS中，同一个数组中可以存放多种不同类型的数据，相当于Java等强类型语言中的集合（长度可变，可以存储多种类型数据） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testArray()&quot;&gt;测试Array&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testArray()&#123; //1.创建数组 // a.通过构造器创建数组 var arr1 = new Array(); var arr2 = new Array(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;); // b.静态初始化数组 var arr3 = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,1,2,3]; //2.数组的操作 // a.添加元素(索引可以不连续，数组长度=最大索引+1) arr1[0] = &quot;wanglaoji&quot;; arr1[1] = &quot;jiaduobao&quot;; arr1[5] = &quot;kangshifu&quot;; // b.通过索引获取数组中的元素 var v1 = arr1[0]; var v2 = arr1[1]; var v3 = arr1[9]; //数组索引越界（返回undefined） // c.遍历 // ①for循环遍历 for (var i = 0; i &lt;arr1.length; i++) &#123; var v = arr1[i]; console.log(i+&quot;:&quot;+v); &#125; // ②for ... in 遍历获取的数组元素的索引 for(var i in arr2)&#123; var v = arr2[i]; console.log(i+&quot;:&quot;+v) &#125; //3.Array中定义的函数 // join :将数组中所有的元素使用&quot;-&quot;拼接成一个字符串 var s1 = arr3.join(&quot;-&quot;); //slice : 从当前数组中截取元素，生成一个新数组 var arr = arr3.slice(2,4); // reverse: 将当前数组中的元素反转 arr3.reverse(); console.log(arr3); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5.6 Date对象1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;内置对象Date&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testDate()&quot;&gt;测试Date&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testDate()&#123; //1.创建Date对象:一个Date对象就表示一个时间，new Date()表示系统当前时间 var date = new Date(); //2. 函数 // set*: 设置当前日期的日期成分 date.setFullYear(2029); date.setMonth(11); date.setDate(28); // get* : 从当前日期对象中获取 时间成分 （年月日时分秒毫秒星期） var year = date.getYear()+1900; //获取年份，相对于1900年的偏移年份 var year2 = date.getFullYear(); //获取公元纪年你年份 var month = date.getMonth()+1; //获取月份0-11 var d = date.getDate(); //获取日期 var hour = date.getHours(); //获取小时 var min = date.getMinutes(); //获取分钟 var sec = date.getSeconds(); //获取秒 var ms = date.getMilliseconds();//获取毫秒 var day = date.getDay(); //获取星期 var timeStr = year+&quot;年&quot;+month+&quot;月&quot;+d+&quot;日 &quot;+hour+&quot;:&quot;+min+&quot;:&quot;+sec+&quot; &quot;+ms+&quot; 星期&quot;+day; console.log(timeStr); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5.7 Functions对象全局函数 全局对象是一个预定义的对象，作为JavaScript中全局函数的占位符。通过全局对象，可以访问所有JS中的全局函数、全局属性。 全局对象不是任何对象的属性，所以它没有名称。 obj.method(); 全局函数(); PS：我们将全局函数归纳到Functions对象，但是在JS中window对象作为顶层容器，在语法上可以通过window对象调用全局函数。 例如：window.eval() 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testFunctions()&quot;&gt;测试全局函数&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testFunctions()&#123; //全局函数：通过全局对象Functions调用全局函数，Functions没有名称，因此全局函数可以直接调用 //parseInt：将字符串转换成整数数值 var s1 = &quot;123&quot;; var m = parseInt(s1); //parseFloat：将字符串转换成小数数值 var s2 = &quot;3.14&quot;; var n = parseFloat(s2); var url = &quot;http://www.qfedu.com/?param=中华有我&quot;; //encodeURI ： 对网址的参数部分进行编码（特殊符号和中文） var newUrl = encodeURI(url); //decodeURI：对编码后的网址进行解码 var url2 = decodeURI(newUrl); //escape：对字符串中的特殊和中文进行编码 var str1 = &quot;My name is 韩梅梅&quot;; var s = escape(str1); //unescape：对编码后的字符串进行解码 var str2 = unescape(s); //当一个字符串满足JS中对象的格式（JSON格式），我们可以通过eval转换成对象格式 var jsonStr = &quot;&#123;stuNum:&#x27;1001&#x27;,stuName:&#x27;张三&#x27;&#125;&quot;; //eval:将满足JSON格式的字符串转换成JS对象 var stu = eval(&quot;(&quot;+jsonStr+&quot;)&quot;); console.log(stu.stuName); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 六、BOM 浏览器对象模型6.1 BOM介绍Browser Object Model 浏览器对象模型。 JS编写在网页文档(document)中，网页文档运行在浏览器窗口(window)中，像document、window这样的对象也成为JS的宿主对象 6.2 window对象window对象是BOM模型中的顶层容器，表示打开的浏览器窗口 6.2.1 获取window对象window对象是所有浏览器都支持，是浏览器内置的对象，在JS代码中可以直接使用。 6.2.2 window对象属性 BOM对象属性 123456//获取BOM对象属性var v = window.navigator;var s = window.screen;var l = window.location;var h = window.history;var d = window.document; 浏览器窗口属性 12345678910111213141516171819//获取/设置当前浏览器窗口的名字window.name = &quot;w1&quot;;var name = window.name;//获取/设置当前浏览器窗口的状态栏window.status = &quot;☆&quot;;//获取当前窗口是否关闭var s = window.closed;//innerWidth: 获取浏览器的内部宽度 (IE8及以下版本不支持当前属性)//innerHeight：获取浏览器的内部高度 (IE8及以下版本不支持当前属性)var w = window.innerWidth;var h = window.innerHeight;//outerWidth: 获取浏览器的外部宽度 (IE8及以下版本不支持当前属性)//outerHeight：获取浏览器的外部高度 (IE8及以下版本不支持当前属性)var ow = window.outerWidth;var oh = window.outerHeight; 窗口对象属性 123456//self 就是当前窗口本身，等价于windows对象var w = window.self;//parent : 如果当前网页是现在另一个网页的iframe中，parent属性就表示获取当前窗口的上一级窗口 var p = window.parent;//top ： 获取当前窗口的顶层窗口var t = window.top; 6.2.3 window对象函数1.弹窗函数12345678910// alert ： 警告提示框,当用户在网页中进行错误操作时用于提示window.alert(&quot;请注意，倒车！&quot;);//confirm：消息确认框，当用户进行不可逆、且影响数据的操作，进行用户确认// 此弹窗有返回值，当用户点击“确定”时，返回truevar v = window.confirm(&quot;请问你确定删除这个信息吗？&quot;);//prompt：用户交互输入框，参数1(弹框问题提示信息)，参数2(输入框默认值)// 此弹窗有返回值，如果点击确定返回值为输入框中的值，点击取消返回值为nullvar v= window.prompt(&quot;请输入你的出生年份:&quot;,&quot;2021&quot;); 2.打开&#x2F;关闭窗口123456789101112131415//close：关闭当前窗口对象（IE有确认提示，谷歌就直接关了）window.close();//open(URL,name,features,replace) ： 打开一个新窗口// 参数1：新打开的窗口显示的网址// 参数2：新打开窗口的名字// 参数3：新打开的窗口的属性// 参数4：是否替换当前窗口 默认值为false，设置为true表示打开的新窗口会替代当前窗口// 返回值：打开的窗口对象var URL = &quot;https://www.baidu.com&quot;;var features = &quot;&quot;;// var w = window.open(URL); //var w = window.open(URL,&quot;百度&quot;);// var w = window.open(URL,&quot;百度&quot;,features);var w = window.open(URL,name,true); 打开新窗口特征（Window Features） channelmode&#x3D;yes|no|1|0 是否使用剧院模式显示窗口。默认为 no。 directories&#x3D;yes|no|1|0 是否添加目录按钮。默认为 yes。 fullscreen&#x3D;yes|no|1|0 是否使用全屏模式显示浏览器。默认是 no。处于全屏模式的窗口必须同时处于剧院模式。 height&#x3D;pixels 窗口文档显示区的高度。以像素计。 left&#x3D;pixels 窗口的 x 坐标。以像素计。 location&#x3D;yes|no|1|0 是否显示地址字段。默认是 yes。 menubar&#x3D;yes|no|1|0 是否显示菜单栏。默认是 yes。 resizable&#x3D;yes|no|1|0 窗口是否可调节尺寸。默认是 yes。 scrollbars&#x3D;yes|no|1|0 是否显示滚动条。默认是 yes。 status&#x3D;yes|no|1|0 是否添加状态栏。默认是 yes。 titlebar&#x3D;yes|no|1|0 是否显示标题栏。默认是 yes。 toolbar&#x3D;yes|no|1|0 是否显示浏览器的工具栏。默认是 yes。 top&#x3D;pixels 窗口的 y 坐标。 width&#x3D;pixels 窗口的文档显示区的宽度。以像素计。 3.窗口操作函数对浏览器窗口进行尺寸设置、位置设置、滚动条操作等的函数 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testWindow()&quot;&gt;测试window&lt;/button&gt; &lt;div style=&quot;height: 1500px; width: 2500px; background: lemonchiffon;&quot;&gt; 1&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 2&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 3&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 4&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 5&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testWindow()&#123; //打开新窗口，返回值w就表示新打开的浏览器窗口，w本身就是一个window对象 //var w = window.open(&quot;http://www.qfedu.com&quot;,&quot;千锋官网&quot;,&quot;width=400,height=300&quot;); //1.修改窗口尺寸 // resizeTo：将w窗口尺寸修改为 *,* w.resizeTo(800,600); // resizeBy：在窗口之前的尺寸宽度和高度各增加多少 w.resizeBy(800,600) //2.改变窗口位置 //moveTo：将窗口移动到指定的位置 // 参数1:窗口与屏幕左边的距离 // 参数2:窗口与屏幕顶端的距离 w.moveTo(200,100); //moveBy：基于窗口当前的位置，横向偏移和纵向偏移 w.moveBy(200,100); //3.滚动滚动条(针对当前窗口的滚动条操作) //scrollTo：将当前窗口的横向和纵向滚动条滚动指定的偏移量(x,y) window.scrollTo(100,300); //scrollBy：将当前窗口的横向和纵向滚动条滚动指定相对偏移量 window.scrollBy(-100,-200); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.延时&#x2F;循环任务延时任务：延迟指定的时间之后再去调用对应的函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;test1()&quot;&gt;打开延时任务&lt;/button&gt; &lt;button onclick=&quot;test2()&quot;&gt;关闭延时任务&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; var task1; function test1()&#123; console.log(&quot;~~~~~~~~test1&quot;); //setTimeout，延时调用指定方法 // 参数1：调用的方法， 参数2：延迟的时间（单位：ms） task1 = window.setTimeout( &quot;showDate()&quot;,3000); &#125; function showDate()&#123; var date = new Date(); date.setFullYear(2029); date.setMonth(11); date.setDate(28); date.setHours(14); var year = date.getYear()+1900; //获取年份，相对于1900年的偏移年份 var month = date.getMonth()+1; //获取月份0-11 var d = date.getDate(); //获取日期 var hour = date.getHours(); //获取小时 var min = date.getMinutes(); //获取分钟 var sec = date.getSeconds(); //获取秒 var str = year+&quot;-&quot;+month+&quot;-&quot;+d+&quot; &quot;+hour+&quot;:&quot;+min+&quot;:&quot;+sec; console.log(str); &#125; function test2()&#123; console.log(&quot;~~~~~~~~test2&quot;); //关闭未执行的延时任务 window.clearTimeout(task1); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 循环任务：间隔指定的时间循环调用函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;test1()&quot;&gt;打开循环任务&lt;/button&gt; &lt;button onclick=&quot;test2()&quot;&gt;关闭循环任务&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; var task2; function test1()&#123; console.log(&quot;~~~~~~~~test1&quot;); //setInterval，启动循环任务 // 参数1：调用的方法， 参数2：间隔的时间（单位：ms） task2 = window.setInterval( &quot;showDate()&quot;,1000); &#125; function showDate()&#123; var date = new Date(); date.setFullYear(2029); date.setMonth(11); date.setDate(28); date.setHours(14); var year = date.getYear()+1900; //获取年份，相对于1900年的偏移年份 var month = date.getMonth()+1; //获取月份0-11 var d = date.getDate(); //获取日期 var hour = date.getHours(); //获取小时 var min = date.getMinutes(); //获取分钟 var sec = date.getSeconds(); //获取秒 var str = year+&quot;-&quot;+month+&quot;-&quot;+d+&quot; &quot;+hour+&quot;:&quot;+min+&quot;:&quot;+sec; console.log(str); &#125; function test2()&#123; console.log(&quot;~~~~~~~~test2&quot;); //clearInterval：关闭正在进行的循环任务 window.clearInterval(task2); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 6.2.4 window对象总结 window对象调用属性、函数都可以省略 6.3 screen对象 screen对象，表示网页显示的硬件设备的屏幕 screen是一个只读对象，它收集硬件屏幕的相关参数，我们可以通过此对像获取当前终端屏幕的相关参数。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testScreen()&quot;&gt;测试Screen&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testScreen()&#123; //1.获取屏幕的宽度和高度(分辨率) var w = screen.width; var h = screen.height; //2.获取屏幕可用的宽度和高度（除掉状态栏） var aw = screen.availWidth; var ah = screen.availHeight; //3.屏幕硬件一英寸的物理像素点 var xdpi = screen.deviceXDPI; var ydpi = screen.deviceYDPI; alert(xdpi+&quot;*&quot;+ydpi); //练习：通过获屏幕的宽度和高度，打开一个新窗口，使其位于屏幕的正中间 &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 6.4 navigator对象 navigator对象包含了浏览器相关的信息 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testnavigator()&quot;&gt;测试navigator&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testnavigator()&#123; //返回浏览器的名称（在老版本的IE中可以测试） var name = navigator.appName; //返回浏览器的代码名 var code = navigator.appCodeName; //返回浏览的平台及版本信息 var version = navigator.appVersion; //返回浏览器的语言环境（并不是所有浏览器都支持） var lang = navigator.browserLanguage; //检查当前浏览器是否启用cookie var b = navigator.cookieEnabled; console.log(b); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 6.5 location对象 表示当前浏览器窗口的地址信息，通过此对象可以获取地址栏信息、设置地址栏信息 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testLocation()&quot;&gt;测试Location&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testLocation()&#123; //获取地址栏完整的网址 http://127.0.0.1:8848/demo3/page20-BOM-location.html?key=value // 协议 主机 端口 路径 参数 var s1 = location.href; //获取地址栏网址的协议 var s2 = location.protocol; //获取地址栏网址的端口 var s3 = location.port; // 获取地址栏网址的主机和端口 var s4 = location.host; // 获取地址栏网址的主机 var s5 = location.hostname; // 获取地址栏网址的资源路径 var s6 = location.pathname; //★ 修改地址栏完整的网址（可以实现网页跳转） location.href = &quot;http://www.qfedu.com/&quot;; //location对象的函数 //reload ： 重新载入当前网页（刷新网页） location.reload(); //replace：使用参数指定的网址替换当前地址栏的网址（实现网页跳转） location.replace(&quot;http://www.qfedu.com/&quot;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 6.6 history对象 history对象包含了用户在当前浏览器窗口中访问过的URL 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;C&lt;/title&gt; &lt;/head&gt; &lt;body&gt; C页面 &lt;hr/&gt; &lt;a href=&quot;d.html&quot;&gt;跳转到D页面&lt;/a&gt; &lt;hr/&gt; &lt;button onclick=&quot;test1()&quot;&gt;🔙&lt;/button&gt; &lt;button onclick=&quot;test2()&quot;&gt;➡&lt;/button&gt; &lt;button onclick=&quot;test3()&quot;&gt;历史记录的数量&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test1()&#123; //back ： 返回上一个页面 //history.back(); history.go(-1); &#125; function test2()&#123; //forward：切换到下一个页面 //history.forward(); history.go(1); &#125; function test3()&#123; //length属性，获取历史记录中网址的个数 var len = history.length; console.log(len); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 七、DOM 文档对象模型7.1 文档对象模型介绍 DOM树——对于一个网页文件，我们可以类比做一颗树，根标签HTML看做树根，文档中所有的标签都可以理解为这棵树上的树枝或叶子。 通过DOM树结构，我们可以从根标签有序的获取、操作文档中任何一个子标签。 7.1.1 DOM树 DOM树模型 7.1.2 相关术语元素：标签以及标签所包含的内容 元素属性：标签的属性 节点：元素、属性、文本统称为节点（元素—标签节点、属性—属性节点、文本—文本节点） 节点名称：标签节点的节点名就是标签名，属性节点的节点名就是属性名，文本节点的节点名是text 7.2 document对象document对象指代的就是一个网页文档，document对象提供属性、函数大多都是获取网页文档中的元素 7.2.1 集合属性1234567891011// all : 获取当前网页文档中的所有元素var arr1 = document.all;// imgs : 获取当前网页文档中所有图片var arr2 = document.images;// links: 获取当前网页文档中所有的链接(a,area)var arr3 = document.links;// forms：获取当前网页文档中的form元素var arr4 = docuemnt.forms; 7.2.2 其他属性12345678910111213141516// body:获取当前网页文档中的body元素var body = document.body;// title：获取当前网页文档的标题内容var title = document.title;// 设置当前文档的标题document.title = &quot;千锋Java&quot;;// URL : 获取当前网页文档的URLvar url = document.URL;// cookie : 向cookie中添加新的数据document.cookie = &quot;key=value&quot;;document.cookie = &quot;key2=value2&quot;;// cookie : 获取cookie中缓存的内容var cs = document.cookie; 7.2.4 函数 流操作 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;document对象&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testDocument()&quot;&gt;测试document对象&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testDocument()&#123; //write : 通过网页输出流将数据输出并显示到网页中 // 如果执行多次write函数使用的是同一个流，则输出的数据会追加 // 如果多次write使用的是不同的流，后面write的内容会覆盖之前的内容 document.write(&quot;从前有座山&quot;); document.write(&quot;山里有座庙&quot;); //close: 关闭当前网页输出流，关闭之后如果执行write，则会打开新的流 document.close(); //open ：打开并使用一个新的流 document.open(); document.write(&quot;庙里有...&quot;); //writeln &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 获取网页元素的函数 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;document对象&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img class=&quot;cc&quot; name=&quot;m1&quot; src=&quot;imgs/img01.png&quot; height=&quot;100&quot;/&gt;&lt;br/&gt; &lt;img id=&quot;img2&quot; src=&quot;imgs/img02.png&quot; height=&quot;100&quot;/&gt;&lt;br/&gt; &lt;img name=&quot;m1&quot; src=&quot;imgs/img03.png&quot; height=&quot;100&quot;/&gt;&lt;br/&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p class=&quot;cc&quot;&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;button onclick=&quot;test1()&quot;&gt;测试getElement...函数&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test1()&#123; //getElementById：根据标签的id属性获取一个元素 var e = document.getElementById(&quot;img2&quot;); //getElementsByName：根据标签的name属性获取一组元素 var es = document.getElementsByName(&quot;m1&quot;); //getElementsByClassName：根据标签的class属性获取一组元素 var es2 = document.getElementsByClassName(&quot;cc&quot;); //getElementsByTagName：根据标签名获取一组元素 var es3 = document.getElementsByTagName(&quot;p&quot;); console.log(es3); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 7.3 对HTML标签的操作 对HTML标签的操作，主要是标签属性操作和标签样式操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .imgStyle&#123; width: 200px; height: 200px; border-radius: 50%; transform: rotate(45deg); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;imgs/img01.png&quot; height=&quot;200&quot;/&gt;&lt;br/&gt; &lt;img id=&quot;img2&quot; src=&quot;imgs/img02.png&quot; height=&quot;200&quot;/&gt;&lt;br/&gt; &lt;img id=&quot;img3&quot; src=&quot;imgs/img03.png&quot; height=&quot;200&quot;/&gt;&lt;br/&gt; &lt;button onclick=&quot;testAttrOper()&quot;&gt;操作标签属性&lt;/button&gt; &lt;button onclick=&quot;testStyleOper()&quot;&gt;操作标签样式&lt;/button&gt; &lt;button onclick=&quot;testClassOper()&quot;&gt;操作标签class属性&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testAttrOper()&#123; var img = document.getElementById(&quot;img2&quot;); //操作标签属性（标签对象.标签属性名） // a.获取属性值 var s = img.src; // b.设置属性值 img.src = &quot;imgs/img03.png&quot;; &#125; function testStyleOper()&#123; var img = document.getElementById(&quot;img2&quot;); //操作标签样式 (标签对象.style.样式属性名) //样式属性名在css中是以&quot;-&quot;分割多个单词，在JS中操作要使用驼峰命名 // a.设置标签的样式属性 img.style.border = &quot;2px rgba(255,0,0,0.5) solid&quot;; img.style.borderRadius=&quot;10px&quot;; // b.获取标签的样式属性 var m = img.style.border; console.log(m); &#125; function testClassOper()&#123; var img3 = document.getElementById(&quot;img3&quot;); //标签对象的 class属性 使用className进行操作 img3.className = &quot;imgStyle&quot;; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 7.4 案例：表单数据校验7.4.1 案例说明 在网页中的数据提交时（登录、注册、提交订单等），如果必须填写的数据没有填写完成，或者填写的数据格式不符合要求，表单是不允许提交的。在网页中就是通过JS完成数据的完成行及合法性校验。 检验规则： 帐号： 不能为空，长度8~20之间，只能包含数字和字母 密码：不能为空，长度8~16 确认密码：要与密码一致 手机号：不能为空，满足手机号码规则 邮箱：不能为空，满足邮箱格式规则 7.4.2 案例实现 form_validate.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function doValidate()&#123; console.log(&quot;-----doValidate&quot;) //对输入的数据进行校验，如果输入的数据OK，return true //1.校验用户名 var userName = document.getElementById(&quot;userNameInput&quot;).value; var label1 = document.getElementById(&quot;userNameTipsLabel&quot;); if(userName== null || userName == &quot;&quot;)&#123; // 通过innerHTML属性修改 标签对象的里面的值 label1.innerHTML = &quot;请输入用户名！&quot;; label1.style.color = &quot;red&quot;; return false; &#125;else if( userName.length&lt;8 || userName.length&gt;20 )&#123; label1.innerHTML = &quot;用户名长度必须为8-20个字符！&quot;; label1.style.color = &quot;red&quot;; return false; &#125;else if( ! new RegExp(&quot;^[0-9a-zA-Z]*$&quot;).test(userName) )&#123; label1.innerHTML = &quot;用户名只允许包含数字和字母&quot;; label1.style.color = &quot;red&quot;; return false; &#125;else&#123; //进入else 表示用户名已经合法 label1.innerHTML = &quot;用户名输入正确！&quot;; label1.style.color = &quot;green&quot;; &#125; //2.检验密码 var userPwd = document.getElementById(&quot;userPwdInput&quot;).value; var label2 = document.getElementById(&quot;userPwdTipsLabel&quot;); if(userPwd == null || userPwd == &quot;&quot;)&#123; label2.innerHTML = &quot;请输入密码！&quot;; label2.style.color=&quot;red&quot;; return false; &#125;else if(userPwd.length&lt;8 ||userPwd.length&gt;16 )&#123; label2.innerHTML = &quot;密码长度必须为8-16个字符！&quot;; label2.style.color = &quot;red&quot;; return false; &#125;else&#123; //密码正确 label2.innerHTML = &quot;密码输入正确！&quot;; label2.style.color = &quot;green&quot;; &#125; //3.确认密码 var rePwd = document.getElementById(&quot;rePwdInput&quot;).value; var label3 = document.getElementById(&quot;rePwdTipsLabel&quot;); if(rePwd == null || rePwd == &quot;&quot;)&#123; label3.innerHTML = &quot;请再次输入密码！&quot;; label3.style.color=&quot;red&quot;; return false; &#125;else if(userPwd != rePwd)&#123; label3.innerHTML = &quot;两次密码输入不一致！&quot;; label3.style.color=&quot;red&quot;; return false; &#125;else&#123; label3.innerHTML = &quot;重复密码输入正确！&quot;; label3.style.color=&quot;green&quot;; &#125; //4.验证手机 //5.验证邮箱 return true;&#125; regist.html 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/form_validate.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- onsubmit 表单提交时间 ，如果函数返回false则不提交表单，如果返回ture则提交表单--&gt; &lt;form action=&quot;http://www.qfedu.com&quot; onsubmit=&quot;return doValidate()&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;用户注册-数据校验&lt;/legend&gt; &lt;p&gt; 账号：&lt;!-- 对于输入框对象而言，value属性就是输入框的值 --&gt; &lt;input id=&quot;userNameInput&quot; type=&quot;text&quot; placeholder=&quot;请输入用户名&quot;/&gt; &lt;label id=&quot;userNameTipsLabel&quot;&gt;&lt;/label&gt; &lt;/p&gt; &lt;p&gt; 密码： &lt;input id=&quot;userPwdInput&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot;/&gt; &lt;label id=&quot;userPwdTipsLabel&quot;&gt;&lt;/label&gt; &lt;/p&gt; &lt;p&gt; 确认密码： &lt;input id=&quot;rePwdInput&quot; type=&quot;password&quot; placeholder=&quot;请再次输入密码&quot;/&gt; &lt;label id=&quot;rePwdTipsLabel&quot;&gt;&lt;/label&gt; &lt;/p&gt; &lt;p&gt; 手机号： &lt;input type=&quot;text&quot; placeholder=&quot;请输入手机&quot;/&gt;&lt;label&gt;&lt;/label&gt; &lt;/p&gt; &lt;p&gt; 邮箱： &lt;input type=&quot;text&quot; placeholder=&quot;请输入邮箱&quot;/&gt;&lt;label&gt;&lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/p&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 7.5 节点操作 元素、元素属性以及文本都称之为节点 节点操作——使用JS完成节点创建、插入节点、修改节点、删除节点 7.5.1 节点属性 节点类型 nodeType nodeName nodeValue 标签节点 1 标签名 null 属性节点 2 属性名 属性值 文本节点 3 #text 文本内容 对于HTML元素对象： 12345//1.获取标签属性var arr1 = tag.attributes;//2.获取标签的子标签var arr2 = tag.childNodes; 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body style=&quot;color: #F08080;&quot; bgcolor=&quot;azure&quot;&gt; &lt;div id=&quot;div1&quot;&gt;hello&lt;h3&gt;枫桥夜泊&lt;/h3&gt; &lt;p&gt;月落乌啼霜满天，&lt;/p&gt; &lt;p&gt;江枫渔火对愁眠；&lt;/p&gt; &lt;p&gt;姑苏城外寒山寺，&lt;/p&gt; &lt;p&gt;夜半钟声到客船。&lt;/p&gt; &lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;测试&quot; onclick=&quot;test()&quot;/&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test()&#123; var body = document.body; console.log(body); //attributes：所有的标签对象都可以调用attributes属性，获取当前标签的属性列表 var attrsArr = body.attributes; //此数组中存放的就是style 和 bgcolor两个属性 //属性节点： var attrNode = attrsArr[0]; console.log(attrNode.nodeType); console.log(attrNode.nodeName); console.log(attrNode.nodeValue); //childNodes所有的标签对象都可以通过childNodes属性获取当前标签的子节点(包括标签节点、文本节点) var div = document.getElementById(&quot;div1&quot;); var nodesArr = div.childNodes; //文本节点 var textNode = nodesArr[0]; console.log(textNode.nodeType); console.log(textNode.nodeName); console.log(textNode.nodeValue); //标签节点 var tagNode = nodesArr[1]; console.log(tagNode.nodeType); console.log(tagNode.nodeName); console.log(tagNode.nodeValue); &#125; &lt;/script&gt;&lt;/html&gt; 7.5.2 创建新节点 网页中原来没有这个节点，通过JS代码新建一个节点 12345678//创建标签节点（元素）var tagNode = document.createElement(&quot;img&quot;);//创建文本节点var textNode = document.createTextNode(&quot;hello world&quot;);//创建属性节点var attrNode = document.createAttribute(&quot;name&quot;); 7.5.3 插入节点 将创建的新节点载入到网页文档中 标签节点的属性操作 123456789101112131415161718//1.创建标签节点var imgTag = document.createElement(&quot;img&quot;); //&lt;img&gt;//-------------------------------------------------------------begin//2.创建属性节点var srcAttr = document.createAttribute(&quot;src&quot;); // src=&quot;&quot;srcAttr.nodeValue = &quot;imgs/img01.png&quot;; // src=&quot;imgs/img01.png&quot;//3.将属性节点添加到标签节点中 imgTag.setAttributeNode(srcAttr); // &lt;img src=&quot;imgs/img01.png&quot;&gt;//---------------------------------------------------------------end//4.给标签节点添加/修改属性imgTag.setAttribute(&quot;src&quot;,&quot;imgs/img02.png&quot;);imgTag.setAttribute(&quot;width&quot;,&quot;200&quot;);imgTag.alt = &quot;图片无法显示&quot;;//5.从标签节点上移出一个属性imgTag.removeAttribute(&quot;alt&quot;); 拼接子节点 1234//6.appendChild : 拼接子节点 //tagNode.appendChild(cNode); 将cNode这个标签节点拼接到 body标签里面（最后面）var body = document.body;body.appendChild(imgTag); 插入子节点 123//7.insertBefore: 插入子节点 parentTag.insertBefore(imgTag,btnTag); 将imgTag插入到parentTag里面btnTag之前var btnTag = document.getElementById(&quot;btn_test&quot;);body.insertBefore(imgTag,btnTag); 7.5.4 替换子节点 可以使用新建的标签节点去替换某个节点，也可以获取网页中已经存在的标签去替换： 如果使用新创建的节点 去替换 某个父节点的子节点则直接替换； 如果使用网页中已经存在的标签A 去替换标签B ，A会发生移动（并不是拷贝A去替换B） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #container&#123; border: #F08080 2px solid; width: 400px; height: 300px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body &gt; &lt;div id=&quot;container&quot;&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p id=&quot;p&quot;&gt;我是一个图片&lt;/p&gt; &lt;p&gt;world&lt;/p&gt; &lt;/div&gt; &lt;img id=&quot;img3&quot; src=&quot;imgs/img03.png&quot; height=&quot;100&quot; /&gt; &lt;input id=&quot;btn_test&quot; type=&quot;button&quot; value=&quot;测试&quot; onclick=&quot;test()&quot;/&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test()&#123; //使用一个图片标签，替换div中的p标签 //0. 创建新节点 //var imgTag = document.createElement(&quot;img&quot;); //imgTag.src = &quot;imgs/img01.png&quot;; //imgTag.height=100; // 获取网页中已经存在的图片标签: // 如果使用网页中已经存在的标签A 去替换标签B ，A会发生移动（并不是拷贝A去替换B） var imgTag = document.getElementById(&quot;img3&quot;); // 1.替换子节点 // parentTag.replaceChild(newChild,oldChild) // 使用newChild替换parentTag中的oldChild var parentTag = document.getElementById(&quot;container&quot;); var oldChild = document.getElementById(&quot;p&quot;); parentTag.replaceChild(imgTag,oldChild); // 2.替换节点 // currentTag.replace( newTag):使用newTag来替换currentTag (受浏览器支持的限制) // oldChild.replaceNode(imgTag); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 7.5.5 删除子节点123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #container&#123; border: #F08080 2px solid; width: 400px; height: 300px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body &gt; &lt;div id=&quot;container&quot;&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p id=&quot;p&quot;&gt;我是一个图片&lt;/p&gt; &lt;p&gt;world&lt;/p&gt; &lt;/div&gt; &lt;input id=&quot;btn_test&quot; type=&quot;button&quot; value=&quot;测试&quot; onclick=&quot;test()&quot;/&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test()&#123; var div = document.getElementById(&quot;container&quot;); var p = document.getElementById(&quot;p&quot;); //删除节点 //removeNode ：删除当前节点 （IE支持，其他浏览器兼容性不强） //p.removeNode(true); //删除子节点 //parentTag.removeChild(oldChild) :从parentTag中删除oldChild div.removeChild(p); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 八、JavaScript事件 事件：在网页文档中发生行为（可以是网页文档加载过程产生、也可以用户人为操作的） 8.1 JS事件绑定 JS函数是通过网页事件驱动的，驱动的方式有两种：内联方式 和 外联方式 8.1.1 HTML内联绑定在HTML标签上添加事件属性，绑定对应的JS函数： 1234567&lt;button onclick=&quot;test1()&quot;&gt;测试按钮1&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; function test1()&#123; console.log(&quot;------------test1&quot;); &#125;&lt;/script&gt; 8.1.2 JS脚本外联绑定不在HTML标签上写事件属性，通过JS获取HTML元素，调用事件属性绑定JS函数： 12345678&lt;button id=&quot;btn2&quot;&gt;测试按钮2&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; var btn2 = document.getElementById(&quot;btn2&quot;); btn2.onclick = function()&#123; console.log(&quot;------------test2&quot;); &#125;&lt;/script&gt; 8.2 HTML常用事件 鼠标事件 键盘事件 （表单标签） window事件 表单事件 8.2.1 鼠标事件 用户的鼠标在HTML标签上产生点击、双击、移动、放上、离开等动作 onclick 单击 ondblclick 双击 onmouseover 鼠标移动到HTML元素上 onmouseout 鼠标从HTML元素上移走 onmousemove 鼠标在HTML元素上移动 onmousedown 鼠标在HTML元素上左键按下 onmouseup 鼠标在HTML元素上左键松开 123456789101112131415161718192021222324252627&lt;img src=&quot;imgs/img01.png&quot; width=&quot;200&quot; onclick=&quot;test1()&quot; ondblclick=&quot;test2()&quot; onmouseover=&quot;test3()&quot; onmouseout=&quot;test4()&quot; onmousemove=&quot;test5()&quot; onmousedown=&quot;test6()&quot; onmouseup=&quot;test7()&quot;/&gt;&lt;script type=&quot;text/javascript&quot;&gt; function test1()&#123; console.log(&quot;----test1&quot;); &#125; function test2()&#123; console.log(&quot;----test2&quot;); &#125; function test3()&#123; console.log(&quot;----test3&quot;); &#125; function test4()&#123; console.log(&quot;----test4&quot;); &#125; function test5()&#123; console.log(&quot;----test5&quot;); &#125; function test6()&#123; console.log(&quot;----test6&quot;); &#125; function test7()&#123; console.log(&quot;----test7&quot;); &#125;&lt;/script&gt; 8.2.2 键盘事件 键盘事件主要是针对于表单中的输入标签 onkeydown 键盘按键按下（如果按下去不松开则一直触发） onkeyup 键盘按键抬起 onkeypress 键盘按键按下(只支持字符键) 12345678910111213&lt;input type=&quot;text&quot; onkeydown=&quot;test8()&quot; onkeyup=&quot;test9()&quot; onkeypress=&quot;test10()&quot;/&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test8()&#123; console.log(&quot;----test8&quot;); &#125; function test9()&#123; console.log(&quot;----test9&quot;); &#125; function test10()&#123; console.log(&quot;----test10&quot;); &#125;&lt;/script&gt; 8.2.3 window事件 window对象触发的时间，window对象并不是一个HTML标签，window对象的事件通常使用JS脚本绑定 1234567891011121314151617181920//onload ： 当网页中body标签内容加载完毕触发window.onload = function()&#123; console.log(&quot;------onload&quot;);&#125;//onunload ： 当前网页关闭或刷新时执行，用于回收资源window.onunload = function()&#123; console.log(&quot;------onunload&quot;);&#125;//onscroll ：当网页发生滚动时触发执行window.onscroll = function()&#123; console.log(&quot;------onscroll&quot;);&#125;//onresize ：窗口的尺寸发生变化时触发window.onresize = function()&#123; console.log(&quot;------onscroll&quot;);&#125; 案例：如果在HTML的head标签中通过js绑定事件，必须写在 window.onload= function()&#123;&#125;中 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var btn = document.getElementById(&quot;btn&quot;); btn.onclick = function()&#123; console.log(&quot;-----hello&quot;); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;btn&quot;&gt;测试按钮&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 8.2.4 表单事件 上面讲到的键盘事件通常是绑定在表单输入标签，但是表单输入标签支持的事件不止键盘事件 onfocus 获取焦点 onblur 失去焦点 onchange 内容发生改变 onselect 内容被选中 onsubmit 表单提交（必须绑定在form元素上） onreset 重置表单（必须绑定在form元素上） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;userName&quot;/&gt; &lt;select id=&quot;num&quot;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &lt;form action=&quot;http://www.qfedu.com&quot;&gt; &lt;input type=&quot;text&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt; &lt;input type=&quot;reset&quot; /&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; var userNameInputTag = document.getElementById(&quot;userName&quot;); //onfocus：当表单标签获得焦点时触发 userNameInputTag.onfocus = function()&#123; console.log(&quot;~~~~~~~test1&quot;); &#125; //onblur ：当表单标签失去焦点时触发 userNameInputTag.onblur = function()&#123; console.log(&quot;~~~~~~~test2&quot;); &#125; //onchange ：当表单标签中的值发生变化触发（输入框输入完成失去焦点后判断） userNameInputTag.onchange = function()&#123; console.log(&quot;~~~~~~~test3&quot;); &#125; //select标签页支持onchange事件 document.getElementById(&quot;num&quot;).onchange = function()&#123; console.log(&quot;~~~~~~~test4&quot;); &#125; //onselect：当输入框中输入的内容被选中时触发 userNameInputTag.onselect = function()&#123; console.log(&quot;~~~~~~~test5&quot;); &#125; //onsubmit ：绑定在form元素上，当此表单被提交时触发 document.forms[0].onsubmit = function()&#123; console.log(&quot;~~~~~~~test6&quot;); return false; //阻止表单提交 &#125; //onsubmit ：绑定在form元素上，当此表单被重置时触发 document.forms[0].onreset = function()&#123; console.log(&quot;~~~~~~~test7&quot;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 8.3 Event事件对象 JS将标签发生的动作抽象为事件对象 Event对象用来描述HTML标签与发生的动作的组合 一个按钮发生了点击事件 — Event对象 一个图片发生了点击事件 — Event对象 一个图片发生了鼠标移动时间 —Event对象 8.3.1 获取event对象方式一：在JS函数中，使用window对象调用event属性获取触发当前JS函数的event对象 12345678&lt;button onmouseover=&quot;test1()&quot;&gt;按钮&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; function test1()&#123; //window.event 获取当前事件对象 var ev = window.event; &#125;&lt;/script&gt; 方式二：如果使用JS脚本绑定函数，也可以使用函数的参数直接获取 123456789&lt;img src=&quot;imgs/img01.png&quot; height=&quot;100&quot; id=&quot;img&quot;/&gt;&lt;script type=&quot;text/javascript&quot;&gt; var img = document.getElementById(&quot;img&quot;); img.onclick = function(ev)&#123; //参数 ev 即为 event对象 console.log(ev); &#125;&lt;/script&gt; 8.3.2 event对象属性1234567//event对象调用srcElement属性，可以获取触发此事件的标签var tag = event.srcElement; console.log(tag);//event对象调用type属性，可以获取事件的类型var type = event.type;console.log(type); 8.4 阻止事件冒泡 事件冒泡：在子标签发生的事件触发了当前标签上层父标签绑定的函数 通过event对象阻止事件冒泡： event.cancelBubble &#x3D; true; event.stopPropagation(); 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div&quot; style=&quot;padding:50px; width: 100px; height: 100px; background: rgba(255,0,0,0.5);&quot;&gt; &lt;button id=&quot;btn&quot;&gt;测试按钮&lt;/button&gt; &lt;img src=&quot;imgs/img01.png&quot; height=&quot;50&quot;/&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var div = document.getElementById(&quot;div&quot;); div.onclick = function()&#123; console.log(&quot;------------test1&quot;); &#125; //阻止事件冒泡 var arr = div.childNodes; for(var i=0; i&lt;arr.length ; i++)&#123; var node = arr[i]; if(node.nodeType == 1)&#123; node.onclick=function(ev)&#123; var event = ev || window.event; //浏览器兼容 event.cancelBubble = true; &#125; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 九、综合案例-锅打灰太狼9.1 准备工作 图片素材 创建web项目 创建游戏主界面网页 index.html 9.2 游戏界面设计index.html1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;锅打灰太狼&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 游戏主界面 --&gt; &lt;div id=&quot;container&quot;&gt; &lt;!-- 记录分数的DIV --&gt; &lt;div id=&quot;fraction&quot;&gt;0&lt;/div&gt; &lt;!-- 时间进度条 --&gt; &lt;div id=&quot;time&quot;&gt;&lt;/div&gt; &lt;!-- 开始按钮 --&gt; &lt;div id=&quot;startMenu&quot;&gt; &lt;input id=&quot;start&quot; type=&quot;button&quot; value=&quot;开始游戏&quot;&gt; &lt;/div&gt; &lt;!-- 结束按钮 --&gt; &lt;div id=&quot;overMenu&quot;&gt; &lt;input id=&quot;over&quot; type=&quot;button&quot; value=&quot;结束游戏&quot;&gt; &lt;/div&gt; &lt;!-- 重新开始 --&gt; &lt;div id=&quot;reloadMenu&quot;&gt; &lt;input id=&quot;reload&quot; type=&quot;button&quot; value=&quot;重新开始&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 引用JS文件 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/wolf.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; style.css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* 游戏主界面样式 */#container&#123; width: 320px; height: 480px; /* border:1px solid #ff0000; */ margin: auto; background: url(../imgs/game_bg.jpg); border-radius: 5px; position: relative; /* 让父容器中的HTML布局都参考父容器 */&#125;/* 设置记分牌的样式：位置、外观 */#fraction&#123; position: absolute; left: 60px; top: 10px; color: yellow; font-weight: bold; font-size: 18px;&#125;/* 设置时间进度条的样式 */#time&#123; position: absolute; left: 63px; top: 66px; width: 180px; height: 15.5px; background: orangered; border-radius: 8px;&#125;/* 设置按钮div的样式 */#startMenu,#overMenu,#reloadMenu&#123; width: 320px; height: 35px; text-align: center; position: absolute; left: 0px; top: 200px;&#125;#reloadMenu&#123; top: 240px;&#125;/* 设置 结束按钮 和 重新开始 按钮 默认隐藏 */#overMenu,#reloadMenu&#123; display: none;&#125;/* 设置三个按钮的样式 */#start,#over,#reload&#123; width: 100px; height: 35px; border: none; border-radius: 5px; background: orangered; color: white; font-size: 16px;&#125;#start:hover,#over:hover,#reload:hover&#123; background: orange;&#125; 9.3 游戏功能实现wolf.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// 获取页面中需要操作的HTML元素var containerDiv = document.getElementById(&quot;container&quot;);var fractionDiv = document.getElementById(&quot;fraction&quot;);var timeDiv = document.getElementById(&quot;time&quot;);var startMenuDiv = document.getElementById(&quot;startMenu&quot;);var overMenuDiv = document.getElementById(&quot;overMenu&quot;);var reloadMenuDiv = document.getElementById(&quot;reloadMenu&quot;);var startBtn = document.getElementById(&quot;start&quot;);var overBtn = document.getElementById(&quot;over&quot;);var reloadBtn = document.getElementById(&quot;reload&quot;);//1.点击开始按钮，隐藏按钮，并开始计时startBtn.onclick = function()&#123; //a.隐藏开始按钮（就是隐藏开始按钮所在的div） startMenuDiv.style.display = &quot;none&quot;; //b.开始记时（时间进度条逐渐变短 默认宽度 180px,假设游戏时间1min,每秒减少3像素） var timeDivWidth = 180; var px = timeDivWidth/(60); //使用进度条宽度除于游戏时间 （每 0.1s 减少 0.3像素） //每0.1s将时间进度条的宽度减少0.3像素 var timeTask = setInterval(function()&#123; //计算 timeDivWidth = timeDivWidth - px; //将计算后的宽度设置给时间进度条DIV timeDiv.style.width = timeDivWidth+&quot;px&quot;; if(timeDivWidth&lt;=0)&#123; //表示游戏时间结束: 停止计时 clearInterval(timeTask); //停止显示狼的循环任务 clearInterval(showWolfsTask); //显示 游戏结束 和 重新开始 按钮 overMenuDiv.style.display = &quot;block&quot;; reloadMenuDiv.style.display = &quot;block&quot;; &#125; &#125;,100); //c.显示狼群(使用循环任务) wolfsGoGoGo();&#125;//显示图片的洞口的坐标var arrPos = [[&quot;98px&quot;,&quot;115px&quot;],[&quot;17px&quot;,&quot;160px&quot;],[&quot;15px&quot;,&quot;221px&quot;],[&quot;30px&quot;,&quot;294px&quot;],[&quot;122px&quot;,&quot;274px&quot;],[&quot;207px&quot;,&quot;296px&quot;],[&quot;200px&quot;,&quot;212px&quot;],[&quot;187px&quot;,&quot;142px&quot;],[&quot;100px&quot;,&quot;192px&quot;]];//记录游戏分数var score = 0; var showWolfsTask;function wolfsGoGoGo()&#123; showOneWolf(); showWolfsTask = setInterval(&quot;showOneWolf()&quot;,1000);&#125;function showOneWolf()&#123; //1. 创建一个img标签 var img = document.createElement(&quot;img&quot;); //将img标签添加为containerDiv的子标签 containerDiv.appendChild(img); //2. 将img显示到洞口位置(随机显示到某个洞口：列出9个洞口的坐标，随机选择一个) var index = Math.floor( Math.random()*arrPos.length ); // 0-8 img.style.position = &quot;absolute&quot;; img.style.left = arrPos[index][0]; img.style.top = arrPos[index][1]; //3.随机产生一只狼，设置到img标签的src属性 // 算法：产生一个0、1、2随机数,如果能被2整除则显示大灰狼，否则显示小灰灰 var wolfIndex = Math.floor( Math.random()*3 ); var wolfName = wolfIndex%2==0?&quot;h&quot;:&quot;x&quot;; //4.让狼有一个上升的过程 （h0---h5, x0--x5） //显示图片 var i = -1; var task = null; // task表示狼完全显示以后的等待任务 var hideImgTask = null; //hideImgTask表示狼下降的循环任务 var showImgTask = setInterval(function()&#123; i++; img.src = &quot;imgs/&quot;+wolfName+i+&quot;.png&quot;; if(i == 5)&#123; //狼已经完全显示 clearInterval(showImgTask); //隐藏图片 ： 等待一定的时间（500ms），如果没有对狼进行点击，则狼要消失 var task = setTimeout(function()&#123; //狼要消失（就是将图片移出,但是在移出之前需要有狼躲进洞的效果） var hideImgTask = setInterval(function()&#123; i--; img.src = &quot;imgs/&quot;+wolfName+i+&quot;.png&quot;; if(i&lt;=0)&#123; clearInterval(hideImgTask); img.remove(); &#125; &#125;,50); &#125;,500); &#125; &#125;,50); //5.游戏计分：当img被点击，则进行计分 img.onclick = function()&#123; //a.清除任务：点击事件可能发生在狼上升、等待、下降任何一个过程 clearInterval(showImgTask); clearTimeout(task); clearInterval(hideImgTask); //b.显示狼被打击的动画 var j = 5; var hitTask = setInterval(function()&#123; j++; img.src = &quot;imgs/&quot;+wolfName+j+&quot;.png&quot;; if(j&gt;9)&#123; clearInterval(hitTask); img.remove(); &#125; &#125;,50); //c.计分 if(wolfName == &quot;h&quot;)&#123; score = score+10; &#125;else&#123; score = score-10; &#125; fractionDiv.innerHTML = score; &#125; &#125;","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"day05-CSS","slug":"day05-CSS","date":"2022-09-16T15:29:15.000Z","updated":"2022-10-01T03:09:57.911Z","comments":true,"path":"2022/09/16/day05-CSS/","link":"","permalink":"http://example.com/2022/09/16/day05-CSS/","excerpt":"","text":"一、CSS基础 HTML标签决定了网页的内容，CSS能够对HTML标签的显示效果进行设置 1.1 style属性 几乎所有的HTML标签都可以添加一个style属性，在style属性值中设置样式属性，来修改当前HTML标签的显示效果。 标签属性：在HTML标签中添加的键值对 样式属性：HTML标签的style属性值中的键值对 style属性值（样式属性）的语法： 在style属性值中，可以添加多个样式属性，样式属性名与样式属性值之间以:隔开，两个样式属性之间用;隔开 12&lt;input type=&quot;text&quot; style=&quot;width:300px ; height: 35px&quot;/&gt;&lt;img src=&quot;imgs/img01.png&quot; style=&quot;width: 200px; height: 200px; border-radius: 50%&quot;/&gt; 1.2 style标签 问题：style属性可以用来设置HTML的样式，但是如果在一个网页中有多个HTML标签要使用相同的样式，使用style属性设置样式会在每个HTML标签写重复的样式属性，同时如果要修改其效果，则需要修改所有HTML标签的style属性值——代码冗余度高、不便于维护 解决方案：我们可以将多个HTML标签共用的样式属性列表单独定义在style标签中 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* CSS选择器：规定&#123;&#125;中的样式列表对哪些HTML标签有效 */ input&#123;width:270px ; height: 30px&#125; img&#123;width: 200px; height: 200px; border-radius: 50%;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入账号&quot;/&gt; &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot;/&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入真实姓名&quot;/&gt; &lt;img src=&quot;imgs/img01.png&quot; /&gt; &lt;img src=&quot;imgs/img02.png&quot; /&gt; &lt;img src=&quot;imgs/img03.png&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 1.3 CSS层叠样式表 CSS （Cascading Style Sheets） 层叠样式表 样式表：style标签中定义的、可以供网页中HTML标签复用的样式列表 层叠样式表：在style标签中定义的多个样式表可以叠加作用在同一个HTML标签上 CSS基础语法： CSS样式表定义在一对&#123;&#125;中 在&#123;&#125;中可以定义多个样式属性，样式属性名与样式属性值之间使用:分隔，多个样式属性之间使用;分隔 定义样式属性列表的&#123;&#125;前需要定义选择器 123&lt;style type=&quot;text/css&quot;&gt; 选择器&#123;样式属性名1:样式属性值1 ; 样式属性名2:样式属性值2...&#125;&lt;/style&gt; 1.4 CSS选择器 CSS选择器：声明此样式列表对网页中哪些HTML标签有效 ID选择器 1.4.1 ID选择器 语法：#idAttrValue&#123;样式列表&#125; 作用范围：对当前网页中id属性值为idAttrValue的标签有效（通常用于对某一个标签定义样式时使用） 示例： 12345678&lt;style type=&quot;text/css&quot;&gt; /* 1、ID选择器 (样式表对id=img1的标签有效)*/ #img1&#123;width: 200px; height: 200px;&#125;&lt;/style&gt;&lt;img id=&quot;img1&quot; src=&quot;imgs/img01.png&quot; /&gt; &lt;br/&gt;&lt;img id=&quot;img2&quot; src=&quot;imgs/img02.png&quot; /&gt; &lt;br/&gt;&lt;img id=&quot;img3&quot; src=&quot;imgs/img03.png&quot; /&gt; &lt;br/&gt; 1.4.2 标签选择器 语法：tagName&#123;样式列表&#125; 作用范围：对当前网页中所有tagName标签都有效 示例： 123456789&lt;style type=&quot;text/css&quot;&gt; /* 2、标签选择器 (对当前网页中所有的img标签都有效) */ img&#123;border: 5px pink solid;&#125;&lt;/style&gt;&lt;img src=&quot;imgs/img01.png&quot; /&gt; &lt;br/&gt;&lt;img src=&quot;imgs/img02.png&quot; /&gt; &lt;br/&gt;&lt;img src=&quot;imgs/img03.png&quot; /&gt; &lt;br/&gt;&lt;div class=&quot;borderStyle&quot;&gt;This is DIV Tag&lt;/div&gt; 1.4.3 class选择器 语法：.classAttrValue&#123;样式列表&#125; 作用范围：对当前网页中所有的class属性值为classAttrValue 示例： 123456789&lt;style type=&quot;text/css&quot;&gt; /* 3、CLASS选择器 (对当前网页中 class=&quot;borderStyle&quot;的标签有效) */ .borderStyle&#123;border: 5px blue solid; border-radius: 50%;&#125;&lt;/style&gt;&lt;img class=&quot;borderStyle&quot; src=&quot;imgs/img01.png&quot; /&gt; &lt;br/&gt;&lt;img src=&quot;imgs/img02.png&quot; /&gt; &lt;br/&gt;&lt;img class=&quot;borderStyle&quot; src=&quot;imgs/img03.png&quot; /&gt; &lt;br/&gt;&lt;div class=&quot;borderStyle&quot;&gt;This is DIV Tag&lt;/div&gt; 1.5 css文件 在一个HTML文件中如果有多个HTML标签需要使用相同的样式，可以将公用的样式定义在当前网页的style标签中，但是如果多个网页的HTML标签需要使用相同的样式，我们该如何处理呢？ —— 将多个网页需要使用的共同的样式单独定义在一个后缀名为.css的文件中（CSS文件），然后在需要使用css文件中的样式的网页文件中，通过link标签引用此样式文件即可 在项目中创建css目录，在css目录中创建css文件,在css文件中定义公用样式表 12345678/* 样式定义在CSS文件中，无需使用style标签 */.btnStyle&#123; width: 200px; height: 35px; border: none; background-color: pink; border-radius: 5px;&#125; 在需要使用css文件中定义的样式的网页文件，通过link标签引用css样式文件 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Page03&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;button class=&quot;btnStyle&quot;&gt;按钮1-1&lt;/button&gt; &lt;button class=&quot;btnStyle&quot;&gt;按钮1-2&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 在一个网页文件中可以通过link标签引用多个css文件，同时还可添加style标签，定义当前网页的专属样式表 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Page03&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt; &lt;style type=&quot;text/css&quot;&gt; /* css样式表 */ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 二、CSS常用样式设置 CSS可以用于设置HTML标签的显示效果，那么HTML标签可以设置哪些显示效果呢 ？ 2.1 CSS盒子模型 基于HTML标签的嵌套、并列关系，我们可以形象的用盒子的嵌套、并列堆放关系来理解常见的CSS样式审定的模型。 2.2 尺寸样式 属性名 说明 示例 with 设置宽度 width: 200px; height 设置高度 height: 200px; CSS样式中设置尺寸，值需要带上单位 px像素，HTML标签属性值不能带px 如果同时设置图片的宽度和高度，可能会导致比例发生变化，建议设置其中之一，另一个会等比缩放 2.3 边框样式 属性名 说明 示例 border-color 边框颜色：值可以是颜色名（blue）、色号(#00ff00)、rgb(255,0,0)、rgba(255,0,0,0.3) border-color:#ff0000 border-style 边框样式：实线solid、点状虚线（dotted）、段状虚线（dashed）、 双实线(double) border-style:double border-width 边框宽度：单位像素，对于双边框，宽度必须&gt;&#x3D;3px border-width:3px border 同时设置边框颜色、样式、宽度 （三个值空格分隔，顺序不限） border: #0000FF double 3px; border-top 设置上边框border-top-style 单独设置上边框的样式border-top-color 单独设置上边框的颜色border-top-width 单独设置上边框的宽度 border-top:#0000FF double 3px; boder-bottom 设置下边框 border-bottom: #FF0000 SOLID 3px; border-left 设置左边框 … border-right 设置右边框 … 任何一个HTML组件，边框分为上、下、左、右四个边框，我们可以单独设置； 组件的上下左右边框也可以单独设置 样式、颜色及宽度。 2.4 边框圆角及阴影 属性名 说明 示例 border-radius 设置边框圆角：样式属性值可以是具体的像素（10px）,也可以是百分比(20%) border-radius:20pxborder-radius:20% box-shadow 设置阴影，四个参数：阴影颜色、X轴偏移、Y轴偏移、渲染 box-shadow: red 3px 3px 4px border-radius设置边框圆角有一下三种设置值的方式： border-radius:10px 同时设置四个圆角 border-radius:0px 10px 分别设置左上右下 、左下右上圆角 border-radius:0px 10px 20px 30px 分别设置左上、右上、右下、左下四个圆角 区域性显示的元素都可以设置阴影 2.5 背景样式 属性名 说明 示例 background-color 设置背景颜色 background-color: lightgreen; background-image 设置背景图片 background-image: url(imgs&#x2F;img02.png); background 设置背景颜色或者图片 background: lightgreen;background: url(imgs&#x2F;img03.png); background-position 当背景图片过大时设置偏移 background-position: -50px ;background-position: -50px -20px; background-repeat 当背景图片比较小时设置平铺方式 background-repeat: no-repeat; 不平铺 background-repeat: repeat-x; 横向平铺background-repeat: repeat-y; 纵向平铺 background-repeat: repeat; 双向平铺 当我们设置背景颜色的时候，区域的所有范围都是设定的颜色 当我们设置背景图片的时候，图片有可能太大也有可能太小 如果图片大于区域范围我们可以对图片进行偏移设置 如果图片小于区域范围我们可以设置图片的平铺方式 2.6 外边距样式 外边距指的是HTML标签与父容器边框、同级标签的距离 在容器中没有同级标签，外边距指的是当前HTML标签与父容器边框的距离 如果父容器中存在与当前HTML标签的同级标签，外边距指的就是当前HTML标签与同级元素的距离 属性名 说明 示例 margin-left 设置左外边距 margin-left: 100px; margin-top 设置上外边距 margin-top: 100px; margin-right 设置右外边距 margin-right: 100px; margin-bottom 设置下外边距 margin-bottom: 100px; margin 设置外边距，可以设置1个参数、2个参数、4个参数margin:100px; 同时设置四个方向的外边距 margin:50px 100px; 分别设置上下、左右外边距margin:0px 100px 50px 100px 分别设置上、右、下、左外边距 我们可以使用margin-left、margin-top等单独设置某一个方向的外边距，也可以直接使用margin设置多个方向的外边距 2.7 内边距样式 内边距，设置当前容器标签中的元素(文本&#x2F;图片等)距离当前容器边框的距离 可以通过 padding-left、padding-top、padding-right、padding-bottom分别设置容器四边的内边距，也可以通过padding来设置 属性名 说明 示例 padding-left 设置左内边距 padding-left: 100px; padding-top 设置上内边距 padding-top: 100px; padding-right 设置右内边距 padding-right: 100px; padding-bottom 设置下内边距 padding-bootom: 100px; padding padding:50px; 同时设置上下左右四个方向的内边距 padding: 50px 100px;分别设置上下、左右的内边距 padding: 0px 50px 100px 200px; 分别设置上、右、下、左四个方向的内边距 2.8 字体样式 设置网页显示的文本的字体样式 12345678910111213141516171819&lt;style&gt;/* 自定义字体： 1.下载字体文件(ttc、ttf、woff格式) 2.在项目中创建fonts目录，将字体文件粘贴进来 3.根据字体文件自定义字体 */ @font-face&#123; font-family: &#x27;华康娃娃体&#x27;; /* 声明自定义字体名称 */ src: url(fonts/华康娃娃体简W5.ttc); /* 链接到字体文件 */ &#125; /* 字体样式 */ .fontStyle&#123; font-size:30px; /* 设置字体大小 */ font-weight: bold; /* 设置字体加粗 */ color: #0000FF; /* 设置字体颜色 */ font-family: 华康娃娃体 ; /* 设置字体样式，需要当前系统支持的字体、或者使用自定义字体 */ &#125;&lt;/style&gt; 2.9 文本样式12345678&lt;style&gt;/* 文本样式 */ .textStyle&#123; text-align: center; /* 设置当前标签中的文本的水平对齐方式 left|center|right */ text-decoration: none ; /* 设置文本的装饰 none|underline|overline|line-through */ text-shadow: #FF0000 2px 2px 3px; /* 设置文本阴影 */ &#125;&lt;/style&gt; 2.10 列表样式 列表样式主要时针对有序列表、无序列表、自定义列表等标签的样式 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* 列表样式 */ .listStyle1&#123; list-style-type: circle; list-style-position: inside ; &#125; .listStyle2&#123; list-style-type: circle; /* 设置列表图标的样式，none表示不显示图标 */ list-style-position: outside ;/* 设置列表项图标的位置，inside/outside */ list-style-image: url(imgs/list_item.bmp); /* 设置自定义列表项图标 */ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=&quot;listStyle1&quot;&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;梨子&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;listStyle2&quot;&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;梨子&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 2.11 分列显示（瀑布模型） 将一个容器下的多个HTML元素分成多列显示，在容器中分成多列高度会保持基本一致——瀑布模型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;分列显示&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #container&#123; width: 1000px; height: 3000px; border: 1px #0000FF solid; margin: 100px auto; /* 设置DIV容器的外边距，上下100px，左右auto居中 */ column-count: 4; /* 设置容器分列的列数 */ column-rule: blue 1px dashed; /* 设置分列显示之后列与列之间的分割线样式 */ column-width: 230px; /* 设置分列之后的每列宽度（默认： 列宽=容器宽度/列数） */ column-gap: 0px; /* 设置列与列之间的空隙 */ &#125; img&#123; width: 200px; border-radius: 5px; margin-left: 25px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;img src=&quot;imgs/img01.png&quot; style=&quot;border:3px pink solid&quot;/&gt; &lt;img src=&quot;imgs/img02.png&quot; style=&quot;border:3px orange solid&quot;/&gt; &lt;img src=&quot;imgs/img03.png&quot;/&gt; &lt;img src=&quot;imgs/img01.png&quot;/&gt; &lt;img src=&quot;imgs/img02.png&quot;/&gt; &lt;img src=&quot;imgs/img03.png&quot;/&gt; &lt;img src=&quot;imgs/img01.png&quot;/&gt; &lt;img src=&quot;imgs/img02.png&quot;/&gt; &lt;img src=&quot;imgs/img03.png&quot;/&gt; &lt;img src=&quot;imgs/img01.png&quot;/&gt; &lt;img src=&quot;imgs/img02.png&quot;/&gt; &lt;img src=&quot;imgs/img03.png&quot;/&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2.12 超链接（伪类） 超链接伪类，用于设置超链接在不同状态时的样式 a:link 超链接初始状态(未激活) a:hover 设置鼠标悬停的样式 a:active 设置超链接鼠标点击下去时的样式 a:visited 设置激活后的超链接的样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*超链接默认样式: 未激活的超链接是蓝色的， 超链接鼠标点击下去是红色， 激活后的超链接是紫色的 如何修改超链接不同状态下的样式呢 ？——使用超链接伪类 */ a&#123; text-decoration: none; /*color: gray;如果使用color设置超链颜色，则未激活、鼠标点下去、激活后颜色都是同一个颜色 */ &#125; /* a:link 超链接初始状态(未激活) */ a:link&#123; color: darkcyan; &#125; /* a:hover 设置鼠标悬停的样式 */ a:hover&#123; color:blue &#125; /* a:active 设置超链接鼠标点击下去时的样式*/ a:active&#123; color: orange; &#125; /* a:visited 设置激活后的超链接的样式 */ a:visited&#123; color:gray &#125; .btnStyle&#123; border: #008B8B 1px solid; border-radius: 3px; width: 180px; height: 30px; color: #008B8B; &#125; .btnStyle:hover&#123; background: #008B8B; color: white; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;http://www.qfedu.com&quot;&gt;千锋教育&lt;/a&gt; &lt;button class=&quot;btnStyle&quot;&gt;测试按钮&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 2.13 CSS布局 div层是一个HTML标签的容器，我们可以将HTML标签放到div容器中，通过CSS改变DIV的排列方式，即可以实现对HTML元素的布局，DIV+CSS布局： 绝对布局 相对布局 浮动布局 2.13.1 绝对布局使用position:absolute设置绝对布局 1、如果div标签直接写在body中，div的绝对布局位置是参考浏览器边框2、如果div写在父容器中，且父容器div没有设置position，则父容器里面的div的绝对布局不是参考父容器，而是参考浏览器边框3、如果div写在父容器中，其父容器div设置了position&#x3D;absolute|relative|fixed, 父容器里面的div的绝对布局就是参考父容器边框 使用position:fiexd设置绝对布局 任何时候，div的绝对布局都是参考浏览器边框 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* body标签在浏览器中默认是有边距，为了让body的元素可以紧挨着浏览器边缘， 我们通常对body进行padding和margin设置为0px，以消除边距 */ body&#123; padding: 0px; margin: 0px; &#125; img&#123; /* height: 200px; */ width: 200px; margin: 0px; &#125; /* div块级元素，高度默认和div中内容一样高；宽度默认和父容器一样宽 */ div&#123; border:1px solid green; width: 200px; padding: 0px; &#125; /* div+css布局：绝对布局 */ #div1&#123; position: fixed; /* 设置div的布局方式 absolute 绝对布局*/ left: 300px; top: 200px; &#125; #div2&#123; position: absolute; left: 450px; top: 400px; &#125; #div3&#123; position: absolute; left: 275px; top: 375px; &#125; #container&#123; width: 1000px; height: 800px; background: yellow; margin: 100px; position: fixed; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt;&lt;!-- 使用 position: absolute 设置div绝对布局：1、如果div标签直接写在body中，设置position: absolute; div的位置是参考浏览器边框2、如果父容器div没有设置position，则父容器里面的div的绝对布局不是参考父容器，而是参考浏览器边框3、如果父容器div设置了position=absolute|relative|fixed, 父容器里面的div的绝对布局就是参考父容器边框--&gt; &lt;!-- 我们也可以使用 position: fiexd 设置div绝对布局： 任何时候div的位置都是参考浏览器--&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;img src=&quot;imgs/img01.png&quot; /&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;img src=&quot;imgs/img02.png&quot; /&gt; &lt;/div&gt; &lt;div id=&quot;div3&quot;&gt; &lt;img src=&quot;imgs/img03.png&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2.13.2 相对布局 相对布局，就是设置HTML标签（div）相对于自己原来的位置的偏移量 div的 position样式属性值为relative,通过设置left、top、right、bottom来设置div的位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* body标签在浏览器中默认是有边距，为了让body的元素可以紧挨着浏览器边缘， 我们通常对body进行padding和margin设置为0px，以消除边距 */ body&#123; padding: 0px; margin: 0px; &#125; img&#123; /* height: 200px; */ width: 200px; margin: 0px; &#125; /* div块级元素，高度默认和div中内容一样高；宽度默认和父容器一样宽 */ div&#123; border:1px solid green; width: 200px; padding: 0px; &#125; /* 相对布局：div有默认的位置 ，相对布局就是参考默认位置的偏移量 */ #div2&#123; position: relative; left: 300px; top: 200px; &#125; #div3&#123; position: relative; left: 150px; &#125; #container&#123; width: 1000px; height: 800px; background: yellow; margin: 100px; position: relative; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;img src=&quot;imgs/img01.png&quot; /&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;img src=&quot;imgs/img02.png&quot; /&gt; &lt;/div&gt; &lt;div id=&quot;div3&quot;&gt; &lt;img src=&quot;imgs/img03.png&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2.13.3 浮动布局 float样式属性，设置当前div在容器中浮动起来，浮动方式有两种（left|right） clear样式属性，可以终止浮动布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #container&#123; width: 1200px; height: 800px; border: 1px solid orange; margin: 0px auto; &#125; /* CSS复合选择器：id=container里面的div标签 */ #container div&#123;&#125; #div1&#123; width: 200px; height:250px; background: red; float: left; /* 浮动 */ &#125; #div2&#123; width: 500px; height: 200px; background: green; float: left; &#125; #div3&#123; width: 400px; height: 200px; background: blue; float: left; &#125; #div4&#123; width: 200px; height: 200px; background: purple; float: left; &#125; #div5&#123; width: 1200px; height: 100px; background: lightgray; clear: both; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt; &lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt; &lt;div id=&quot;div4&quot;&gt;div4&lt;/div&gt; &lt;div id=&quot;div5&quot;&gt;div5&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2.14 2D&amp;3D CSS3中提供一些关于HTML标签视图的2D(平面)及3D(立体)的视图转换 1.偏移 2.旋转 3.缩放 4.拉伸 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; border:1px blue solid; background: lemonchiffon; width: 300px; height: 200px; /* display: inline; 将块级元素转换成内联元素 */ &#125; /* transform样式属性用于对HTML标签进行2D和3D转换 样式属性值为函数，不同的函数实现不同的转换： 1、translate 偏移 transform: translate(200px,100px); 同时设置横向和纵向偏移 transform: translateX(250px); 设置横向偏移 transform: translateY(250px); 设置纵向偏移 */ #div1&#123; transform: translate(350px,100px); /* 相对布局 */ &#125; /* 2、rotate 旋转 函数参数为角度，单位deg transform: rotateZ(45deg); transform: rotate(45deg); 沿着Z轴（垂直于屏幕）旋转 transform: rotateX(45deg); 沿着X轴（垂直于屏幕）旋转 transform: rotateY(45deg); 沿着Y轴（垂直于屏幕）旋转 */ #div2&#123; transform: rotateY(45deg); &#125; /* 3、scale 缩放 transform: scale(0.5); 同时将原DIV宽度和高度变为原来的0.5倍 transform: scale(0.5,2); 设置宽度为原来0.5倍，高度为原来2倍 transform: scaleX(2); 单独设置宽度的缩放 transform: scaleY(2); 单独设置高度的缩放 */ #div3&#123; transform: scaleY(0.5); &#125; /* 4、skew拉伸 参数也是角度 transform: skewX(30deg); 沿着X轴拉伸 30deg transform: skewY(30deg); 沿着Y轴拉伸 30deg transform: skew(30deg,30deg); 沿着X和Y轴拉伸 30deg */ #div4&#123; transform: skew(30deg,30deg); 沿着X和Y轴拉伸 30deg &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt; &lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt; &lt;div id=&quot;div4&quot;&gt;div4&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2.15 自定义动画 可以借助于CSS实现HTML元素的动画 2.15.1 过渡1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; img&#123; width: 200px; height: 200px; border-radius: 50%; transform: rotate(0deg); /* transition 样式过渡： 参数1：过渡的样式名（样式属性名） 参数2：过渡时间 参数3：过渡效果 ease(慢-快-慢) ease-in(慢-快) ease-out(快-慢) linear(匀速) 参数4：延迟时间 */ transition: transform 5s linear -2s; &#125; img:hover&#123; transform: rotate(360deg); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;imgs/img01.png&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 2.15.2 动画 动画，就是由一帧一帧的画面连续的播放形成的 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* 定义动画 */ @keyframes xuanZhuan&#123; /* 元素的原始状态 from 0% */ 0%&#123; transform: rotate(0deg); &#125; 50%&#123; transform: rotate(180deg); &#125; /* 元素的目标状态 to 100%*/ 25%,100%&#123; transform: rotate(360deg); &#125; &#125; #img2&#123; width: 200px; height: 200px; border-radius: 50%; /* animation 应用动画: 参数1：动画名称 参数2：完成动画的时间 参数3：动画的过渡效果 参数4：动画的循环次数（整数,infinite表示无限循环） */ animation: xuanZhuan 10s linear infinite; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=&quot;img2&quot; src=&quot;imgs/img02.png&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 三、用户界面设计 如果同一个网页用户通过不同的设备（手机、平板、PC等）打开网页，我们如何保证页面显示的完整性及美观呢？ 3.1 媒体查询 使用CSS设置网页根据不同的显示设备，动态的显示不同的CSS样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123;padding: 0px;margin: 0px;&#125; /* 当屏幕最小尺寸为1800像素时，显示如下样式 */ @media screen and (min-width:1800px) &#123; div&#123; width: 1800px; height: 800px; background: lightcyan; border: 1px solid #008B8B; margin: 20px auto; &#125; &#125; /* 当屏幕大于1200像素且小于1800像素时，显示如下样式 */ @media only screen and (min-width:1200px) and (max-width:1800px) &#123; div&#123; width: 1200px; height: 800px; background: lemonchiffon; border: 1px solid #008B8B; margin: 20px auto; &#125; &#125; /* 当屏幕大于600像素且小于1200像素时，显示如下样式 */ @media only screen and (min-width:600px) and (max-width:1200px) &#123; div&#123; width: 600px; height: 800px; background: deepskyblue; border: 1px solid #008B8B; margin: 20px auto; &#125; &#125; /* 当屏幕小于等于600像素时，显示如下样式 */ @media only screen and (max-width:600px)&#123; div&#123; width: 600px; height: 800px; background: deeppink; border: 1px solid #008B8B; margin: 20px auto; &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3.2 响应式布局 不设置每行显示几个图片，每行显示的图片个数可以随着父容器的宽度而动态变化 3.2.1 浮动布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123;padding: 0px;margin: 0px;&#125; /* 当屏幕最小尺寸为1800像素时，显示如下样式 */ @media screen and (min-width:1800px) &#123; #div1&#123; width: 1540px; height: 800px; background: lightcyan; border: 1px solid #008B8B; margin: 20px auto; &#125; &#125; /* 当屏幕大于1200像素且小于1800像素时，显示如下样式 */ @media only screen and (min-width:1200px) and (max-width:1800px) &#123; #div1&#123; width: 1100px; height: 800px; background: lemonchiffon; border: 1px solid #008B8B; margin: 20px auto; &#125; &#125; /* 当屏幕大于600像素且小于1200像素时，显示如下样式 */ @media only screen and (min-width:600px) and (max-width:1200px) &#123; #div1&#123; width: 440px; height: 800px; background: deepskyblue; border: 1px solid #008B8B; margin: 20px auto; &#125; &#125; /* 当屏幕小于等于600像素时，显示如下样式 */ @media only screen and (max-width:600px)&#123; #div1&#123; width: 220px; height: 800px; background: deeppink; border: 1px solid #008B8B; margin: 20px auto; &#125; &#125; #div1 div&#123; width: 210px; height: 280px; background: whitesmoke; margin: 5px; box-shadow: gray 2px 2px 3px; float: left; &#125; img&#123; width: 200px; margin: 5px; border-radius: 5px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;div&gt;&lt;img src=&quot;imgs/img01.png&quot;/&gt;&lt;br/&gt;图片1&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img02.png&quot;/&gt;&lt;br/&gt;图片2&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img03.png&quot;/&gt;&lt;br/&gt;图片3&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img01.png&quot;/&gt;&lt;br/&gt;图片1&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img02.png&quot;/&gt;&lt;br/&gt;图片2&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img03.png&quot;/&gt;&lt;br/&gt;图片3&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img01.png&quot;/&gt;&lt;br/&gt;图片1&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img02.png&quot;/&gt;&lt;br/&gt;图片2&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img03.png&quot;/&gt;&lt;br/&gt;图片3&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img01.png&quot;/&gt;&lt;br/&gt;图片1&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img02.png&quot;/&gt;&lt;br/&gt;图片2&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img03.png&quot;/&gt;&lt;br/&gt;图片3&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img01.png&quot;/&gt;&lt;br/&gt;图片1&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img02.png&quot;/&gt;&lt;br/&gt;图片2&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img03.png&quot;/&gt;&lt;br/&gt;图片3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3.2.2 弹性盒 父容器中的子标签不设置宽度&#x2F;高度的具体值，只设置在父容器占据的宽度&#x2F;高度的比例，当父容器宽度发生变化时，子标签宽度对对应发生变化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123;padding: 0px;margin: 0px;&#125; .row&#123; width: 1200px; height: 300px; background: lightcyan; border: 1px solid #008B8B; margin: 20px auto; display: flex; /* 将父容器的div设置为弹性盒,此容器相当于一个行，容器中的每个标签相当于行中的列 */ flex-direction: row; /* 设置弹性盒主轴方向row（左-右） row-reverse(右-左) column(上-下) column-reverse(下-上) */ &#125; .row div&#123; height: 280px; background: whitesmoke; margin: 5px; box-shadow: gray 2px 2px 3px; &#125; img&#123; width: 100%; border-radius: 5px; &#125; /* flex样式属性，用于设置 弹性盒 中的标签所占的位置的比例*/ #d1&#123;flex: 1;&#125; #d2&#123;flex: 2;&#125; #d3&#123;flex: 2;&#125; #d4&#123;flex: 2;&#125; #d5&#123;flex: 2;&#125; #d6&#123;flex: 1;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;row&quot;&gt; &lt;div id=&quot;d1&quot;&gt;&lt;img src=&quot;imgs/img01.png&quot;/&gt;&lt;br/&gt;图片1&lt;/div&gt; &lt;div id=&quot;d2&quot;&gt;&lt;img src=&quot;imgs/img02.png&quot;/&gt;&lt;br/&gt;图片2&lt;/div&gt; &lt;div id=&quot;d3&quot;&gt;&lt;img src=&quot;imgs/img03.png&quot;/&gt;&lt;br/&gt;图片3&lt;/div&gt; &lt;div id=&quot;d4&quot;&gt;&lt;img src=&quot;imgs/img01.png&quot;/&gt;&lt;br/&gt;图片1&lt;/div&gt; &lt;div id=&quot;d5&quot;&gt;&lt;img src=&quot;imgs/img02.png&quot;/&gt;&lt;br/&gt;图片2&lt;/div&gt; &lt;div id=&quot;d6&quot;&gt;&lt;img src=&quot;imgs/img03.png&quot;/&gt;&lt;br/&gt;图片3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 四、CSS案例 华为商城登录页面的CSS优化 4.1 style.css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* 消除边距 */*&#123; margin: 0px; padding: 0px;&#125;/* 标题样式 */.titleTextStyle&#123; /* 字体 */ font-family: 黑体; font-size: 18px; font-weight: bold; transform: translateY(-20px); display: inline;&#125;#logo&#123; transform: translateY(10px);&#125;/* 帐号密码输入框 */.inputStyle&#123; width: 320px; height: 30px; background: #eeeeee; border-radius: 4px; border:none; padding: 10px 20px;&#125;/* 超链接样式 */a&#123; text-decoration: none;&#125;/* 登录按钮样式 */.btnStyle&#123; width: 360px; height: 50px; border-radius: 5px; border:none; background: lightcoral; color: white; font-weight: bold; font-size: 20px;&#125;/* 设置登录按钮下三个超链接样式 */.linkStyle&#123; margin-left: 30px; padding: 15px;&#125; 4.2 hw_login.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;华为商城欢迎您&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;100%&quot; height=&quot;970&quot;&gt; &lt;tr height=&quot;50&quot; bgcolor=&quot;#eeeeee&quot;&gt; &lt;td width=&quot;355&quot;&lt;/td&gt; &lt;td&gt; &lt;img src=&quot;imgs/logo.jpg&quot; height=&quot;30&quot; id=&quot;logo&quot;/&gt; &lt;div class=&quot;titleTextStyle&quot;&gt;|&amp;nbsp;千锋商城&lt;/div&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td width=&quot;355&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;150&quot;&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot; valign=&quot;bottom&quot;&gt; &lt;label style=&quot;font-size: 30px;&quot;&gt;华为帐号登录&lt;/label&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;30%&quot;&gt; &lt;img src=&quot;imgs/qrcode.png&quot; width=&quot;200&quot; height=&quot;200&quot; /&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;label style=&quot;font-size: 10px; color: lightgray;&quot;&gt;若您使用华为手机，请进入“设置”&gt;“华为帐号”扫码登录。&lt;/label&gt; &lt;/td&gt; &lt;td width=&quot;30%&quot;&gt; &lt;table height=&quot;420&quot; width=&quot;360&quot;&gt; &lt;tr&gt; &lt;td &gt; &lt;input type=&quot;text&quot; class=&quot;inputStyle&quot; placeholder=&quot;手机号/邮箱地址/账号名&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td &gt; &lt;input type=&quot;password&quot; class=&quot;inputStyle&quot; placeholder=&quot;密码&quot;/&gt; &lt;div style=&quot;margin-top: 20px;&quot;&gt; &lt;a href=&quot;#&quot;&gt;短信验证码登录&lt;/a&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; class=&quot;btnStyle&quot; value=&quot;登录&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;80&quot;&gt; &lt;td align=&quot;center&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;linkStyle&quot;&gt;注册&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;linkStyle&quot;&gt;忘记密码&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;linkStyle&quot;&gt;遇到问题&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt; &lt;img src=&quot;imgs/qq.png&quot; /&gt; &lt;img src=&quot;imgs/zfb.png&quot; /&gt; &lt;img src=&quot;imgs/wx.png&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;150&quot;&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;100&quot; bgcolor=&quot;#eeeeee&quot;&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot; valign=&quot;middle&quot;&gt; &lt;a href=&quot;#&quot;&gt;华为帐号用户协议&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;关于华为帐号与隐私的声明&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;常见问题&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;Cookies&lt;/a&gt; &lt;br/&gt; 华为帐号 版权所有 © 2011-2021 &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"day01-JavaWebGuide","slug":"day01-JavaWebGuide","date":"2022-09-16T15:28:00.000Z","updated":"2022-10-05T06:35:48.777Z","comments":true,"path":"2022/09/16/day01-JavaWebGuide/","link":"","permalink":"http://example.com/2022/09/16/day01-JavaWebGuide/","excerpt":"","text":"一、Java web是什么？1.1 Java web概念 Java web指的是使用Java语言进行web互联网领域项目开发的技术栈——进行web项目开发所需的技术的集合： web前端——在浏览器中用户可以看到的网页 web后端——为前端提供数据的程序 1.2 Web项目 Java语言是可以进行多种类型的项目的开发 Java ME 嵌入式应用程序 （功能手机系统内置应用——俄罗斯方块、贪吃蛇） Java SE 窗体应用程序（下载—安装—双击打开） Android SDK 移动应用开发 HarmonyOS SDK 移动应用开发 Java EE 企业级项目开发（web项目） web项目 - 使用浏览器访问的软件系统 二、Java web学什么？2.1 web项目的结构 2.2 Java web技术体系 1.Java语言基础 Java基本语法：标识符、关键字、运算符、表达式、流程控制、数据类型 Java OOP： 类、属性、方法、对象，抽象继承封装多态 封装类：日期、Math、String、封装类 集合：List、Set、Iterator、Map JavaSE高级：IO、线程、网络 2.数据库 MySQL MySQL下载、安装、配置 SQL 结构化查询语言 添加、查询、修改、 删除 高级使用：存储过程、索引 数据库设计&#x2F;建模 数据库设计案例 3.数据库编程 JDBC 数据库编程介绍 JDBC步骤及实现 JDBCUtil工具类封装 DAO与DTO 4.web前端 网页设计 HTML 超文本标记语言 CSS 层叠样式表 JavaScript 脚本语言 AJAX 异步交互 BootStrap 样式框架 jQuery JS框架 5.Servlet&#x2F;JSP ​ 一种可以将网页数据提交到Java程序，并且将Java程序的数据显示到网页的技术 Tomcat、HTTP Servlet、JSP","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"JavaWebGuide","slug":"JavaWebGuide","permalink":"http://example.com/tags/JavaWebGuide/"}]},{"title":"day04-HTML","slug":"day04-HTML","date":"2022-09-13T16:50:10.000Z","updated":"2022-10-01T03:08:49.435Z","comments":true,"path":"2022/09/14/day04-HTML/","link":"","permalink":"http://example.com/2022/09/14/day04-HTML/","excerpt":"","text":"一、C&#x2F;S架构与B&#x2F;S架构 对于一个软件系统，用户是通过用户界面来完成与软件系统的交互的（用户是通过用户界面来使用软件系统的），根据软件不同的架构模式，软件系统界面设计的实现技术是不同的： C&#x2F;S架构 B&#x2F;S架构 1.1 C&#x2F;S架构 C&#x2F;S Client-Server 基于客户端和服务器的架构模式 1.2 B&#x2F;S架构 B&#x2F;S Browser-Server 基于浏览器和服务器的架构模式 1.3 不同架构的前端技术栈1.3.1 C&#x2F;S Java语言可以进行C&#x2F;S架构开发，JDK提供的AWT（abstract window toolkit）可以进行窗体开发 awt swing 1.3.2 B&#x2F;S Java语言主要应用于web系统的开发，web系统就是基于B&#x2F;S架构，其系统界面都是通过网页实现的 HTML 超文本标记语言 网页的结构 CSS 层叠样式表 网页的样式 JavaScript 网页脚本语言 网页的行为 1.3.3 移动应用 Java语言还可以用于进行Android和HarmonyOS应用开发 AndroidUI xml及组件 HarmonyOSUI xml及组件 二、HTML简介2.1 什么是网页？ 网页 —— 可以在网络中传输、通过浏览器解析并显示视图的页面 问题：一个文件通过网络传递给浏览器之后，浏览器是如何显示视图的呢？ 存储在服务器上的页面文件中编写的是浏览器可以识别的代码 当浏览器请求服务器时，服务器将这个写有浏览器可以识别的代码的页面文件通过网络传递给浏览器 浏览器接收到文件后，不会将代码显示出来，而是对代码进行解析，显示出对应的视图 网页设计：就是在网页文件中编写HTML代码(标签)，通过浏览器可以显示特定的用户界面 2.2 HTML是什么？ HTML （Hyper Text Markup Language）超文本标记语言。以特定的标签在浏览器中呈现不同的视图 标记（标签）：就是由&lt;&gt;和特定的单词组成的符号，可以被浏览器识别并显示对应的视图 超文本：使用文本标签显示图片、视频、声音等非文本数据 2.3 HTML书写规范 HTML标签需要写在一个网页文件中，网页文件的规则： 网页文件是一个后缀名为.html或者.htm的文件 网页文件有一个基本结构： 在网页文件第一行通过&lt;!DOCTYPE html&gt;声明当前文档遵循的HTML规范 在HTML规范声明之后，必须有一对根标签&lt;html&gt;&lt;/html&gt;（根标签：当前网页中其他的标签都在根标签的里面） 在根标签中，有两对子标签&lt;head&gt;&lt;/head&gt;和&lt;body&gt;&lt;/body&gt; head标签：用于定义当前网页文档的标题、字符集等属性信息 body标签：用于定义当前网页显示的主体内容 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;title&gt;我的第一个网页&lt;/title&gt; &lt;/head&gt; &lt;body bgcolor=&quot;red&quot;&gt; &lt;input type=&quot;password&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 标签： 双标签（围堵标签） 单标签 标签属性：在双标签前一个标签中、单标签的标签名后可以添加键值对，用于设置当前标签的特性 HTML标签是不区分大小写的，为了便于可读，建议统一写成小写 HTML版本规范 前端规范— w3c HTML4 &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; XHTML 提出了基于HTML4更多的语法规则，让HTML编写规范更严谨 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot; http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; HTML5 &lt;!DOCTYPE html&gt; 2.4 前端开发工具 为了便于前端开发，有很多的前端开发工具，可以为我们进行网页设计提供代码自动补全、代码错误提示、项目文件管理等功能，常见的工具： webStorm vsCode subline HBuilder –HBuilderX HBuilderX的使用 下载：www.dcloud.io 解压：解压到存放软件的目录（免安装） 运行： 首次运行，需要对HBuilderX进行用户使用习惯设置（主题） 第一次关闭HBuilderX的时候，会提示创建桌面快捷方式 创建web项目 创建网页文件：选择项目—右键—新建—HTML文件 创建的HTML文件默认会给出规范的网页文件结构 运行网页文件： 三、HTML常用标签 网页就是使用HTML标签构成的文档，在浏览器显示视图页面。HTML什么样的标签表示什么样的是呢？ 网页界面：显示数据、输入数据 为用户提供一个界面，显示用户想要看到的数据（文本、图片、声音、视频） 为用户提供一个界面，可以输入数据（发表博客：输入文本、选择图片、点击按钮） 如何使用HTML标签在网页中显示数据和提供输入视图呢？ 根据HTML标签的作用，我们将HTML标签分为以下： 显示标签：就是将图片、文本、声音、视频通过网页呈现给用户 表单标签：就是给用户提供输入框、按钮、单选按钮、复选框、文本域等视图供其输入数据 布局标签：对网页中的内容进行布局&#x2F;排版 功能标签：能够提供特定用户功能的标签 框架标签：搭建页面框架（输入布局标签） 3.1 显示标签 将文本、图片、声音和视频显示到网页 3.1.1 文本12345678&lt;!--显示文本--&gt;&lt;!-- font标签：color属性设置颜色，fase属性设置字体，size属性设置大小 --&gt;&lt;font color=&quot;red&quot; face=&quot;华文行楷&quot; size=&quot;7&quot;&gt;千锋教育&lt;/font&gt;&lt;font color=&quot;blue&quot; face=&quot;微软雅黑&quot; size=&quot;4&quot;&gt;Java涛哥&lt;/font&gt;&lt;!-- H5不推荐使用font标签，显示文本推荐使用label标签 --&gt;&lt;!-- label标签没有字体属性，但是可以通过style属性值设置字体颜色、大小、样式 --&gt;&lt;label style=&quot;color:green;font-size:100px;font-family:楷体&quot;&gt;网页设计&lt;/label&gt; 3.1.2 图片123456789&lt;!-- 显示图片 --- img标签： src属性用于指定显示的图片的路径，可以是网络图片路径，也可以本地图片路径 (本地图片：先在项目中创建一个存放图片的目录imgs，再将要显示的图片拷贝进来 ) width、hegiht属性,设置图片的宽度、高度 ,如果两个属性同时设置可能会改变图片的比例 可以只设置其中一个属性，另一个属性会等比缩放 alt属性，用于指定图片无法加载时的替换文本--&gt;&lt;img src=&quot;http://www.qfedu.com/images/new_logo.png&quot;/&gt;&lt;img src=&quot;imgs/logo.jpg&quot; height=&quot;200&quot; alt=&quot;千锋LOGO&quot;/&gt; 3.1.3 声音和视频1234567891011121314&lt;!--audio标签 调用浏览器内置的音频播放器（默认是隐藏的） src属性指定音频的路径（网络路径、本地路径） controls属性表示显示播放器（此属性不需要属性值） autoplay属性表示音乐自动播放（考虑浏览器兼容性）--&gt;&lt;audio src=&quot;meida/麻雀.mp3&quot; controls autoplay&gt;&lt;/audio&gt;&lt;!--video标签 调用浏览器内置的视频播放器（默认是隐藏的） src属性指定视频的路径（网络路径、本地路径） controls属性表示显示播放器的控制条（此属性不需要属性值） autoplay属性表示视频自动播放（考虑浏览器兼容性） width、height属性设置视频播放器的尺寸--&gt;&lt;video src=&quot;meida/Java学科宣传片.mp4&quot; controls autoplay width=&quot;400&quot;&gt;&lt;/video&gt; 3.2 表单标签 用户提供输入视图供其输入数据： 3.2.1 input标签 input标签可以用来显示多种表单输入视图效果，input标签有一个type属性，不同的属性表示不同的视图 123456789101112131415161718192021- 文本输入框：&lt;input type=&quot;text&quot;/&gt;&lt;br/&gt;- 密码输入框：&lt;input type=&quot;password&quot;/&gt;&lt;br/&gt;- 单选按钮：&lt;input type=&quot;radio&quot;/&gt;&lt;br/&gt;- 复选框：&lt;input type=&quot;checkbox&quot;/&gt;&lt;br/&gt;- 文件选择框：&lt;input type=&quot;file&quot;/&gt;&lt;br/&gt;&lt;!-- 普通按钮默认是没有文本的，通过value属性指定按钮文本 --&gt;-普通按钮：&lt;input type=&quot;button&quot; value=&quot;点我呀！&quot;/&gt;&lt;br/&gt;-重置按钮：&lt;input type=&quot;reset&quot;/&gt;&lt;br/&gt;-提交按钮：&lt;input type=&quot;submit&quot;/&gt;&lt;br/&gt;&lt;!-- 图片按钮从功能讲和提交按钮一致，需要通过src属性指定按钮图片 --&gt;-图片按钮：&lt;input type=&quot;image&quot; src=&quot;imgs/btn.bmp&quot;/&gt;&lt;br/&gt;&lt;!-- 以下input的type是HTML5新增的 ,要考虑浏览器的兼容性（浏览器是否支持）--&gt;&lt;!-- type=number ，表示次输入框只能输入数字，min设置最小值，max设置最大值--&gt;- 数字输入框：&lt;input type=&quot;number&quot; min=&quot;10&quot; max=&quot;20&quot;/&gt;&lt;br/&gt;- 日期输入框：&lt;input type=&quot;date&quot;/&gt;&lt;br/&gt;- 颜色选择框：&lt;input type=&quot;color&quot;/&gt;&lt;br/&gt;- 邮箱输入框：&lt;input type=&quot;email&quot;/&gt;&lt;br/&gt;- 电话输入框：&lt;input type=&quot;tel&quot;/&gt;&lt;br/&gt;- 搜索输入框：&lt;input type=&quot;search&quot;/&gt;&lt;br/&gt; 单选按钮和复选框： 123456789101112131415&lt;hr/&gt;&lt;!-- 单选按钮使用注意事项：1.如果多个单选按钮是同一个主题的选项，则需要提供name属性，且那么属性值必须相同（排他性）2.单选按钮必须提供value属性，value属性值会在当前单选按钮被选中时提交3.单选按钮可以通过添加checked属性使其默认被选中，如果有多个单选按钮添加checked属性，则选中最后一个--&gt;性别：&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;M&quot; checked/&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;F&quot;/&gt;女&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;N&quot; /&gt;不详&lt;hr/&gt;&lt;!-- 复选框注意事项（与单选按钮一致） --&gt;爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;篮球&quot; checked/&gt;篮球&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;足球&quot;/&gt;足球&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;羽毛球&quot; checked/&gt;羽毛球&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;溜溜球&quot;/&gt;溜溜球 3.2.2 select标签 下拉菜单（省、市、区选择） 12345678910111213141516&lt;!-- select标签表示下拉菜单的容器1.添加multiple属性，设置此下拉菜单多选（ctrl）2.size属性，设置下拉列表中可见选项的数量option子标签表示下拉菜单的选项1.option标签中的标签文本用于指定选项显示的文字2.option标签需要提供value属性，当选择此菜单式提交到后台--&gt;&lt;select multiple size=&quot;3&quot;&gt; &lt;option value=&quot;BeiJing&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;ShangHai&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;GuangZhou&quot;&gt;广州&lt;/option&gt; &lt;option value=&quot;ShenZhen&quot;&gt;深圳&lt;/option&gt; &lt;option value=&quot;WuHan&quot;&gt;武汉&lt;/option&gt;&lt;/select&gt; 3.2.3 textarea标签 文本域、多行文本框 123456&lt;!-- 多行输入框 textarea标签：1、rows属性用于指定多行文本框显示的行数2、cols属性用于设置多行文本输入框每行显示的字符个数（考虑浏览器兼容性）3、输入框（文本输入框、密码输入框）是通过value属性来设置默认值的，textarea通过标签文本设置默认值--&gt;&lt;textarea rows=&quot;5&quot; cols=&quot;30&quot;&gt;这是文本域的默认值&lt;/textarea&gt; 3.2.4 表单标签共有属性 对于表单标签，他们有一些共有属性 id属性，不仅是表单标签共有的属性，几乎所有的HTML标签都可以有这个属性，它表示此标签在当前网页文件中的唯一表示，便于我们定位标签进行操作；在一个网页中标签的ID属性值要保持唯一性。 name属性，用于将数据提交（同步提交）到后端时，在后端接收数据。 required属性，设置此输入框必须输入数据，否则不能提交。 1234&lt;form&gt; &lt;input type=&quot;text&quot; required=&quot;required&quot;/&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; placeholder属性，用于设置输入框空值提示信息。 readonly属性，表示设置此输入框，只能显示数据，不能点击输入。 disabled属性，设置输入组件禁用（输入框不能输入、按钮不能点击、下拉菜单不能选择）。 value属性，表示当前输入框的值、下拉菜单选中的选项的值。 3.2.5 form标签 form标签，在页面中没有显示效果，它用于将用户在输入视图中输入的数据提交到后台 123456789101112131415161718&lt;!-- form标签：用于提交数据的表单 作用：当点击form标签中的提交按钮时，可以将form标签中输入视图中的数据提交到action属性指定的url注意：1.提交form表单的按钮必须是提交按钮（type=submit，type=image） 2.form表单中的输入标签需要提供name属性，否则输入标签中的值不会被提交 3.form标签的method属性，指定表单提交数据的方式（get显式提交 post隐藏提交；其他区别暂不关注） method属性默认值是get，也就是说如果不写method属性，则get方式提交 4.enctype属性，用于设置表单提交时数据的编码方式重置按钮： 必须在form表单中使用，用于重置表单中输入框的值（让输入框的值回到默认状态 ≠ 清空）提交按钮： 必须用在form表单中，用于提交表单 --&gt;&lt;form action=&quot;https://www.baidu.com&quot; method=&quot;post&quot; enctype=&quot;&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入帐号&quot; name=&quot;userName&quot; value=&quot;123&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; name=&quot;userPwd&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;reset&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;&lt;/form&gt; 在HTML5规范中，提交按钮也可以写在form外面,但是要通过form属性指定表单id 12345678&lt;form id=&quot;form1&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入帐号&quot; name=&quot;userName&quot; value=&quot;123&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; name=&quot;userPwd&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;reset&quot; /&gt;&lt;br/&gt;&lt;/form&gt;&lt;!--对于同一个form，可以使用不同的提交按钮，提交到不同的URL--&gt;&lt;input type=&quot;submit&quot; value=&quot;登录1&quot; form=&quot;form1&quot; formaction=&quot;https://www.baidu.com&quot; formmethod=&quot;get&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;登录2&quot; form=&quot;form1&quot; formaction=&quot;http://www.qfedu.com&quot; formmethod=&quot;post&quot;/&gt;&lt;br/&gt; 3.3 布局标签 用于对网页中的视图组件进行排版 3.3.1 标题 h标签提供了默认的标题样式,HTML中提供了 h1~h6 用于表示6级标题 123456&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt; 3.3.2 段落 p标签： HTML可以将文档分割成多个段落 hr标签： 水平分割线 br标签：换行 1234567891011121314151617&lt;hr/&gt;&lt;p&gt; 枫桥夜泊&lt;br/&gt; 张继&lt;br/&gt; 月落乌啼霜满天，&lt;br/&gt; 江枫渔火对愁眠；&lt;br/&gt; 姑苏城外寒山寺，&lt;br/&gt; 夜半钟声到客船。&lt;br/&gt;&lt;/p&gt;&lt;p&gt; 静夜思&lt;br/&gt; 李白&lt;br/&gt; 床前明月光，&lt;br/&gt; 疑是地上霜；&lt;br/&gt; 举头望明月，&lt;br/&gt; 低头思故乡。&lt;br/&gt;&lt;/p&gt; 3.3.3 列表 将相关联的多行文本以列表的形式进行展示 1.有序列表 12345678910水龙头接水的步骤：&lt;!-- ol标签表示有序列表，li子标签表示列表项 --&gt;&lt;!-- type属性用于指定序号的类型 1 A a I i--&gt;&lt;ol type=&quot;i&quot;&gt; &lt;li&gt;放置水桶&lt;/li&gt; &lt;li&gt;打开水龙头&lt;/li&gt; &lt;li&gt;等待放水&lt;/li&gt; &lt;li&gt;关闭水龙头&lt;/li&gt; &lt;li&gt;提走水桶&lt;/li&gt;&lt;/ol&gt; 2.无序列表 12345678910水果列表&lt;!-- ul标签表示无序列表，li子标签表示列表项 --&gt;&lt;!-- type属性用于指定图标的类型 disc实心圆 circle空心圆 square方形实心 --&gt;&lt;ul type=&quot;square&quot;&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;菠萝&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;li&gt;火龙果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt;&lt;/ul&gt; 3.自定义列表 123456789自定义列表&lt;dl&gt; &lt;dt&gt;分组1&lt;/dt&gt; &lt;dd&gt;1-1&lt;/dd&gt; &lt;dd&gt;1-2&lt;/dd&gt; &lt;dt&gt;分组2&lt;/dt&gt; &lt;dd&gt;2-1&lt;/dd&gt; &lt;dd&gt;2-2&lt;/dd&gt;&lt;/dl&gt; 3.3.4 表格 在网页中显示一个表格，通过将页面的HTML元素存放在表格的不同单元格，以达到设置元素布局的效果 123456789101112131415161718192021222324252627282930313233343536&lt;!-- table标签：用于在网页中定义一个表格 ，表格是由若干行组成，行被分割成多个单元格--&gt;&lt;!-- 表格（table）:table中的属性设置的是整个表格的属性 border属性：设置表格的边框宽度（同时设置表格外边框，以及每个单元格的边框） cellspacing属性：设置单元格空隙 cellpadding属性：设置当前表格中单元格的内边距 width、height属性：设置当前表格的宽度、高度 align属性：设置当前表格在网页中的水平位置（left|center|right） bgcolor属性：设置表格的背景颜色 background属性：设置当前表格的背景图片行（tr）：用在table标签里面，一对tr标签就表示表格中的一行 ，tr的属性设置影响当前行 height属性：设置当前行的高度，如果不设置行高，则平均分配 bgcolor属性：设置当前行的背景颜色单元格（td）：写在tr标签，一对td标签就表示当前行中的一个单元格 ,每一行的对应列都会自动对齐 width属性：设置当前单元格的宽度，设置某一行的单元格宽度，其他行对应单元格宽度同步修改 bgcolor属性：设置当前单元格的背景颜色 valign属性：设置当前单元格中的内容在当前单元格中的垂直位置（middle、top、bottom） align属性：设置当前单元格中的内容在当前单元格中的水平位置（left、center、right） colspan属性：横向合并单元格（设置当前单元格占用几个单元格的宽度） rowspan属性：纵向合并单元格（设置当前单元格占用几行的高度）--&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;300&quot; height=&quot;300&quot; align=&quot;center&quot; bgcolor=&quot;orange&quot;&gt; &lt;tr height=&quot;50&quot; bgcolor=&quot;aqua&quot;&gt; &lt;td colspan=&quot;2&quot;&gt;1-1&lt;/td&gt; &lt;td width=&quot;50&quot; rowspan=&quot;2&quot;&gt;1-3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;50&quot; rowspan=&quot;2&quot;&gt;2-1&lt;/td&gt; &lt;td valign=&quot;bottom&quot; align=&quot;right&quot;&gt;2-2&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;50&quot;&gt; &lt;td colspan=&quot;2&quot;&gt;3-2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 3.3.5 div层 区块元素（标签），在浏览器中进行显示的时候，通常会有换行 （例如：段落p、表格table…） 内联元素（标签），在浏览器中进行显示的时候，不会进行换行（例如：label img） 1234567891011121314151617181920&lt;!-- div标签：层，一个HTML标签的容器 1.如果不设置宽度，则默认宽度为父容器的宽度（如下：body就是div的父容器）2.如果不设置高度，则DIV的高度默认与其中存放的元素高度相同3.div中可以包含HTML标签，我通过对DIV标签的设置可以实现HTML标签的层叠--&gt;&lt;!-- &lt;img src=&quot;imgs/img01.png&quot; height=&quot;100&quot;/&gt;&lt;img src=&quot;imgs/img02.png&quot; height=&quot;100&quot;/&gt;&lt;img src=&quot;imgs/img03.png&quot; height=&quot;100&quot;/&gt; --&gt;&lt;div style=&quot; width: 83px; height: 100px; border: 1px solid red; position: absolute; left: 0px; top:0px&quot;&gt; &lt;img src=&quot;imgs/img01.png&quot; height=&quot;100&quot;/&gt;&lt;/div&gt;&lt;div style=&quot; width: 83px; height: 100px; border: 1px solid green; position: absolute; left: 50px; top:50px&quot;&gt; &lt;img src=&quot;imgs/img02.png&quot; height=&quot;100&quot;/&gt;&lt;/div&gt;&lt;div style=&quot; width: 83px; height: 100px; border: 1px solid blue; position: absolute;left: 100px; top: 100px;&quot;&gt; &lt;img src=&quot;imgs/img03.png&quot; height=&quot;100&quot;/&gt;&lt;/div&gt; 3.3.6 fieldset字段集1234567&lt;!-- fieldset标签：网页中的模块，也是一个容器，默认带有边框,有内边距 --&gt;&lt;!-- legend子标签：用于设置当前模块区域的标题 --&gt;&lt;fieldset style=&quot;width: 300px; height: 100px;&quot;&gt; &lt;legend&gt;🏀管理员登录&lt;/legend&gt; &lt;p&gt;帐号：&lt;input type=&quot;text&quot;/&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot;/&gt;&lt;/p&gt;&lt;/fieldset&gt; 3.4 功能标签 功能标签，在网页中没有对应的视图效果，但是可以实现特定的功能 form表单，用于提交用户输入数据的 a超链接 3.4.1 form表单参考3.2.5 3.4.2 a 标签超链接 激活文本可点击，当点击这个特定的文本之后，链接到对应的地址 1234&lt;!-- a标签（超链接）：激活文本/图片连接href 属性指定当前文本/图片链接的地址--&gt;学Java开发就来&lt;a href=&quot;http://www.qfedu.com&quot;&gt;千锋教育&lt;/a&gt; &lt;br/&gt;&lt;a href=&quot;https://www.baidu.com/s?wd=张韶涵&quot;&gt;&lt;img src=&quot;imgs/img01.png&quot; height=&quot;50&quot;/&gt;&lt;/a&gt; 锚点 用于当前页面不同位置的跳转 123456789101112131415161718&lt;hr/&gt;&lt;a href=&quot;#aaa&quot;&gt;div1&lt;/a&gt;&lt;!-- 跳转到锚点 --&gt;&lt;a href=&quot;#bbb&quot;&gt;div2&lt;/a&gt;&lt;a href=&quot;#ccc&quot;&gt;div3&lt;/a&gt;&lt;a href=&quot;#ddd&quot;&gt;div4&lt;/a&gt;&lt;hr/&gt;&lt;a id=&quot;aaa&quot;&gt;&lt;/a&gt;&lt;!-- 定义锚点 --&gt;&lt;div style=&quot;height: 1000px; background-color: aquamarine;&quot;&gt;div1&lt;/div&gt;&lt;a id=&quot;bbb&quot;&gt;&lt;/a&gt;&lt;!-- 定义锚点 --&gt;&lt;div style=&quot;height: 1000px; background-color: lawngreen;&quot;&gt;div2&lt;/div&gt;&lt;a id=&quot;ccc&quot;&gt;&lt;/a&gt;&lt;!-- 定义锚点 --&gt;&lt;div style=&quot;height: 1000px; background-color: palevioletred;&quot;&gt;div3&lt;/div&gt;&lt;a id=&quot;ddd&quot;&gt;&lt;/a&gt;&lt;!-- 定义锚点 --&gt;&lt;div style=&quot;height: 1000px; background-color: peru;&quot;&gt;div4&lt;/div&gt; 3.5 框架标签-iframe 框架标签，实现页面的模块化 frameset frame 不建议使用 iframe 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table width=&quot;100%&quot; height=&quot;880&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; &gt; &lt;tr height=&quot;80&quot; bgcolor=&quot;lightblue&quot;&gt; &lt;td align=&quot;center&quot;&gt; &lt;label style=&quot;font-size: 40px;&quot;&gt;QQMail&lt;/label&gt; &lt;/td&gt; &lt;td align=&quot;right&quot; valign=&quot;top&quot;&gt; 二狗，欢迎你！[&lt;a href=&quot;#&quot;&gt;退出&lt;/a&gt;] &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;200&quot; bgcolor=&quot;lightgray&quot; valign=&quot;top&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;page02-表单标签.html&quot; target=&quot;mainFrame&quot;&gt;新邮件&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.taobao.com&quot; target=&quot;mainFrame&quot;&gt;淘宝&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://www.qfedu.com&quot; target=&quot;mainFrame&quot;&gt;千锋&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;td&gt; &lt;!-- iframe标签，表示一个页面的容器,通过name属性可以设置点击超链接以后，将页面显示到当前容器 1.给iframe标签设置name属性 2.给超链接a标签设置target等于iframe的name属性值 --&gt; &lt;iframe name=&quot;mainFrame&quot; width=&quot;100%&quot; height=&quot;800&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 3.6 其他标签3.6.1 文本修饰123456789101112&lt;b&gt;粗体&lt;/b&gt;&lt;i&gt;斜体&lt;/i&gt;&lt;u&gt;下划线&lt;/u&gt;&lt;del&gt;删除线&lt;/del&gt;&lt;strong&gt;加重语气&lt;/strong&gt;&lt;em&gt;强调&lt;/em&gt;&lt;small&gt;小号文本&lt;/small&gt;10&lt;sup&gt;上标&lt;/sup&gt;4&lt;sub&gt;下标&lt;/sub&gt; 3.6.2 计算机输出相关12345&lt;!-- 计算机输出标签，除了字体有所改变之外，更多的是语义上的设定 --&gt;&lt;code&gt;System.out.println(&quot;计算机代码!&quot;);&lt;/code&gt;&lt;kbd&gt;Ctrl+L&lt;/kbd&gt;&lt;var&gt;程序变量&lt;/var&gt;&lt;pre&gt;预定义&lt;/pre&gt; 3.6.3 引用标签1234&lt;address&gt;湖北省武汉市江夏区&lt;/address&gt;跟着涛哥一起学习&lt;abbr title=&quot;Java DataBase Conectivity&quot;&gt;JDBC&lt;/abbr&gt;技术&lt;bdo dir=&quot;rtl&quot;&gt;定义文字方向&lt;/bdo&gt;毛泽东同志说：&lt;blockquote&gt;生的伟大，死的光荣！&lt;/blockquote&gt; 四、HTML页面设计案例 案例：使用HTML标签，完成华为商城的登录页面的设计 4.1 模仿页面分析 4.2 按照分析进行网页设计12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;华为商城欢迎您&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;100%&quot; height=&quot;960&quot;&gt; &lt;tr height=&quot;40&quot; bgcolor=&quot;#eeeeee&quot;&gt; &lt;td width=&quot;355&quot;&lt;/td&gt; &lt;td&gt; &lt;img src=&quot;imgs/logo.jpg&quot; height=&quot;30&quot;/&gt;|千锋商城 &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td width=&quot;355&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;150&quot;&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;label style=&quot;font-size: 30px;&quot;&gt;华为帐号登录&lt;/label&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;30%&quot;&gt; &lt;img src=&quot;imgs/qrcode.png&quot; width=&quot;200&quot; height=&quot;200&quot; /&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;label style=&quot;font-size: 10px; color: lightgray;&quot;&gt;若您使用华为手机，请进入“设置”&gt;“华为帐号”扫码登录。&lt;/label&gt; &lt;/td&gt; &lt;td width=&quot;30%&quot;&gt; &lt;table height=&quot;320&quot; width=&quot;400&quot;&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt;&lt;input type=&quot;text&quot; placeholder=&quot;手机号/邮箱地址/账号名&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt; &lt;input type=&quot;password&quot; placeholder=&quot;密码&quot;/&gt; &lt;br/&gt; &lt;a href=&quot;#&quot;&gt;短信验证码登录&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt; &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;忘记密码&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;遇到问题&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt; &lt;img src=&quot;imgs/qq.png&quot; /&gt; &lt;img src=&quot;imgs/zfb.png&quot; /&gt; &lt;img src=&quot;imgs/wx.png&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;150&quot;&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;100&quot; bgcolor=&quot;#eeeeee&quot;&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot; valign=&quot;middle&quot;&gt; &lt;a href=&quot;#&quot;&gt;华为帐号用户协议&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;关于华为帐号与隐私的声明&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;常见问题&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;Cookies&lt;/a&gt; &lt;br/&gt; 华为帐号 版权所有 © 2011-2021 &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 案例运行效果图","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-09-03T02:44:45.202Z","updated":"2022-10-14T16:18:21.193Z","comments":true,"path":"2022/09/03/hello-world/","link":"","permalink":"http://example.com/2022/09/03/hello-world/","excerpt":"","text":"First,my name is bitezhang,you can call me 杰哥. Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 1，生成新的文章代码： 12hexo new &quot;page&quot;（代码中标点符号都为英文）文件会生成在source/_posts之下_ 2，本地预览指令： 1hexo s 3，上传指令： 123先 hexo g 再 hexo d或hexo g -d （这两个指令执行之后，网页就会自动更新） 4，新建页面 1hexo new page &quot;页面名&quot; 会生成一个文件夹","categories":[{"name":"HelloWorld","slug":"HelloWorld","permalink":"http://example.com/categories/HelloWorld/"}],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/tags/Hello-World/"}]}],"categories":[{"name":"C语言基础知识","slug":"C语言基础知识","permalink":"http://example.com/categories/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"},{"name":"HelloWorld","slug":"HelloWorld","permalink":"http://example.com/categories/HelloWorld/"}],"tags":[{"name":"C语言基础-3","slug":"C语言基础-3","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-3/"},{"name":"C语言基础-2","slug":"C语言基础-2","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2/"},{"name":"C语言基础-1","slug":"C语言基础-1","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-1/"},{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"},{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"},{"name":"JSP","slug":"JSP","permalink":"http://example.com/tags/JSP/"},{"name":"Servlet","slug":"Servlet","permalink":"http://example.com/tags/Servlet/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"JavaWebGuide","slug":"JavaWebGuide","permalink":"http://example.com/tags/JavaWebGuide/"},{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"},{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/tags/Hello-World/"}]}