{"meta":{"title":"比特张的博客","subtitle":"beiying","description":"个人学习博客","author":"bitezhang","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-09-11T12:12:41.773Z","updated":"2022-09-11T12:12:41.773Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"有什么想对我说的可以在下面留言。"},{"title":"所有分类","date":"2022-09-10T16:18:33.643Z","updated":"2022-09-10T16:18:33.643Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-09-10T16:19:24.645Z","updated":"2022-09-10T16:19:24.645Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-09-10T16:18:45.503Z","updated":"2022-09-10T16:18:45.503Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2022-09-11T11:59:40.103Z","updated":"2022-09-11T11:59:40.103Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2022-09-11T12:13:59.140Z","updated":"2022-09-11T12:13:59.140Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 &#123;% p center bold, 很抱歉，您访问的页面不存在 %&#125; &#123;% p center small, 可能是输入地址有误或该地址已被删除 %&#125; 加我微信:print_sincerity kiss kiss!"}],"posts":[{"title":"day03-jdbc","slug":"day03-jdbc","date":"2022-09-08T09:33:04.000Z","updated":"2022-09-12T02:00:21.587Z","comments":true,"path":"2022/09/08/day03-jdbc/","link":"","permalink":"http://example.com/2022/09/08/day03-jdbc/","excerpt":"","text":"一、JDBC介绍 JDBC (Java DataBase Contectivity) Java与数据库的连接——数据库编程 JDBC 是Java语言（JDK）为完成数据库的访问操作提供的一套统一的标准。 二、JDBC步骤 三、JDBC入门案例 JDBC 是用Java代码完成数据访问的规范 3.1 加载驱动3.1.1 下载驱动jar包 对应数据库匹配版本的驱动jar包 地址https://mvnrepository.com/ 搜索mysql 选择版本下载 MySQL数据库版本为5.x,驱动jar包建议使用5.1.47 MySQL数据库版本为8.x,驱动jar包建议使用8.0.x 3.1.2 将驱动jar文件添加到Java应用 在java应用中创建lib文件夹 将下载好的jar文件拷贝—粘贴到lin目录 将驱动jar文件设置为java库：选择lib&#x2F;驱动jar—右键—Add as Library.. —OK 3.1.3 注册驱动 通过反射机制，将驱动jar文件中提供的驱动类载入到JVM中 12//1.注册驱动（驱动jar包中的驱动类（Driver）的路径：com.mysql.cj.jdbc.Driver）Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); 3.2 创建连接12345678910//2.创建连接：通过数据库驱动管理器 DriverManager（java.sql.Driver）获取连接// JDBC JDK提供的数据库连接的规范 --- java.sql// java.sql.Connection接口 一个对象就表示一个数据库连接// url 数据库的统一资源定位器（定位数据库连接资源）// url参数// characterEncoding 设置编码// useSSL=true 使用SSL通信// useTimezone=true 设置客户端和服务端时区转换String url = &quot;jdbc:mysql://localhost:3306/db_test3&quot;;Connection connection = DriverManager.getConnection(url,&quot;root&quot;,&quot;@QFedu123&quot;); 3.3 编写SQL指令12//3.编写要执行的SQL指令:SQL指令中需要的参数可以通过字符串拼接的形式（会导致SQL注入）String sql = &quot;insert into books(book_id,book_name,book_author,book_price,book_stock,book_desc) values(&#x27;&quot;+id+&quot;&#x27;,&#x27;&quot;+name+&quot;&#x27;,&#x27;&quot;+author+&quot;&#x27;,&quot;+price+&quot;,&quot;+stock+&quot;,&#x27;&quot;+desc+&quot;&#x27;)&quot;; 3.4 加载SQL指令1234//4.加载SQL指令:获取SQL指令的加载器// java.sql.Statement 对象 可以理解为 SQL指令的“加载器”// java.sql.PreparedStatement 对象 SQL指令的“预编译加载器”Statement statement = connection.createStatement(); 3.5 执行SQL、获取结果123456//5.执行SQL获取执行结果// a. 如果SQL指令为DQL,则 ResultSet rs = statement.executeQuery(sql); rs中就是查询结果// b. 如果SQL指令为DML，则 int i = statement.executeUpdate(sql); i就表示DML操作影响的数据行数// 如果i&gt;0，表示DML操作是成功的；如果i=0表示DML操作对数据表中的数据没有影响int i = statement.executeUpdate(sql); 3.6 处理结果123456//6.处理结果（业务）// 添加操作：返回值i&gt;0表示添加成功，否则表示添加失败// 修改操作：返回值i&gt;0表示修改对数据有影响，如果i=0 表示对数据库没有影响// 删除操作：返回值i&gt;0表示删除对数据有影响，如果i=0 表示对数据库没有影响// 查询操作：从ResultSet rs中取出查询结果，封装到Java对象中System.out.println(i&gt;0?&quot;添加成功&quot;:&quot;添加失败&quot;); 3.7 关闭连接12345678910//7.关闭连接// 如果执行DML操作：需要关闭Statement和Connection// 如果执行DQL操作：需要关闭ResultSet、Statement和Connection// 关闭之前先判空、由大到大关闭if(statement != null &amp;&amp; !statement.isClosed())&#123; statement.close();&#125;if(connection !=null &amp;&amp; !connection.isClosed())&#123; connection.close();&#125; 四、JDBC增删查改操作实例 使用JDBC完成数据库的CRUD访问 4.1 insert操作1234567891011121314151617181920212223242526272829303132333435363738394041public class TestInsertBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; String name = &quot;Java进阶之路&quot;; String author = &quot;老王&quot;; double price = 22.22; int stock = 10; String desc = &quot;这本书很好&quot;; //1.注册驱动（驱动jar包中的驱动类（Driver）的路径：com.mysql.cj.jdbc.Driver） Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2.创建连接：通过数据库驱动管理器 DriverManager（java.sql.Driver）获取连接 String url = &quot;jdbc:mysql://localhost:3306/db_test3&quot;; Connection connection = DriverManager.getConnection(url,&quot;root&quot;,&quot;@QFedu123&quot;); //3.编写要执行的SQL指令 String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(&#x27;&quot;+name+&quot;&#x27;,&#x27;&quot;+author+&quot;&#x27;,&quot;+price+&quot;,&quot;+stock+&quot;,&#x27;&quot;+desc+&quot;&#x27;)&quot;; //4.加载SQL指令:获取SQL指令的加载器 Statement statement = connection.createStatement(); //5.执行SQL获取执行结果 int i = statement.executeUpdate(sql); //6.处理结果（业务） System.out.println(i&gt;0?&quot;添加成功&quot;:&quot;添加失败&quot;); //7.关闭连接 if(statement != null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection !=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 4.2 delete操作1234567891011121314151617181920212223242526272829public class TestDeleteBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; int bid = 1012; //使用JDBC，根据图书编号删除图书信息 //1.注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2.创建连接 String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); //3.编写SQL String sql = &quot;delete from books where book_id=&quot;+bid; //4.获取SQL加载器 Statement statement = connection.createStatement(); //5.执行SQL int i = statement.executeUpdate(sql); //6.处理结果 System.out.println(i&gt;0?&quot;删除成功&quot;:&quot;删除失败&quot;); //7.关闭连接 if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 4.3 update操作1234567891011121314151617181920212223242526272829303132333435package com.qfedu.jdbc.les1;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class TestUpdateBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; // 根据数据记录的主键 修改其他的字段 // 根据图书ID，修改图书名称、作者、价格、库存、描述 int id = 1011; String name = &quot;Java进阶之路&quot;; String author = &quot;亮亮&quot;; double price = 36.80; int stock = 8; String desc = &quot;这本书非常好&quot;; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); String sql = &quot;update books set book_name=&#x27;&quot;+name+&quot;&#x27;,book_author=&#x27;&quot;+author+&quot;&#x27;,book_price=&quot;+price+&quot;,book_stock=&quot;+stock +&quot;,book_desc=&#x27;&quot;+desc+&quot;&#x27; where book_id=&quot;+id; Statement statement = connection.createStatement(); int i = statement.executeUpdate(sql); System.out.println(i&gt;0?&quot;修改成功&quot;:&quot;修改失败&quot;); if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 4.4 select操作（一条结果） 结果集处理 123456789101112131415161718192021222324252627282930313233343536373839package com.qfedu.jdbc.les1;import java.sql.*;public class TestSelectBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //根据图书ID，查询一本图书信息 int bid = 1011; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=&quot;+bid; Statement statement = connection.createStatement(); //通过executeQuery方法执行查询语句，并且将查询的结果存放到一个ResultSet对象中（结果集） ResultSet rs = statement.executeQuery(sql); //处理结果：从rs中获取查询结果 if(rs.next())&#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); System.out.println(bookId+&quot;\\t&quot;+bookName+&quot;\\t&quot;+bookAuthor+&quot;\\t&quot;+bookPrice+&quot;\\t&quot;+bookStock+&quot;\\t&quot;+bookDesc); &#125; //关闭连接 结果集也需要关闭 if(rs!=null &amp;&amp; !rs.isClosed())&#123; rs.close(); &#125; if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 4.5 select操作（多条结果）1234567891011121314151617181920212223242526272829303132333435package com.qfedu.jdbc.les1;import java.sql.*;public class TestSelectBooks &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //查询所有图书信息 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books&quot;; Statement statement = connection.createStatement(); ResultSet rs = statement.executeQuery(sql); while(rs.next())&#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); System.out.println(bookId+&quot;\\t&quot;+bookName+&quot;\\t&quot;+bookAuthor+&quot;\\t&quot;+bookPrice+&quot;\\t&quot;+bookStock+&quot;\\t&quot;+bookDesc); &#125; if(rs!=null &amp;&amp; !rs.isClosed())&#123; rs.close(); &#125; if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 五、JDBC的核心类与接口 java.sql.DriverManager类 驱动管理器 java.sql.Connection接口 数据库连接 java.sql.Statement接口 SQL指令的“加载&#x2F;执行器” java.sql.ResultSet接口 结果集 5.1 DriverManager类 注册驱动 创建数据库连接 注册驱动 12345// 在Driver类中的静态初始化块中，注册驱动：DriverManager.registerDriver(new Driver());Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);// 在我们的应用程序中手动注册驱动的代码也可以省略 【Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);】// 如果我们没有手动注册驱动，驱动管理器在获取连接的时候发现没有注册驱动则读取 驱动jar/META-INF/servicesjava.sql.Driver文件中配置的驱动类路径进行注册 获取连接 1234// url 数据库服务器的地址// username 数据库连接用户名// password 数据库连接密码Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); 5.2 Connection接口 Connection对象表示Java应用程序与数据库之间的连接 通过Connection接口对象，获取执行SQL语句的Statement对象 完成数据的事务管理 5.2.1 获取Statement对象 Statement接口: 编译执行静态SQL指令 1Statement statement = connection.createStatement(); PreparedStatement接口：继承了Statement接口，预编译动态SQL指令（解决SQL注入问题） 1PreparedStatement preparedStatement = connection.prepareStatement(sql); CallableStatement接口：继承了PreparedStatement接口，可以调用存储过程 1CallableStatement callableStatement = connection.prepareCall(sql); 5.2.2 事务管理12345678//开启事务（关闭事务自动提交）connection.setAutoCommit(false);//事务回滚connection.rollback();//提交事务connection.commit(); 5.3 Statement接口 用于编译、执行SQL指令的 12345// 执行DML操作的SQL指令int i = statement.executeUpdate(sql);// 执行DQL操作的SQL指令ResultSet rs = statement.executeQuery(sql); 5.4 ResultSet接口 ResultSet接口对象，表示查询操作返回的结果集，提供了便利的方法用于获取结果集中的数据 判断结果集中是否还有数据未取出 1234ResultSet rs = statement.executeQuery(select_statement);// 判断rs中是否还有数据rs.next(); 获取rs指向的结果集中某行的数据 1234567int id = rs.getInt(String columnLable); //获取rs指向的行的 列 数据（字段名）int id = rs.getInt(int columnIndex);rs.getString(&quot;&quot;); //获取String类型数据rs.getDouble(&quot;&quot;); //获取Double类型数据....rs.getDate(&quot;&quot;); //获取日期类型数据 六、SQL注入问题6.1 什么是SQL注入问题？ 在JDBC操作SQL指令编写过程中，如果SQL指令中需要数据，我们可以通过字符串拼接的形式将参数拼接到SQL指令中，如String sql = &quot;delete from books where book_id=&quot;+s;(s就是拼接到SQL中的变量) 使用字符串拼接变量的形式来设置SQL语句中的数据，可能会导致因变量值的改变引起SQL指令的原意发生改变，这就被称为SQL注入。SQL注入问题是需要避免的。 例如： 如果s的值为1，SQL指令 ： delete from books where book_id&#x3D;1 如果s的值为1 or 1=1，SQL指令：delete from books where book_id&#x3D;1 or 1&#x3D;1 6.2 如何解决SQL注入问题？ 使用PreparedStatement进行SQL预编译解决SQL注入问题： 在编写SQL指令时，如果SQL指令中需要参数，一律使用?参数占位符 如果SQL指令中有?，在JDBC操作步骤中不再使用Statement，而是从Conection对象获取PreparedStatement对SQL指令进行预编译 PreparedStatement preparedStatement = connection.prepareStatement(sql); 预编译完成之后，通过PreparedStatement对象给预编译后的SQL指令的?复制 prepareadStatement.setInt(参数占位符序号,值); prepareadStatement.setString(参数占位符序号,值); SQL指令中的所有?完成赋值之后，通过PreparedStatement执行SQL执行SQL时不再加载SQL int i &#x3D; prepareadStatement.executeUpdate(); ResultSet rs &#x3D; preparedStatement.executeQuery(); 6.3 使用PreparedStatement预编译案例 删除操作 1234567891011121314151617181920212223242526272829303132333435363738394041package com.qfedu.jdbc.les1;import com.mysql.cj.jdbc.Driver;import java.sql.*;import java.util.Scanner;public class TestDeleteBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入你要删除的图书的ID：&quot;); String s = scanner.nextLine(); int bid = Integer.parseInt(s); //1.注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2.创建连接 String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); //3.编写SQL:SQL指令中的参数使用?表示 String sql = &quot;delete from books where book_id=?&quot;; //4.如果SQL指令有参数占位符?,则从Connection获取PreparedStatement预编译SQL指令 // 预编译：在SQL指令中的参数赋值之前对SQL执行的语法结构进行编译 PreparedStatement preparedStatement = connection.prepareStatement(sql); // SQL指令预编译之后，给SQL中的?赋值 preparedStatement.setInt(1,bid); //5.执行SQL int i = preparedStatement.executeUpdate(); //6.处理结果 System.out.println(i&gt;0?&quot;删除成功&quot;:&quot;删除失败&quot;); //7.关闭连接 if(preparedStatement!=null &amp;&amp; !preparedStatement.isClosed())&#123; preparedStatement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 修改操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.qfedu.jdbc.les1;import java.sql.*;public class TestInsertBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; String name = &quot;Java进阶之路&quot;; String author = &quot;老王&quot;; double price = 22.22; int stock = 10; String desc = &quot;这本书很好&quot;; //1.注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2.创建连接 String url = &quot;jdbc:mysql://localhost:3306/db_test3&quot;; Connection connection = DriverManager.getConnection(url,&quot;root&quot;,&quot;@QFedu123&quot;); //3.编写要执行的SQL指令:SQL指令中所需的参数一律使用? String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; //4.SQL中有? 使用PreparedStatement预编译SQL PreparedStatement preparedStatement = connection.prepareStatement(sql); // 给SQL指令中的?复制 preparedStatement.setString(1,name); preparedStatement.setString(2,author); preparedStatement.setDouble(3,price); preparedStatement.setInt(4,stock); preparedStatement.setString(5,desc); //5.执行SQL获取执行结果 int i = preparedStatement.executeUpdate(); //6.处理结果（业务） System.out.println(i&gt;0?&quot;添加成功&quot;:&quot;添加失败&quot;); //7.关闭连接 if(preparedStatement != null &amp;&amp; !preparedStatement.isClosed())&#123; preparedStatement.close(); &#125; if(connection !=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 练习1：修改操作 1234567891011121314151617181920212223242526272829303132333435363738394041package com.qfedu.jdbc.les1;import java.sql.*;public class TestUpdateBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; // 根据数据记录的主键 修改其他的字段 // 根据图书ID，修改图书名称、作者、价格、库存、描述 int id = 1011; String name = &quot;Java进阶之路&quot;; String author = &quot;亮亮&quot;; double price = 36.80; int stock = 8; String desc = &quot;这本书非常好&quot;; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); //1. String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; //2. PreparedStatement preparedStatement = connection.prepareStatement(sql); //3. preparedStatement.setString(1,name); preparedStatement.setString(2,author); preparedStatement.setDouble(3,price); preparedStatement.setInt(4,stock); preparedStatement.setString(5,desc); //4. int i = preparedStatement.executeUpdate(); System.out.println(i&gt;0?&quot;修改成功&quot;:&quot;修改失败&quot;); //5. if(preparedStatement!=null &amp;&amp; !preparedStatement.isClosed())&#123; preparedStatement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 练习2：根据ID查询图书信息 12345678910111213141516171819202122232425262728293031323334353637383940package com.qfedu.jdbc.les1;import java.sql.*;public class TestSelectBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //根据图书ID，查询一本图书信息 int bid = 1013; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1,bid); //通过executeQuery方法执行查询语句，并且将查询的结果存放到一个ResultSet对象中（结果集） ResultSet rs = preparedStatement.executeQuery(); //处理结果：从rs中获取查询结果 if(rs.next())&#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); System.out.println(bookId+&quot;\\t&quot;+bookName+&quot;\\t&quot;+bookAuthor+&quot;\\t&quot;+bookPrice+&quot;\\t&quot;+bookStock+&quot;\\t&quot;+bookDesc); &#125; //关闭连接 结果集也需要关闭 if(rs!=null &amp;&amp; !rs.isClosed())&#123; rs.close(); &#125; if(preparedStatement!=null &amp;&amp; !preparedStatement.isClosed())&#123; preparedStatement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 备注 如果SQL指令中需要参数，则使用PreparedStatement进行SQL预编译，如果SQL指令中没有参数建议使用Statement（Statement执行效率要高于PreparedStatement）。 七、工具类封装7.1 代码的复用性在我们的应用程序中，如果需要完成相同的操作，相同的代码无需重复编写，我们只需一次编写多次调用即可！ JDBC数据库编程是由一个固定的步骤： 注册驱动 创建连接 编写SQL 获取Statement对象 执行SQL 处理结果 关闭连接 7.2 工具类封装 DBManager DBUtil JDBCUtil DBHelper 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.qfedu.jdbc.utils;import java.sql.*;public class DBHelper &#123; /*将创建数据库连接所需的字符串定义为常量，集中管理*/ private static final String DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;; private static final String URL = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; private static final String USERNAME = &quot;root&quot;; private static final String PASSWORD = &quot;@QFedu123&quot;; /** * 注册驱动只需执行一次，因此我们放在帮助类的静态初始化块中完成 */ static&#123; try &#123; Class.forName(DRIVER); &#125; catch (ClassNotFoundException e) &#123; System.out.println(&quot;-----------注册驱动失败&quot;); &#125; &#125; /** * 创建数据库连接对象 */ public static Connection getConnection()&#123; Connection connection = null; try &#123; connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); &#125; catch (SQLException e) &#123; System.out.println(&quot;-----------创建连接失败&quot;); &#125; return connection; &#125; /** * 关闭连接 * 多态的应用：使用Statement接口做参数，既可以传递Statement接口对象， * 也可以传递PreparedStatement接口对象 */ public static void close(Statement statement, Connection connection)&#123; close(null,statement,connection); &#125; /** * 关闭连接 */ public static void close(ResultSet resultSet,Statement statement, Connection connection)&#123; try &#123; if(resultSet!=null &amp;&amp; !resultSet.isClosed())&#123; resultSet.close(); &#125; if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;catch (Exception e)&#123; System.out.println(&quot;~~~~~关闭数据库连接失败&quot;); &#125; &#125;&#125; 八、DAO与DTO的封装 DAO Data Access Object 数据访问对象 DTO Data Transfer Object 数据传输对象（实体类） 用于传输DML操作参数及DQL的查询结果 8.1 CRUD方法的封装 面向对象的特征之一——封装 我们将能够完成某个CRUD操作的代码单独定义成一个方法，当需要完成此CRUD操作时调用这个方法即可; insert操作封装 delete操作封装 update操作封装 8.2 DTO实体类封装 问题：在封装CRUD方法时，对于查询操作而言，需要将查询到的数据库记录返回给调用者，但是一个查询方法只能返回一个值，而一条数据库记录有多个值，如何将一条数据库记录的多个值返回呢？ 处理：在Java程序中创建一个属性与数据库表匹配的类，通过此类的对象封装查询到的数据，我们把用于传递JDBC增删查改操作的数据的对象称之为数据传输对象——DTO(实体类：带有属性，其对象可以存放数据的类) 实体类创建规则： 1234567* 1.类中属性的个数和类型，与对应的数据表保持一致* 2.提供所有属性的get和set方法：Alt+Insert --- Getter And Setter --- 选择所有属性 --- OK* 3.提供全参构造器：Alt+Insert --- Constructor --- 选择所有属性 --- OK* 4.提供无参构造器：Alt+Insert --- Constructor --- SelectNone* 5.重写toString方法：Alt+Insert --- toString --- OK* 6.[暂略] 重写hashcode和equals* 7.[暂略]实现序列化Serializable接口 实体类实例： 123456789101112131415161718192021222324252627282930313233343536373839package com.qfedu.jdbc.dto;import java.io.Serializable;public class Book implements Serializable &#123; private int bookId; private String bookName; private String bookAuthor; private double bookPrice; private int bookStock; private String bookDesc; @Override public String toString() &#123; return &quot;Book&#123;&quot; + &quot;bookId=&quot; + bookId + &quot;, bookName=&#x27;&quot; + bookName + &#x27;\\&#x27;&#x27; + &quot;, bookAuthor=&#x27;&quot; + bookAuthor + &#x27;\\&#x27;&#x27; + &quot;, bookPrice=&quot; + bookPrice + &quot;, bookStock=&quot; + bookStock + &quot;, bookDesc=&#x27;&quot; + bookDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public Book() &#123; &#125; public Book(int bookId, String bookName, String bookAuthor, double bookPrice, int bookStock, String bookDesc) &#123; this.bookId = bookId; this.bookName = bookName; this.bookAuthor = bookAuthor; this.bookPrice = bookPrice; this.bookStock = bookStock; this.bookDesc = bookDesc; &#125; //get和set方法&#125; 使用实体类封装查询操作返回的结果： 1234567891011121314151617181920212223242526/*** 根据图书ID查询一条图书记录*/public Book queryBook(int bid) throws SQLException&#123; Book book = null; Connection connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1,bid); //通过executeQuery方法执行查询语句，并且将查询的结果存放到一个ResultSet对象中（结果集） ResultSet rs = preparedStatement.executeQuery(); //处理结果：从rs中获取查询结果 if(rs.next())&#123; int id = rs.getInt(&quot;book_id&quot;); String name = rs.getString(&quot;book_name&quot;); String author = rs.getString(&quot;book_author&quot;); double price = rs.getDouble(&quot;book_price&quot;); int stock = rs.getInt(&quot;book_stock&quot;); String desc = rs.getString(&quot;book_desc&quot;); //我们需要将查询到的一条数据库图书记录的6个值返回 book = new Book(id,name,author,price,stock,desc); &#125; //关闭连接 结果集也需要关闭 DBHelper.close(rs,preparedStatement,connection); return book;&#125; 8.3 实体类封装查询结果 查询的每条结果分别存放到一个DTO对象中，再将多个DTO对象存放到一个List集合中，返回这个List集合 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.qfedu.jdbc.les1;import com.qfedu.jdbc.dto.Book;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * @Description */public class TestSelectBooks &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; List&lt;Book&gt; list = new TestSelectBooks().listBooks(); for(Book b:list)&#123; System.out.println(b.getBookName()+&quot;\\t&quot;+b.getBookAuthor()); &#125; &#125; public List&lt;Book&gt; listBooks() throws SQLException&#123; List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); //查询所有图书信息 Connection connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books&quot;; Statement statement = connection.createStatement(); ResultSet rs = statement.executeQuery(sql); while(rs.next())&#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); Book book = new Book(bookId, bookName, bookAuthor, bookPrice, bookStock, bookDesc); bookList.add(book); &#125; DBHelper.close(rs,statement,connection); return bookList; &#125;&#125; 8.4 实体类传递添加、修改操作参数 在JDBC的添加、修改等方法中需要多个数据，我们可以通过实体类来进行参数传递 8.4.1 添加操作1234567891011121314151617public boolean insertBook(Book book) throws SQLException &#123; boolean flag = false; //调用工具类，获取数据库连接对象 Connection connection = DBHelper.getConnection(); String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,book.getBookName()); preparedStatement.setString(2,book.getBookAuthor()); preparedStatement.setDouble(3,book.getBookPrice()); preparedStatement.setInt(4,book.getBookStock()); preparedStatement.setString(5,book.getBookDesc()); int i = preparedStatement.executeUpdate(); flag = i&gt;0; //关闭连接 DBHelper.close(preparedStatement,connection); return flag;&#125; 8.4.2 修改操作12345678910111213141516public boolean updateBook(Book book) throws SQLException&#123; boolean flag = false; Connection connection = DBHelper.getConnection(); String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,book.getBookName()); preparedStatement.setString(2,book.getBookAuthor()); preparedStatement.setDouble(3,book.getBookPrice()); preparedStatement.setInt(4,book.getBookStock()); preparedStatement.setString(5,book.getBookDesc()); preparedStatement.setInt(6,book.getBookId()); int i = preparedStatement.executeUpdate(); flag = i&gt;0; DBHelper.close(preparedStatement,connection); return flag;&#125; 8.5 DAO类封装 DAO封装：将对数据库中同一张数据表的JDBC操作方法封装到同一个Java类中，这个类就是访问此数据表的数据访问对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import java.util.ArrayList;import java.util.List;/** * @Descript DAO Data Access Object 数据访问对象 */public class BookDAO &#123; public boolean deleteBook(int bid) throws SQLException &#123; boolean flag = false; //使用JDBC，根据图书编号删除图书信息 //1.注册驱动 创建连接 Connection connection = DBHelper.getConnection(); //3.编写SQL String sql = &quot;delete from books where book_id=?&quot;; //4.如果SQL指令有参数占位符?,则从Connection获取PreparedStatement预编译SQL指令 // 预编译：在SQL指令中的参数赋值之前对SQL执行的语法结构进行编译 PreparedStatement preparedStatement = connection.prepareStatement(sql); // SQL指令预编译之后，给SQL中的?赋值 preparedStatement.setInt(1,bid); //5.执行SQL int i = preparedStatement.executeUpdate(); //6.处理结果 flag = i&gt;0; //7.关闭连接 DBHelper.close(preparedStatement,connection); return true; &#125; /** * 添加图书 * @return 如果添加成功返回true，如果添加失败则返回false * @throws SQLException */ public boolean insertBook(Book book) throws SQLException &#123; boolean flag = false; //调用工具类，获取数据库连接对象 Connection connection = DBHelper.getConnection(); String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,book.getBookName()); preparedStatement.setString(2,book.getBookAuthor()); preparedStatement.setDouble(3,book.getBookPrice()); preparedStatement.setInt(4,book.getBookStock()); preparedStatement.setString(5,book.getBookDesc()); int i = preparedStatement.executeUpdate(); // 如果i&gt;0，表示DML操作是成功的；如果i=0表示DML操作对数据表中的数据没有影响 flag = i&gt;0; //关闭连接 DBHelper.close(preparedStatement,connection); return flag; &#125; /** * 根据图书ID查询一条图书记录 */ public Book queryBook(int bid) throws SQLException&#123; Book book = null; Connection connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1,bid); //通过executeQuery方法执行查询语句，并且将查询的结果存放到一个ResultSet对象中（结果集） ResultSet rs = preparedStatement.executeQuery(); //处理结果：从rs中获取查询结果 if(rs.next())&#123; int id = rs.getInt(&quot;book_id&quot;); String name = rs.getString(&quot;book_name&quot;); String author = rs.getString(&quot;book_author&quot;); double price = rs.getDouble(&quot;book_price&quot;); int stock = rs.getInt(&quot;book_stock&quot;); String desc = rs.getString(&quot;book_desc&quot;); //我们需要将查询到的一条数据库图书记录的6个值返回 book = new Book(id,name,author,price,stock,desc); &#125; //关闭连接 结果集也需要关闭 DBHelper.close(rs,preparedStatement,connection); return book; &#125; public List&lt;Book&gt; listBooks() throws SQLException&#123; List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); //查询所有图书信息 Connection connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books&quot;; Statement statement = connection.createStatement(); ResultSet rs = statement.executeQuery(sql); while(rs.next())&#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); Book book = new Book(bookId, bookName, bookAuthor, bookPrice, bookStock, bookDesc); bookList.add(book); &#125; DBHelper.close(rs,statement,connection); return bookList; &#125; public boolean updateBook(Book book) throws SQLException&#123; boolean flag = false; Connection connection = DBHelper.getConnection(); String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,book.getBookName()); preparedStatement.setString(2,book.getBookAuthor()); preparedStatement.setDouble(3,book.getBookPrice()); preparedStatement.setInt(4,book.getBookStock()); preparedStatement.setString(5,book.getBookDesc()); preparedStatement.setInt(6,book.getBookId()); int i = preparedStatement.executeUpdate(); flag = i&gt;0; DBHelper.close(preparedStatement,connection); return flag; &#125;&#125; 8.6 DAO类代码优化 1.在应用程序开发中，如果方法中抛出异常且自己可以处理，则直接通过try&#x2F;catch进行捕获处理； 2.JDBC操作方法的连接需要放在finally中进行关闭； 3.将数据库连接Connection、Statement、ResultSet等需要关闭的数据库对象定义在try之前; 4.因为所有的JDBC操作都需要Conection、Statement对象，查询方法都需要ResultSet对象，因此在DAO中可以将这些对象定义成类的成员变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.qfedu.jdbc.dao;import com.qfedu.jdbc.dto.Book;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * @Descript DAO Data Access Object 数据访问对象 */public class BookDAO &#123; private Connection connection; private Statement statement; private PreparedStatement preparedStatement; private ResultSet rs; public boolean deleteBook(int bid) &#123; boolean flag = false; try&#123; connection = DBHelper.getConnection(); String sql = &quot;delete from books where book_id=?&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1,bid); int i = preparedStatement.executeUpdate(); flag = i&gt;0; &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(preparedStatement,connection); &#125; return flag; &#125; public boolean insertBook(Book book) &#123; boolean flag = false; try&#123; //调用工具类，获取数据库连接对象 connection = DBHelper.getConnection(); String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,book.getBookName()); preparedStatement.setString(2,book.getBookAuthor()); preparedStatement.setDouble(3,book.getBookPrice()); preparedStatement.setInt(4,book.getBookStock()); preparedStatement.setString(5,book.getBookDesc()); int i = preparedStatement.executeUpdate(); // 如果i&gt;0，表示DML操作是成功的；如果i=0表示DML操作对数据表中的数据没有影响 flag = i&gt;0; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(preparedStatement,connection); &#125; return flag; &#125; public Book queryBook(int bid) &#123; Book book = null; try &#123; connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1, bid); //通过executeQuery方法执行查询语句，并且将查询的结果存放到一个ResultSet对象中（结果集） rs = preparedStatement.executeQuery(); //处理结果：从rs中获取查询结果 if (rs.next()) &#123; int id = rs.getInt(&quot;book_id&quot;); String name = rs.getString(&quot;book_name&quot;); String author = rs.getString(&quot;book_author&quot;); double price = rs.getDouble(&quot;book_price&quot;); int stock = rs.getInt(&quot;book_stock&quot;); String desc = rs.getString(&quot;book_desc&quot;); //我们需要将查询到的一条数据库图书记录的6个值返回 book = new Book(id, name, author, price, stock, desc); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; finally &#123; DBHelper.close(rs, preparedStatement, connection); &#125; return book; &#125; public List&lt;Book&gt; listBooks()&#123; List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); try &#123; connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books&quot;; statement = connection.createStatement(); rs = statement.executeQuery(sql); while (rs.next()) &#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); Book book = new Book(bookId, bookName, bookAuthor, bookPrice, bookStock, bookDesc); bookList.add(book); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(rs, statement, connection); &#125; return bookList; &#125; public boolean updateBook(Book book) &#123; boolean flag = false; try &#123; connection = DBHelper.getConnection(); String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1, book.getBookName()); preparedStatement.setString(2, book.getBookAuthor()); preparedStatement.setDouble(3, book.getBookPrice()); preparedStatement.setInt(4, book.getBookStock()); preparedStatement.setString(5, book.getBookDesc()); preparedStatement.setInt(6, book.getBookId()); int i = preparedStatement.executeUpdate(); flag = i &gt; 0; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; finally &#123; DBHelper.close(preparedStatement, connection); &#125; return flag; &#125;&#125; 九、JDBC综合案例 完成学生信息的CRUD操作 9.1 JDBC数据库编程的流程 创建数据库、数据表 123456create table students( stu_num char(8) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null); 创建新的Java工程 创建JDBC的工具类：DBHelper 创建DTO类（用于封装参数及查询结果） 创建DAO类（用于完成CRUD操作） 9.2 创建JDBC工具类 在Java工程中创建package :com.qfedu.jdbc.utils 在com.qfedu.jdbc.utils包中创建工具类DBHelper 编写DBHelper工具类： 添加驱动jar文件 编写DBHelper代码 9.3 创建DTO类 在Java工程中创建package：com.qfedu.jdbc.dto 在com.qfedu.jdbc.dto创建数据表对应的实体类Student 编写实体类 123456789101112131415161718192021222324252627282930313233package com.qfedu.jdbc.dto;/** * @Descript 用于传递学生信息的实体类 */public class Student &#123; private String stuNum; private String stuName; private String stuGender; private int stuAge; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;stuNum=&#x27;&quot; + stuNum + &#x27;\\&#x27;&#x27; + &quot;, stuName=&#x27;&quot; + stuName + &#x27;\\&#x27;&#x27; + &quot;, stuGender=&#x27;&quot; + stuGender + &#x27;\\&#x27;&#x27; + &quot;, stuAge=&quot; + stuAge + &#x27;&#125;&#x27;; &#125; public Student() &#123; &#125; public Student(String stuNum, String stuName, String stuGender, int stuAge) &#123; this.stuNum = stuNum; this.stuName = stuName; this.stuGender = stuGender; this.stuAge = stuAge; &#125; //get set&#125; 9.4 创建DAO类 创建DAO类，完成JDBC操作 在Java项目中创建package:com.qfedu.jdbc.dao 在com.qfedu.jdbc.dao包中创建类StudentDAO 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.qfedu.jdbc.dao;import com.qfedu.jdbc.dto.Student;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * @Descript students表的数据访问类 */public class StudentDAO &#123; private Connection connection; private Statement statement; private PreparedStatement preparedStatement; private ResultSet resultSet; //1、添加学生信息 public boolean insert(Student student)&#123; boolean flag = false; try &#123; connection = DBHelper.getConnectin(); String sql = &quot;insert into students(stu_num,stu_name,stu_gender,stu_age) values(?,?,?,?)&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,student.getStuNum()); preparedStatement.setString(2,student.getStuName()); preparedStatement.setString(3,student.getStuGender()); preparedStatement.setInt(4,student.getStuAge()); int i = preparedStatement.executeUpdate(); flag = i&gt;0; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(preparedStatement,connection); &#125; return flag; &#125; //2、根据学号查询一个学生记录 public Student queryStudent(String snum)&#123; Student student = null; try&#123; connection = DBHelper.getConnectin(); String sql = &quot;select stu_num,stu_name,stu_gender,stu_age from students where stu_num=?&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,snum); resultSet = preparedStatement.executeQuery(); if(resultSet.next())&#123; String stuNum = resultSet.getString(&quot;stu_num&quot;); String stuName = resultSet.getString(&quot;stu_name&quot;); String stuGender = resultSet.getString(&quot;stu_gender&quot;); int stuAge = resultSet.getInt(&quot;stu_age&quot;); student = new Student(stuNum,stuName,stuGender,stuAge); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(resultSet,preparedStatement,connection); &#125; return student; &#125; //3、查询多个学生信息 public List&lt;Student&gt; listStudents()&#123; List&lt;Student&gt; studentList = new ArrayList&lt;&gt;(); try&#123; connection = DBHelper.getConnectin(); String sql = &quot;select stu_num,stu_name,stu_gender,stu_age from students&quot;; statement = connection.createStatement(); resultSet = statement.executeQuery(sql); while(resultSet.next())&#123; String stuNum = resultSet.getString(&quot;stu_num&quot;); String stuName = resultSet.getString(&quot;stu_name&quot;); String stuGender = resultSet.getString(&quot;stu_gender&quot;); int stuAge = resultSet.getInt(&quot;stu_age&quot;); Student s = new Student(stuNum,stuName,stuGender,stuAge); studentList.add(s); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; finally &#123; DBHelper.close(resultSet,statement,connection); &#125; return studentList; &#125;&#125; 9.5 测试DAO类中的方法 使用junit对DAO中创建的JDBC方法进行单元测试 9.5.1 下载导入junit依赖到项目中 下载：https://mvnrepository.com/ （如果使用junit 4.10 + 版本单元测试，需要以下两个jar文件） junit-4.12.jar hamcrest-core-1.3.jar 将junit-4.12.jar、hamcrest-core-1.3.jar拷贝项目的lib文件夹 选择拷贝到项目中的jar文件—右键—Add as Library 9.5.2 创建单元测试类 如果我们需要对某个类中的方法进行单元测试，我们需要创建这个类的测试类 StudentDAO ———&gt; StudentDAOTest（测试类：类名&#x3D;被测试类+Test） 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.qfedu.jdbc.test;import com.qfedu.jdbc.dao.StudentDAO;import com.qfedu.jdbc.dto.Student;import org.junit.Test;import java.util.List;import static org.junit.Assert.*;/** * @Descript 此类是StudentDAO的单元测试类 */public class StudentDAOTest &#123; //1.在测试类中定义成员变量：创建被测试类的对象 private StudentDAO studentDAO = new StudentDAO(); //2创建测试方法 ： 用来测试StudentDAO类中的insertStudent方法 //a.测试方法名=test+被测试方法名 //b.测试方法无参数无返回值 @Test public void testInsertStudent()&#123; //准备被测试方法所需的参数 Student stu = new Student(&quot;1008&quot;,&quot;Tom&quot;,&quot;男&quot;,20); //调用被测试方法，获取结果 boolean b = studentDAO.insertStudent(stu); //断言返回结果(成立 | 不成立) assertTrue(b); &#125; @Test public void testQueryStudent()&#123; String snum = &quot;1008&quot;; Student student = studentDAO.queryStudent(snum); assertEquals(&quot;Tom2&quot;,student.getStuName()); &#125; @Test public void testListStudents()&#123; List&lt;Student&gt; studentList = studentDAO.listStudents(); assertEquals(8,studentList.size()); &#125;&#125; 十、JDBC事务管理 什么是事务？ 事务的四大特性—ACID 事务的隔离级别 MySQL事务管理： start transaction rollback commit 10.1 JDBC实现借书操作 向records表添加借书记录 修改books表中的库存 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.qfedu.jdbc.dao;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;/** * @Descript */public class BookDAO &#123; /** * 借书： * @param stuNum 借书的学生学号 * @param bookId 借书的图书编号 * @param num 借书的数量 * @return */ public boolean borrowBook2(String stuNum,int bookId,int num)&#123; boolean flag = false; try &#123; //1.向`records`表添加借书记录 Connection connection = DBHelper.getConnectin(); String sql1 = &quot;insert into records(snum,bid,borrow_num,is_return,borrow_date) values(?,?,?,0,sysdate())&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql1); preparedStatement.setString(1,stuNum); preparedStatement.setInt(2,bookId); preparedStatement.setInt(3,num); int i = preparedStatement.executeUpdate(); int k = 10/0; //造异常：算术异常 //2.修改`books`表中的库存 Connection connection2 = DBHelper.getConnectin(); String sql2 = &quot;update books set book_stock=book_stock-? where book_id=?&quot;; PreparedStatement preparedStatement2 = connection2.prepareStatement(sql2); preparedStatement2.setInt(1,num); preparedStatement2.setInt(2,bookId); int j = preparedStatement2.executeUpdate(); flag = i&gt;0 &amp;&amp; j&gt;0; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; // 关闭连接 &#125; return flag; &#125;&#125; 分析： 借书业务由两个数据库操作完成，这两个操作要么同时成功，要么同时失败，构成一个数据库事务； JDBC的DML操作默认是自定提交的，因此当第一个DML操作（添加借书记录）完成后，无论第二个操作（修改库存）是否成功，借书记录都会添加到数据库，而且是永久的 JDBC中该如何做事务管理呢？ 10.2 JDBC事务管理 一个事务中的多个DML操作需要基于同一个数据库连接； 创建连接之后，设置事务手动提交（关闭自动提交）；connection.setAutoCommit(false); 当当前事务中的所有DML操作完成之后手动提交；connection.commit(); 当事务中的任何一个步骤出现异常，在catch代码块中执行事务回滚。connection.rollback(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.qfedu.jdbc.dao;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;/** * @Descript */public class BookDAO &#123; /** * 借书： * @param stuNum 借书的学生学号 * @param bookId 借书的图书编号 * @param num 借书的数量 * @return */ public boolean borrowBook(String stuNum,int bookId,int num)&#123; boolean flag = false; Connection connection = null; PreparedStatement preparedStatement1 = null; PreparedStatement preparedStatement2 = null; try &#123; connection = DBHelper.getConnectin(); //设置使用当前Connection连接操作数据库自动提交关闭 connection.setAutoCommit(false); //1.向`records`表添加借书记录 String sql1 = &quot;insert into records(snum,bid,borrow_num,is_return,borrow_date) values(?,?,?,0,sysdate())&quot;; preparedStatement1 = connection.prepareStatement(sql1); preparedStatement1.setString(1,stuNum); preparedStatement1.setInt(2,bookId); preparedStatement1.setInt(3,num); int i = preparedStatement1.executeUpdate(); int k = 10/0; //造异常：算术异常 //2.修改`books`表中的库存 String sql2 = &quot;update books set book_stock=book_stock-? where book_id=?&quot;; preparedStatement2 = connection.prepareStatement(sql2); preparedStatement2.setInt(1,num); preparedStatement2.setInt(2,bookId); int j = preparedStatement2.executeUpdate(); // 提交事务 connection.commit(); flag = i&gt;0 &amp;&amp; j&gt;0; &#125;catch (Exception e)&#123; try &#123; //一旦事务执行过程中出现异常，执行回滚 connection.rollback(); &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; &#125;finally &#123; DBHelper.close(preparedStatement1,null); DBHelper.close(preparedStatement2,connection); &#125; return flag; &#125; &#125; 10.3 Service层的事务管理 DAO只负责数据库的操作，业务由service层进行管理 10.3.1 Service分层介绍 DAO负责特定的数据库操作 Servcie进行业务处理，Service业务处理过程如果需要数据库操作，则调用DAO完成 10.3.2 Service分层实现 创建RecordDAO，完成insertRecord方法 123456789101112131415161718192021222324252627282930313233343536373839404142package com.qfedu.jdbc.dao;import com.qfedu.jdbc.utils.DBHelper;import java.sql.Connection;import java.sql.PreparedStatement;/** * @Descript 完成对借书记录表的JDBC操作 */public class RecordDAO &#123; /** * 添加借书记录 * @param snum 借书的学生的学号 * @param bid 借书的图书编号 * @param num 借书的数量 * @return 添加借书记录成功返回true，失败返回false */ public boolean insertRecord(String snum,int bid,int num)&#123; boolean flag = false; Connection connection = null; PreparedStatement preparedStatement1 = null; try&#123; //1.向`records`表添加借书记录 connection = DBHelper.getConnectin(); String sql1 = &quot;insert into records(snum,bid,borrow_num,is_return,borrow_date) values(?,?,?,0,sysdate())&quot;; preparedStatement1 = connection.prepareStatement(sql1); preparedStatement1.setString(1,snum); preparedStatement1.setInt(2,bid); preparedStatement1.setInt(3,num); int i = preparedStatement1.executeUpdate(); flag = i&gt;0; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(preparedStatement1,connection); &#125; return flag; &#125;&#125; 在BookDAO中定义updateStock修改库存方法 123456789101112131415161718192021222324252627282930313233343536373839package com.qfedu.jdbc.dao;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;/** * @Descript */public class BookDAO &#123; /** * 修改库存 * @param bid 要修改库存的图书编号 * @param num book_stock=book_stock-num * @return */ public boolean updateStock(int bid,int num)&#123; boolean flag = false; Connection connection = null; PreparedStatement preparedStatement2 = null; try&#123; //2.修改`books`表中的库存 connection = DBHelper.getConnectin(); String sql2 = &quot;update books set book_stock=book_stock-? where book_id=?&quot;; preparedStatement2 = connection.prepareStatement(sql2); preparedStatement2.setInt(1,num); preparedStatement2.setInt(2,bid); int j = preparedStatement2.executeUpdate(); flag = j&gt;0; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(preparedStatement2,connection); &#125; return flag; &#125;&#125; 创建BookService完成借书业务 123456789101112131415161718192021222324252627package com.qfedu.jdbc.service;import com.qfedu.jdbc.dao.BookDAO;import com.qfedu.jdbc.dao.RecordDAO;/** * @Descript 图书管理的业务类 */public class BookService &#123; private RecordDAO recordDAO = new RecordDAO(); private BookDAO bookDAO = new BookDAO(); /** * 借书业务，包含两个步骤，这两个步骤要么同时成功，要么同时失败——事务 */ public boolean borrowBook(String stuNum,int bookId,int num)&#123; //1.添加借书记录 boolean b1 = recordDAO.insertRecord(stuNum, bookId, num); //2.修改图书库存 boolean b2 = bookDAO.updateStock(bookId, num); // 结果处理 boolean r = b1 &amp;&amp; b2; return r; &#125;&#125; 10.3.3 Service层的事务管理 Servcie层事务中多个数据库的DML操作是相互独立的，如何保证所有DML要么同时成功，要么同时失败呢？ 事务管理要满足以下条件： 多个DML操作需使用同一个数据库连接 第一个DML操作之前设置事务手动提交 所有DML操作执行完成之后提交事务 出现异常则进行事务回滚 如何让Service事务中的多个DML使用同一个数据库连接？ 在Service获取连接对象，将连接对象传递到DAO中 分析：DAO类中的Connection对象需要通过Service传递给进来，这种对象传递本来也无可厚非，但是当我们通过面向接口开发时（面向接口，是为了能够灵活的定义实现类），容易造成接口的冗余（接口污染） 使用ThreadLocal容器，实现多个DML操作使用相同的连接 存储Connection的容器可以使用List集合 使用List集合做容器，在多线程并发编程中会出现资源竞争问题——多个并发的线程使用的是同一个数据库连接对象（我们的要求是同一个事务中使用同一个连接，而并非多个线程共享连接） 为了解决并发编程的连接对象共享问题，我们可以使用ThreadLocal作为数据库连接对象的容器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.qfedu.jdbc.utils;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * @Descript */public class DBHelper &#123; //1.定义数据库连接信息 private static final String DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;; private static final String URL = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; private static final String USERNAME = &quot;root&quot;; private static final String PASSWORD = &quot;@QFedu123&quot;; //1️⃣定义ThreadLocal容器 private static final ThreadLocal&lt;Connection&gt; local = new ThreadLocal&lt;&gt;(); //2.静态初始化块注册驱动 static&#123; try &#123; Class.forName(DRIVER); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; //3.创建数据库连接 public static Connection getConnectin()&#123; // 2️⃣从ThreadLocal容器中获取连接 Connection connection = local.get(); try &#123; if(connection == null)&#123; //3️⃣如果容器中没有连接，则创建连接，并将创建的连接存放到容器 connection = DriverManager.getConnection(URL,USERNAME,PASSWORD); local.set(connection); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125; //4. 4️⃣关闭连接 // 如果使用ThreadLocal存储数据库连接，关闭连接时同时要将Connection对象从ThreadLocal中移除 public static void closeConnection()&#123; // 获取到当前线程使用的数据库连接对象 Connection connection = local.get(); try &#123; if(connection !=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; // 将关闭后的连接对象从ThreadLocal中移除 local.remove(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void closeStatement(Statement statement)&#123; closeStatement(null,statement); &#125; public static void closeStatement(ResultSet resultSet, Statement statement)&#123; try &#123; if(resultSet!=null &amp;&amp; !resultSet.isClosed())&#123; resultSet.close(); &#125; if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 十一、数据库连接池11.1 什么是数据库连接池？ 如果每个JDBC操作需要数据库连接都重新创建，使用完成之后都销毁，我们的JVM会因为频繁的创建、销毁连接而占用额外的系统资源。 数据库连接本质上是可被重用的资源（当一个JDBC操作完成之后，其创建的连接是可以被其他JDBC操作使用的），基于这个特性： 我们可以创建一个存放数据库连接的容器（连接池），连接池是有最大容量的 当我们要进行JDBC操作时，直接从这个容器中获取连接 如果容器中没有空闲的连接且连接池中连接的个数没有达到最大值，则创建新的数据库连接存入连接池并给这个操作使用，使用完成之后无需关闭连接直接归还这个容器中即可； 如果容器中没有空闲的连接且连接池中连接的个数达到最大值，当前操作就会进行等待，等待连接池中的某个连接被归还，归还之后再使用； 如果容器中有空闲连接，则无需创建新的连接，直接从容器中获取这个空闲连接进行使用； 连接池：存放数据库连接对象的容器 连接池作用：对数据库连接进行管理，减少因重复创建、销毁连接导致的系统开销 11.2 常用连接池 我们可以编程实现：创建一个数组、集合来存放数据库连接； 目前市面上已经有多种实现的数据库连接池了，我们无需再手动实现，只需引用对应的数据库连接池产品，即可在我们自己的Java应用中使用连接池（站在巨人的肩上） 功能 dbcp druid c3p0 HikariCP 是否支持PSCache 是 是 是 否 监控 jmx jmx&#x2F;log&#x2F;http jmx,log jmx 扩展性 弱 好 弱 弱 sql拦截及解析 无 支持 无 无 代码 简单 中等 复杂 简单 特点 依赖于common-pool 阿里开源，功能全面 历史久远，代码逻辑复杂，且不易维护 优化力度大，功能简单，起源于boneCP 连接池管理 LinkedBlockingDeque 数组 ThreadLocalCopyOnWriteArrayList 基于连接池的性能、使用的便捷性、连接监控等多方面综合情况，druid是目前企业应用中使用最广泛的 Hikari在SpringBoot中默认集成，性能是诸多竞品中最好的 11.3 使用Druid连接池11.3.1 创建Java应用 创建Java工程 添加驱动jar文件 11.3.2 创建连接池属性配置 在src中创建package：com.qfedu.jdbc.utils 在com.qfedu.jdbc.utils中创建druid.properties文件 配置druid连接池的实行 123456789101112131415# 数据库连接信息driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8username=rootpassword=@QFedu123# 连接池属性# 连接池的初始化连接数&lt;创建数据库连接池时默认初始化的连接的个数&gt;initialSize=10# 连接池的最大连接数maxActive=50# 最小空闲连接数（当数据库连接使用率很低时，连接池中的连接会被释放一部分）minIdle=5# 超时等待时间(单位：ms)maxWait=30000 11.3.3 创建连接池工具类 下载并导入druid的jar文件druid-1.2.8.jar 在com.qfedu.jdbc.utils创建DruidUtils工具类（工具类与属性文件druid.properties在同目录下） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.qfedu.jdbc.utils;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;/** * @Descript Druid数据库连接池工具类 */public class DruidUtils &#123; //1.定义DruidDataSource对象：表示Druid数据库连接池（数据源） private static DruidDataSource druidDataSource; //2.静态代码块初始化定义DruidDataSource对象 static&#123; try &#123; //读取druid.properties文件中配置的属性 InputStream is = DruidUtils.class.getResourceAsStream(&quot;druid.properties&quot;); Properties properties = new Properties(); properties.load(is); //使用属性文件初始化DruidDataSource对象 druidDataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //3.创建静态方法，从连接池对象中获取连接 public static Connection getConnection()&#123; Connection connection = null; try &#123; connection = druidDataSource.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125; &#125; 十二、通用JDBC操作封装 在DAO层的JDBC操作中，对数据的表增、删、改、查操作存在代码的冗余，我们可以对其公共部分进行封装，实现代码的复用。 12.1 DML操作封装 对于数据库的DML操作： 参数不同 SQL通过 SQL参数复制不同 通用的DML操作方法 12345678910111213141516171819202122232425262728293031323334353637383940package com.qfedu.jdbc.utils;import java.sql.Connection;import java.sql.PreparedStatement;/** * @Descript 公共DAO，用于封装公共的JDBC操作 */public class CommonDAO &#123; /** * 公共DML操作 * @param sql 执行的SQL指令 * @return */ /** * sql : delete from students where stu_num=? * args: snum * * sql : insert into students(stu_num,stu_name,stu_gender,stu_age) values(?,?,?,?) * args: 1009 Lucy 女 18 */ public boolean update(String sql, Object... args)&#123; boolean b = false; try&#123; Connection connection = DruidUtils.getConnection(); PreparedStatement preparedStatement = connection.prepareStatement(sql); for (int i = 0; i &lt; args.length ; i++) &#123; preparedStatement.setObject(i+1,args[i]); &#125; int i = preparedStatement.executeUpdate(); b = i&gt;0; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return b; &#125;&#125; 12.2 DQL操作封装 使用泛型设置通用查询方法的返回类型 12345678910111213package com.qfedu.jdbc.utils;import java.sql.ResultSet;import java.sql.SQLException;/** * @Descript 用于定义结果集映射的接口 */public interface RowMapper&lt;T&gt; &#123; public T getRow(ResultSet resultSet) throws SQLException;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.qfedu.jdbc.utils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.List;/** * @Descript 公共DAO，用于封装公共的JDBC操作 */public class CommonDAO&lt;T&gt; &#123; /** * 公共DML操作 */ public boolean update(String sql, Object... args)&#123; boolean b = false; try&#123; Connection connection = DruidUtils.getConnection(); PreparedStatement preparedStatement = connection.prepareStatement(sql); for (int i = 0; i &lt; args.length ; i++) &#123; preparedStatement.setObject(i+1,args[i]); &#125; int i = preparedStatement.executeUpdate(); b = i&gt;0; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return b; &#125; /** * 查询 */ public List&lt;T&gt; select(String sql, RowMapper&lt;T&gt; rowMapper,Object...args)&#123; List&lt;T&gt; list = new ArrayList&lt;&gt;(); try&#123; Connection connection = DruidUtils.getConnection(); PreparedStatement preparedStatement = connection.prepareStatement(sql); for (int i = 0; i &lt;args.length ; i++) &#123; preparedStatement.setObject(i+1,args[i]); &#125; ResultSet resultSet = preparedStatement.executeQuery(); while(resultSet.next())&#123; // 从查询结果中取出一条记录（多个值），封装到一个实体类对象中 // getRow就是方法调用者在调用方法时，传递进来的用于映射查询结果的方法 T t = rowMapper.getRow(resultSet); list.add(t); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return list; &#125;&#125; 12.3 基于通用JDBC操作的案例 图书信息进行JDBC操作 创建图书实体类Book 创建BookDAO 12.3.1 创建实体类1234567891011121314151617/** * @Descript 图书信息实体类 */public class Book &#123; private int bookId; private String bookName; private String bookAuthor; private double bookPrice; private int bookStock; private String bookDesc; //无参构造器 //全参构造器 //toString //get和set&#125; 12.3.2 创建DAO类 DAO中的操作都是调用CommonDAO实现的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.qfedu.jdbc.dao;import com.qfedu.jdbc.dto.Book;import com.qfedu.jdbc.utils.CommonDAO;import com.qfedu.jdbc.utils.RowMapper;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;/** * @Descript 对图书信息表进行CRUD操作 */public class BookDAO &#123; private CommonDAO&lt;Book&gt; commonDAO = new CommonDAO&lt;&gt;(); public boolean insertBook(Book book)&#123; String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; boolean b = commonDAO.update(sql, book.getBookName(), book.getBookAuthor(), book.getBookPrice(), book.getBookStock(), book.getBookDesc()); return b; &#125; public boolean deleteBook(int bookId)&#123; String sql = &quot;delete from books where book_id=?&quot;; boolean b = commonDAO.update(sql, bookId); return b; &#125; public boolean updateBook(Book book)&#123; String sql=&quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; boolean b = commonDAO.update(sql, book.getBookName(), book.getBookAuthor(), book.getBookPrice(), book.getBookStock(), book.getBookDesc(), book.getBookId()); return b; &#125; public Book queryBook(int bookId)&#123; String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; RowMapper&lt;Book&gt; bookRowMapper = new RowMapper&lt;Book&gt;()&#123; public Book getRow(ResultSet resultSet) throws SQLException &#123; int bid = resultSet.getInt(&quot;book_id&quot;); String bookName = resultSet.getString(&quot;book_name&quot;); String bookAuthor = resultSet.getString(&quot;book_author&quot;); double bookPrice = resultSet.getDouble(&quot;book_price&quot;); int bookStock = resultSet.getInt(&quot;book_stock&quot;); String bookDesc = resultSet.getString(&quot;book_desc&quot;); return new Book(bid,bookName,bookAuthor,bookPrice,bookStock,bookDesc); &#125; &#125;; List&lt;Book&gt; list = commonDAO.select(sql, bookRowMapper, bookId); return list.size()&gt;0?list.get(0):null; &#125; public List&lt;Book&gt; listBooks()&#123; String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books&quot;; List&lt;Book&gt; list = commonDAO.select(sql, resultSet -&gt; &#123; int bid = resultSet.getInt(&quot;book_id&quot;); String bookName = resultSet.getString(&quot;book_name&quot;); String bookAuthor = resultSet.getString(&quot;book_author&quot;); double bookPrice = resultSet.getDouble(&quot;book_price&quot;); int bookStock = resultSet.getInt(&quot;book_stock&quot;); String bookDesc = resultSet.getString(&quot;book_desc&quot;); return new Book(bid, bookName, bookAuthor, bookPrice, bookStock, bookDesc); &#125;); return list; &#125;&#125; 十三、Apache DBUtils13.1 DBUtils介绍 Commons DBUtils是Apache组织提供的一个针对JDBC进行简单封装的开源工具类库，使用DBUtils可以极大简化JDBC应用程序开发，同时不会影响数据库访问的性能。 DBUtils是Java编程中数据库访问的轻巧、使用的工具类库 提供对数据表通用的DML操作 提供对数据表通用的DQL操作（可以把结果封装成对象、集合等类型） DBUtils工具类库中的核心类： QueryRunner，用于执行SQL指令（相当于我们自己封装的CommonDAO类） update() , 用于执行DML指令 query(), 用于执行DQL指令 ResultSetHandler接口，结果集处理器，用于处理查询结果（相当于我们自己的封装的RowMapper接口） BeanHandler实现类：当查询语句返回一条结果时，使用BeanHandler将结果转换成一个对象 BeanListHandler实现类：当查询语句返回多个结果时，使用BeanListHandler将结果转换成一个集合 ScalarHandler实现类：当查询结果返回一个值时，使用ScalarHandler将这个值转换成Java变量类型 13.2 DBUtils的使用准备 新建Java工程 添加依赖： mysql-connector-java-8.0.26.jar druid-1.2.8.jarApache DBUtils建立数据库连接是依赖连接池数据源的，因此我们需要使用连接池 commons-dbutils-1.7.jar 配置druid的属性文件 创建com.qfedu.jdbc.utils包 在包中创建druid.properties文件，配置如下 123456789101112131415# 数据库连接信息driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8username=rootpassword=@QFedu123# 连接池属性# 连接池的初始化连接数&lt;创建数据库连接池时默认初始化的连接的个数&gt;initialSize=10# 连接池的最大连接数maxActive=50# 最小空闲连接数（当数据库连接使用率很低时，连接池中的连接会被释放一部分）minIdle=5# 超时等待时间(单位：ms)maxWait=30000 创建Druid连接池工具类 在com.qfedu.jdbc.utils包创建DruidUtils工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.qfedu.jdbc.utils;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;/** * @Descript */public class DruidUtils &#123; private static DruidDataSource druidDataSource; static&#123; try &#123; InputStream is = DruidUtils.class.getResourceAsStream(&quot;druid.properties&quot;); Properties properties = new Properties(); properties.load(is); druidDataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取数据库连接池数据源对象 * @return */ public static DataSource getDataSource()&#123; return druidDataSource; &#125; public static Connection getConnection()&#123; Connection connection = null; try &#123; connection = druidDataSource.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125;&#125; 13.3 DBUtils使用 完成图书信息的数据库操作 创建实体类 12345678910111213/** * @Descript 图书信息实体类 */public class Book &#123; private int bookId; private String bookName; private String bookAuthor; private double bookPrice; private int bookStock; private String bookDesc; &#125; 13.3.1 添加操作123456789101112131415public int insertBook(Book book)&#123; int i= 0; try &#123; //1.编写SQL String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; //2.准备参数 Object[] params = &#123;book.getBookName(),book.getBookAuthor(),book.getBookPrice(),book.getBookStock(),book.getBookDesc()&#125;; //3.调用commons-dbutils中的QueryRunner执行SQL QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); i = queryRunner.update(sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i;&#125; 13.3.2 删除操作1234567891011public int deleteBook(int bookId)&#123; int i = 0; try &#123; String sql = &quot;delete from books where book_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); i = queryRunner.update(sql,bookId); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i;&#125; 13.3.3 修改操作123456789101112public int updateBook(Book book)&#123; int i=0; try &#123; String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; Object[] params = &#123;book.getBookName(),book.getBookAuthor(),book.getBookPrice(),book.getBookStock(),book.getBookDesc(),book.getBookId()&#125;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); i = queryRunner.update(sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i;&#125; 13.3.4 查询操作查询一条记录 1234567891011121314151617public Book queryBook(int bookId)&#123; Book book = null; try &#123; String sql = &quot;select book_id bookId,book_name bookName,book_author bookAuthor,book_price bookPrice,book_stock bookStock,book_desc bookDesc from books where book_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); //1.对于查询操作，我们需要通过QueryRunner对象调用query方法来执行 //2.所有的query方法都需要一个ResultSetHandler的参数，通过此参数指定query方法的返回类型 // 如果SQL指令执行之后返回的是一行记录，我们通过BeanHandler指定查询结果封装的实体类类型 // 要求：查询结果集的字段名必须与指定的实体类的属性名匹配 // 方案1：创建实体类的时候，实体类中属性的名字与数据表中的列名相同 // 方案2：查询语句字段取别名，让字段别名与实体类属性名一致 book = queryRunner.query(sql, new BeanHandler&lt;Book&gt;(Book.class), bookId); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return book;&#125; 自定义结果集处理 自定义ResultSetHandler 1234567891011121314151617181920212223242526272829303132public Book queryBook2(int bookId)&#123; Book book = null; try &#123; String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); //1.对于查询操作，我们需要通过QueryRunner对象调用query方法来执行 //2.所有的query方法都需要一个ResultSetHandler的参数，通过此参数指定query方法的返回类型 // 如果SQL指令执行之后返回的是一行记录，我们通过BeanHandler指定查询结果封装的实体类类型 // 要求：查询结果集的字段名必须与指定的实体类的属性名匹配 // 方案3：自定义ResultSetHandler结果处理 ResultSetHandler&lt;Book&gt; resultSetHandler = new ResultSetHandler&lt;Book&gt;() &#123; @Override public Book handle(ResultSet resultSet) throws SQLException &#123; Book book = null; if(resultSet.next()) &#123; int id = resultSet.getInt(&quot;book_id&quot;); String bookName = resultSet.getString(&quot;book_name&quot;); String bookAuthor = resultSet.getString(&quot;book_author&quot;); double bookPrice = resultSet.getDouble(&quot;book_price&quot;); int bookStock = resultSet.getInt(&quot;book_stock&quot;); String bookDesc = resultSet.getString(&quot;book_desc&quot;); book = new Book(id,bookName,bookAuthor,bookPrice,bookStock,bookDesc); &#125; return book; &#125; &#125;; book = queryRunner.query(sql, resultSetHandler, bookId); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return book;&#125; 查询多条记录 123456789101112public List&lt;Book&gt; listBooks()&#123; List&lt;Book&gt; bookList = null; try &#123; String sql = &quot;select book_id bookId,book_name bookName,book_author bookAuthor,book_price bookPrice,book_stock bookStock,book_desc bookDesc from books&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); //如果SQL指令执行之后返回的是多行记录，我们通过BeanListHandler指定查询结果封装的实体类的集合类型 bookList = queryRunner.query(sql, new BeanListHandler&lt;Book&gt;(Book.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return bookList;&#125; 查询一个值 例如在做分页的时候，我们需要查询数据的总记录数 123456789101112131415public long getCount()&#123; long count = 0; String sql = &quot;select count(1) from books&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); // 如果SQL指令执行之后返回的是一个值时，我们通过ScalarHandler指定返回类型 // QueryRunner在处理统计操作时，是以long类型进行操作的，因此不能直接转成Integer // 如果我们确定这个值在int范围内，我们可以在得到long类型之后进行强转，建议使用long处理 ScalarHandler&lt;Long&gt; scalarHandler = new ScalarHandler&lt;Long&gt;(); try &#123; count = queryRunner.query(sql, scalarHandler); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/categories/JavaWeb/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"}]},{"title":"day02-mysql","slug":"day02-mysql","date":"2022-09-08T04:46:05.000Z","updated":"2022-09-12T02:00:27.171Z","comments":true,"path":"2022/09/08/day02-mysql/","link":"","permalink":"http://example.com/2022/09/08/day02-mysql/","excerpt":"","text":"一、MySQL课程内容1.1 数据库介绍 数据库概念 术语介绍 1.2 MySQL数据库 下载、安装、配置、卸载 MySQL客户端工具的安装及使用 1.3 SQL 结构化查询语言 什么是SQL SQL操作数据（CRUD操作：添加、查询、修改、删除） 1.4 SQL 高级 存储过程 索引 触发器、视图 1.5 数据库设计 数据库设计步骤 数据库设计范式 E-R图 PowerDesigner建模工具、PDMan 1.6 数据库事务 什么是事务 事务特性ACID 事务隔离级别 事务管理 二、数据库介绍2.1 数据库概念 数据库，就是存放数据的仓库 数据库（DataBase，简称DB）是长期存储在计算机内部有结构的、大量的、共享的数据集合。 长期存储：持久存储 有结构： 类型：数据库不仅可以存放数据，而且存放的数据还是有类型的 关系：存储数据与数据之间的关系 大量：大多数数据库都是文件系统的，也就是说存储在数据库中的数据实际上就是存储在磁盘的文件中 共享：多个应用程序可以通过数据库实现数据的共享 2.2 关系型数据库与非关系型数据库 关系型数据库 关系型数据库，采用了关系模型来组织数据的存储，以行和列的形式存储数据并记录数据与数据之间的关系 —— 将数据存储在表格中，可以通过建立表格与表格之间的关联来维护数据与数据之间的关系。 学生信息—- 学生表 班级信息—- 班级表 非关系型数据库 非关系型数据库，采用键值对的模型来存储数据，只完成数据的记录，不会记录数据与数据之间的关系。 在非关系型数据库中基于其特定的存储结构来解决一些大数据应用的难题。 NoSQL(Not only SQL)数据库来指代非关系型数据库。 2.3 常见的数据库产品关系型数据库产品 MySQL 免费 MariaDB Percona Server PostgreSQL Oracle 收费 SQL Server Access Sybase 达梦数据库 非关系型数据库产品 面向检索的列式存储 Column-Oriented HaBase （Hadoop子系统） BigTable （Google） 面向高并发的缓存存储Key-Value Redis MemcacheDB 面向海量数据访问的文档存储 Document–Oriented MongoDB CouchDB 2.4 数据库术语 数据库（Database）：存储的数据的集合，提供数据存储的服务 数据（Data）：实际上指的是描述事物的符号记录 数据库管理系统（Database Management System，DBMS ）： 数据库管理系统，是位于用户与操作系统之间的一层数据管理软件 数据库系统管理员（Database Anministrator，简称为DBA）:负责数据库创建、使用及维护的专门人员 数据库系统（Database System，DBS）：数据库系统管理员、数据库管理系统及数据库组成整个单元 三、MySQL数据库环境准备 MySQL下载、安装、配置、卸载，安装DBMS、使用DBMS 3.1 MySQL版本及下载3.1.1 版本 MySQL 是Oracle的免费的关系型数据库 ， 官网 https://www.mysql.com/ MySQL 目前的最新版本为8.0.26 ，在企业项目中主流版本： 5.0 — 5.5 — 5.6 — 5.7 — 8.0.26 5.x — 2020年 5.7.32 8.x — 2018年8.0.11 — 2019年 8.0.16 — 2021年 8.0.26 MySQL 8.x新特性 性能：官方8.x比5.7速度要快2倍 支持NoSQL存储：5.7开始提供了对NoSQL的支持，8.0.x做了更进一步的改进 窗口函数 索引：隐藏索引、降序索引 可用性、可靠性 3.1.2 下载 官网下载：https://dev.mysql.com/downloads/installer/ 需要注册oracle 服务器在国外，下载速度…. 镜像下载：https://www.filehorse.com/download-mysql-64/download/ 3.2 MySQL 安装 傻瓜式（直接点击下一步） 选择Developer Default模式安装 此模式会安装开发人员需要的常用组件；在安装这些组件时需要对应的环境依赖，我们要暂停，先去安装依赖的环境： 例如：Microsoft Visual C++ 2019 Redistributable Package (x64) is not installed. Latest binary compatible version will be installed if agreed to resolve this requirement. 安装： 选择自定义Custom安装 3.3 MySQL配置3.3.1 端口配置 3.3.2 账号密码设置 3.3.3 服务名称 3.4 MySQL 服务的启动与停止 MySQL是以服务的形式运行在系统中 3.4.1 计算机管理窗口此电脑—右键—管理 3.4.2 windows命令行打开命令行 ： win + R — 输入cmd回车 以管理员身份打开命令行：win+s—- 输入cmd—-选择以管理员身份运行 3.5 MySQL卸载 关闭服务 12## 管理员身份启动 cmd 命令行net stop mysql80 卸载软件 打开控制面板 点击“程序和功能” 卸载MySQL 删除目录 MySQL的安装目录：C:\\Program Files (x86)\\MySQL MySQL的数据文件目录(默认隐藏)：C:\\ProgramData\\MySQL (如果不允许删除，强制删除) 删除注册表 打开注册表： win+r — 输入regedit—回车 删除 HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\MySQL80 删除搜索mysql的相关项（非必须） 四、MySQL的管理工具 当完成数据库的安装之后，mysql是以服务的形式运行在windows&#x2F;linux系统，用户是通过DBMS工具来对MySQL进行操作的，当我们安装完成MySQL之后默认安装了mysql Commcand line Client，此工具是一个命令行形式的工具，通常我们会单独安装可视化的DBMS工具： SQLyog Navicat for MySQL 4.1 MySQL Command line Client使用 打开MySQL Command line Client: 开始菜单 — MySQL — MySQL 8.0 Command line Client 连接MySQL : 输入密码即可 （如果密码错误或者mysql服务没有启动，窗口会闪退） 关闭MySQL Command line Client：输入exit指令回车即可退出 4.2 可视化工具Navicat使用4.2.1 Navicat工具下载及安装 傻瓜式安装 4.2.2 创建连接 打开navicat工具 创建连接： 五、MySQL逻辑结构 MySQL可以存储数据，但是存储在MySQL中的数据需要按照特定的结果进行存储 学生 —— 学校 数据 —— 数据库 5.1 逻辑结构 5.2 记录&#x2F;元组 六、SQL 结构化查询语言6.1 SQL概述 SQL（Structured Query Language）结构化查询语言，用于存取、查询、更新数据以及管理关系型数据库系统 6.1.1 SQL发展 SQL是在1981年由IBM公司推出，一经推出基于其简洁的语法在数据库中得到了广泛的应用，成为主流数据库的通用规范 SQL由ANSI组织确定规范 在不同的数据库产品中遵守SQL的通用规范，但是也对SQL有一些不同的改进，形成了一些数据库的专有指令 MySQL: limit SQLServer ： top Oracle：rownum 6.1.2 SQL分类 根据SQL指令完成的数据库操作的不同，可以将SQL指令分为四类： **DDL Data Definition Language 数据定义语言 ** 用于完成对数据库对象（数据库、数据表、视图、索引等）的创建、删除、修改 DMLData Manipulation Language 数据操作&#x2F;操纵语言 用于完成对数据表中的数据的添加、删除、修改操作 添加：将数据存储到数据表 删除：将数据从数据表移除 修改：对数据表中的数据进行修改 DQL Data Query Language 数据查询语言 用于将数据表中的数据查询出来 DCL Data Control Language 数据控制语言 用于完成事务管理等控制性操作 6.2 SQL基本语法 在MySQL Command Line Client 或者navicat等工具中都可以编写SQL指令 SQL指令不区分大小写 每条SQL表达式结束之后都以;结束 SQL关键字之间以空格进行分隔 SQL之间可以不限制换行（可以有空格的地方就可以有换行） 6.3 DDL 数据定义语言6.3.1 DDL-数据库操作 使用DDL语句可以创建数据库、查询数据库、修改数据库、删除数据库 查询数据库 12345## 显示当前mysql中的数据库列表show databases;## 显示指定名称的数据的创建的SQL指令show create database &lt;dbName&gt;; 创建数据库 12345678## 创建数据库 dbName表示创建的数据库名称，可以自定义create database &lt;dbName&gt;;## 创建数据库，当指定名称的数据库不存在时执行创建create database if not exists &lt;dbName&gt;;## 在创建数据库的同时指定数据库的字符集（字符集：数据存储在数据库中采用的编码格式 utf8 gbk）create database &lt;dbName&gt; character set utf8; 修改数据库 修改数据库字符集 12## 修改数据库的字符集alter database &lt;dbName&gt; character set utf8; # utf8 gbk 删除数据库 删除数据库时会删除当前数据库中所有的数据表以及数据表中的数据 12345## 删除数据库drop database &lt;dbName&gt;;## 如果数据库存在则删除数据库drop database is exists &lt;dbName&gt;; 使用&#x2F;切换数据库 1use &lt;dbName&gt; 6.3.2 DDL-数据表操作创建数据表 数据表实际就是一个二维的表格，一个表格是由多列组成，表格中的每一类称之为表格的一个字段 12345678create table students( stu_num char(8) not null unique, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, stu_tel char(11) not null unique, stu_qq varchar(11) unique); 查询数据表 1show tables; 查询表结构 1desc &lt;tableName&gt;; 删除数据表 12345## 删除数据表drop table &lt;tableName&gt;;## 当数据表存在时删除数据表drop table if exists &lt;tableName&gt;; 修改数据表 1234567891011121314151617## 修改表名alter table &lt;tableName&gt; rename to &lt;newTableName&gt;;## 数据表也是有字符集的，默认字符集和数据库一致alter table &lt;tableName&gt; character set utf8;## 添加列（字段）alter table &lt;tableName&gt; add &lt;columnName&gt; varchar(200);## 修改列（字段）的列表和类型alter table &lt;tableName&gt; change &lt;oldColumnName&gt; &lt;newCloumnName&gt; &lt;type&gt;;## 只修改列（字段）类型alter table &lt;tableName&gt; modify &lt;columnName&gt; &lt;newType&gt;;## 删除列（字段）alter table stus drop &lt;columnName&gt;; 6.4 MySQL数据类型 数据类型，指的是数据表中的列中支持存放的数据的类型 6.4.1 数值类型在mysql中有多种数据类型可以存放数值，不同的类型存放的数值的范围或者形式是不同的 类型 内存空间大小 范围 说明 tinyint 1byte 有符号 -128127无符号 0255 特小型整数（年龄） smallint 2byte （16bit） 有符号 -32768 ~ 32767无符号 0~65535 小型整数 mediumint 3byte 有符号 -2^31 ~ 2^31 - 1无符号 0~2^32-1 中型整数 int/integer 4byte 整数 bigint 8byte 大型整数 float 4byte 单精度 double 8byte 双精度 decimal 第一参数+2 decimal(10,2)表示数值一共有10位小数位有2位 6.4.2 字符串类型 存储字符序列的类型 类型 字符长度 说明 char 0~255 字节 定长字符串，最多可以存储255个字符 ;当我们指定数据表字段为char(n)此列中的数据最长为n个字符，如果添加的数据少于n，则补’\\u0000’至n长度 varchar 0~65536 字节 可变长度字符串，此类型的类最大长度为65535 tinyblob 0~255 字节 存储二进制字符串 blob 0~65535 存储二进制字符串 mediumblob 0~1677215 存储二进制字符串 longblob 0~4294967295 存储二进制字符串 tinytext 0~255 文本数据（字符串） text 0~65535 文本数据（字符串） mediumtext 0~1677215 文本数据（字符串） longtext 0~4294967295 文本数据（字符串） 6.4.3 日期类型 在MySQL数据库中，我们可以使用字符串来存储时间，但是如果我们需要基于时间字段进行查询操作（查询在某个时间段内的数据）就不便于查询实现 类型 格式 说明 date 2021-09-13 日期，只存储年月日 time 11:12:13 时间，只存储时分秒 year 2021 年份 datetime 2021-09-13 11:12:13 日期+时间，存储年月日时分秒 timestamp 20210913 111213 日期+时间 （时间戳） 6.5 字段约束6.5.1 约束介绍 在创建数据表的时候，指定的对数据表的列的数据限制性的要求（对表的列中的数据进行限制） 为什么要给表中的列添加约束呢？ 保证数据的有效性 保证数据的完整性 保证数据的正确性 字段常见的约束有哪些呢？ 非空约束（not null）：限制此列的值必须提供，不能为null 唯一约束（unique）：在表中的多条数据，此列的值不能重复 主键约束（primary key）：非空+唯一，能够唯一标识数据表中的一条数据 外键约束（foreign key）：建立不同表之间的关联关系 6.5.2 非空约束 限制数据表中此列的值必须提供 创建表：设置图书表的 book_name not null 12345create table books( book_isbn char(4), book_name varchar(10) not null, book_author varchar(6)); 添加数据： 6.5.3 唯一约束 在表中的多条数据，此列的值不能重复 创建表：设置图书表的book_isbn为 unique 12345create table books( book_isbn char(4) unique, book_name varchar(10) not null, book_author varchar(6)); 添加数据： 6.5.4 主键约束 主键——就是数据表中记录的唯一标识，在一张表中只能有一个主键（主键可以是一个列，也可以是多个列的组合） 当一个字段声明为主键之后，添加数据时： 此字段数据不能为null 此字段数据不能重复 创建表时添加主键约束 12345create table books( book_isbn char(4) primary key, book_name varchar(10) not null, book_author varchar(6)); 或者 123456create table books( book_isbn char(4), book_name varchar(10) not null, book_author varchar(6), primary key(book_isbn)); 删除数据表主键约束 1alter table books drop primary key; 创建表之后添加主键约束 123456789## 创建表时没有添加主键约束create table books( book_isbn char(4), book_name varchar(10) not null, book_author varchar(6));## 创建表之后添加主键约束 alter table books modify book_isbn char(4) primary key; 6.5.5 主键自动增长 在我们创建一张数据表时，如果数据表中有列可以作为主键（例如：学生表的学号、图书表的isbn）我们可以直接这是这个列为主键； 当有些数据表中没有合适的列作为主键时，我们可以额外定义一个与记录本身无关的列（ID）作为主键，此列数据无具体的含义主要用于标识一条记录，在mysql中我们可以将此列定义为int，同时设置为自动增长，当我们向数据表中新增一条记录时，无需提供ID列的值，它会自动生成。 定义主键自动增长 定义int类型字段自动增长：auto_increment 12345create table types( type_id int primary key auto_increment, type_name varchar(20) not null, type_remark varchar(100)); 注意：自动增长从1开始，每添加一条记录，自动的增长的列会自定+1，当我们把某条记录删除之后再添加数据，自动增长的数据也不会重复生成（自动增长只保证唯一性、不保证连续性） 6.5.6 联合主键 联合组件——将数据表中的多列组合在一起设置为表的主键 定义联合主键 123456create table grades( stu_num char(8), course_id int, score int, primary key(stu_num,course_id)); 注意：在实际企业项目的数据库设计中，联合主键使用频率并不高；当一个张数据表中没有明确的字段可以作为主键时，我们可以额外添加一个ID字段作为主键。 6.5.7 外键约束在多表关联部分讲解 6.6 DML 数据操纵语言 用于完成对数据表中数据的插入、删除、修改操作 12345678create table students( stu_num char(8) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, stu_tel char(11) not null unique, stu_qq varchar(11) unique); 6.6.1 插入数据语法 1insert into &lt;tableName&gt;(columnName,columnName....) values(value1,value2....); 示例 12345678910111213## 向数据表中指定的列添加数据（不允许为空的列必须提供数据）insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel) values(&#x27;20210101&#x27;,&#x27;张三&#x27;,&#x27;男&#x27;,21,&#x27;13030303300&#x27;);## 数据表名后的字段名列表顺序可以不与表中一致，但是values中值的顺序必须与表名后字段名顺序对应insert into stus(stu_num,stu_name,stu_age,stu_tel,stu_gender)values(&#x27;20210103&#x27;,&#x27;王五&#x27;,20,&#x27;13030303302&#x27;,&#x27;女&#x27;);## 当要向表中的所有列添加数据时，数据表名后面的字段列表可以省略，但是values中的值的顺序要与数据表定义的字段保持一致; insert into stus values(&#x27;20210105&#x27;,&#x27;孙琦&#x27;,&#x27;男&#x27;,21,&#x27;13030303304&#x27;,&#x27;666666&#x27;);## 不过在项目开发中，即使要向所有列添加数据,也建议将列名的列表显式写出来(增强SQL的稳定性)insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq) values(&#x27;20210105&#x27;,&#x27;孙琦&#x27;,&#x27;男&#x27;,21,&#x27;13030303304&#x27;,&#x27;666666&#x27;); 6.6.2 删除数据 从数据表中删除满足特定条件（所有）的记录 语法 1delete from &lt;tableName&gt; [where conditions]; 实例 12345678## 删除学号为20210102的学生信息delete from stus where stu_num=&#x27;20210102&#x27;;## 删除年龄大于20岁的学生信息(如果满足where子句的记录有多条，则删除多条记录)delete from stus where stu_age&gt;20;## 如果删除语句没有where子句，则表示删除当前数据表中的所有记录(敏感操作)delete from stus; 6.6.3 修改数据 对数据表中已经添加的记录进行修改 语法 1update &lt;tableName&gt; set columnName=value [where conditions] 示例 1234567891011## 将学号为20210105的学生姓名修改为“孙七”（只修改一列）update stus set stu_name=&#x27;孙七&#x27; where stu_num=&#x27;20210105&#x27;;## 将学号为20210103的学生 性别修改为“男”,同时将QQ修改为 777777（修改多列）update stus set stu_gender=&#x27;男&#x27;,stu_qq=&#x27;777777&#x27; where stu_num=&#x27;20210103&#x27;;## 根据主键修改其他所有列 update stus set stu_name=&#x27;韩梅梅&#x27;,stu_gender=&#x27;女&#x27;,stu_age=18,stu_tel=&#x27;13131313311&#x27; ,stu_qq=&#x27;999999&#x27; where stu_num=&#x27;20210102&#x27;; ## 如果update语句没有where子句，则表示修改当前表中所有行（记录）update stus set stu_name=&#x27;Tom&#x27;; 6.7 DQL 数据查询语言 从数据表中提取满足特定条件的记录 单表查询 多表联合查询 6.7.1 查询基础语法12345## select 关键字后指定要显示查询到的记录的哪些列select colnumName1[,colnumName2,colnumName3...] from &lt;tableName&gt; [where conditions];## 如果要显示查询到的记录的所有列，则可以使用 * 替代字段名列表 （在项目开发中不建议使用*）select * from stus; 6.7.2 where 子句 在删除、修改及查询的语句后都可以添加where子句（条件），用于筛选满足特定的添加的数据进行删除、修改和查询操作。 123delete from tableName where conditions;update tabeName set ... where conditions;select .... from tableName where conditions; 条件关系运算符 123456789101112131415161718192021## = 等于select * from stus where stu_num = &#x27;20210101&#x27;;## != &lt;&gt; 不等于select * from stus where stu_num != &#x27;20210101&#x27;;select * from stus where stu_num &lt;&gt; &#x27;20210101&#x27;;## &gt; 大于select * from stus where stu_age&gt;18;## &lt; 小于select * from stus where stu_age&lt;20;## &gt;= 大于等于select * from stus where stu_age&gt;=20;## &lt;= 小于等于select * from stus where stu_age&lt;=20;## between and 区间查询 between v1 and v2 [v1,v2]select * from stus where stu_age between 18 and 20; 条件逻辑运算符 在where子句中，可以将多个条件通过逻辑预算(and or not )进行连接，通过多个条件来筛选要操作的数据。 12345678## and 并且 筛选多个条件同时满足的记录select * from stus where stu_gender=&#x27;女&#x27; and stu_age&lt;21;## or 或者 筛选多个条件中至少满足一个条件的记录select * from stus where stu_gender=&#x27;女&#x27; or stu_age&lt;21;## not 取反select * from stus where stu_age not between 18 and 20; 6.7.3 LIKE 子句 在where子句的条件中，我们可以使用like关键字来实现模糊查询 语法 1select * from tableName where columnName like &#x27;reg&#x27;; 在like关键字后的reg表达式中 %表示任意多个字符 【%o% 包含字母o】 _表示任意一个字符 【_o% 第二个字母为o】 示例 1234567891011# 查询学生姓名包含字母o的学生信息select * from stus where stu_name like &#x27;%o%&#x27;;# 查询学生姓名第一个字为`张`的学生信息select * from stus where stu_name like &#x27;张%&#x27;;# 查询学生姓名最后一个字母为o的学生信息select * from stus where stu_name like &#x27;%o&#x27;;# 查询学生姓名中第二个字母为o的学生信息select * from stus where stu_name like &#x27;_o%&#x27;; 6.7.4 对查询结果的处理设置查询的列 声明显示查询结果的指定列 1select colnumName1,columnName2,... from stus where stu_age&gt;20; 计算列 对从数据表中查询的记录的列进行一定的运算之后显示出来 12345678910111213## 出生年份 = 当前年份 - 年龄select stu_name,2021-stu_age from stus;+-----------+--------------+| stu_name | 2021-stu_age |+-----------+--------------+| omg | 2000 || 韩梅梅 | 2003 || Tom | 2001 || Lucy | 2000 || Polly | 2000 || Theo | 2004 |+-----------+--------------+ as 字段取别名 我们可以为查询结果的列名 去一个语义性更强的别名 (如下案例中as关键字也可以省略) 1234567891011121314151617181920212223select stu_name,2021-stu_age as stu_birth_year from stus;+-----------+----------------+| stu_name | stu_birth_year |+-----------+----------------+| omg | 2000 || 韩梅梅 | 2003 || Tom | 2001 || Lucy | 2000 || Polly | 2000 || Theo | 2004 |+-----------+----------------+ select stu_name as 姓名,2021-stu_age as 出生年份 from stus;+-----------+--------------+| 姓名 | 出生年份 |+-----------+--------------+| omg | 2000 || 韩梅梅 | 2003 || Tom | 2001 || Lucy | 2000 || Polly | 2000 || Theo | 2004 |+-----------+--------------+ distinct 消除重复行 从查询的结果中将重复的记录消除 distinct 123456789101112131415161718192021select stu_age from stus;+---------+| stu_age |+---------+| 21 || 18 || 20 || 21 || 21 || 17 |+---------+select distinct stu_age from stus;+---------+| stu_age |+---------+| 21 || 18 || 20 || 17 |+---------+ 6.7.5 排序 - order by 将查询到的满足条件的记录按照指定的列的值升序&#x2F;降序排列 语法 1select * from tableName where conditions order by columnName asc|desc; order by columnName 表示将查询结果按照指定的列排序 asc 按照指定的列升序（默认） desc 按照指定的列降序 实例 12345678910111213141516171819202122232425# 单字段排序select * from stus where stu_age&gt;15 order by stu_gender desc;+----------+-----------+------------+---------+-------------+--------+| stu_num | stu_name | stu_gender | stu_age | stu_tel | stu_qq |+----------+-----------+------------+---------+-------------+--------+| 20210101 | omg | 男 | 21 | 13030303300 | NULL || 20210103 | Tom | 男 | 20 | 13030303302 | 777777 || 20210105 | Polly | 男 | 21 | 13030303304 | 666666 || 20210106 | Theo | 男 | 17 | 13232323322 | NULL || 20210102 | 韩梅梅 | 女 | 18 | 13131313311 | 999999 || 20210104 | Lucy | 女 | 21 | 13131323334 | NULL |+----------+-----------+------------+---------+-------------+--------+# 多字段排序 ： 先满足第一个排序规则，当第一个排序的列的值相同时再按照第二个列的规则排序select * from stus where stu_age&gt;15 order by stu_gender asc,stu_age desc;+----------+-----------+------------+---------+-------------+--------+| stu_num | stu_name | stu_gender | stu_age | stu_tel | stu_qq |+----------+-----------+------------+---------+-------------+--------+| 20210104 | Lucy | 女 | 21 | 13131323334 | NULL || 20210102 | 韩梅梅 | 女 | 18 | 13131313311 | 999999 || 20210101 | omg | 男 | 21 | 13030303300 | NULL || 20210105 | Polly | 男 | 21 | 13030303304 | 666666 || 20210103 | Tom | 男 | 20 | 13030303302 | 777777 || 20210106 | Theo | 男 | 17 | 13232323322 | NULL |+----------+-----------+------------+---------+-------------+--------+ 6.7.6 聚合函数 SQL中提供了一些可以对查询的记录的列进行计算的函数——聚合函数 count max min sum avg count() 统计函数，统计满足条件的指定字段值的个数（记录数） 123456789101112131415# 统计学生表中学生总数select count(stu_num) from stus;+----------------+| count(stu_num) |+----------------+| 7 |+----------------+# 统计学生表中性别为男的学生总数select count(stu_num) from stus where stu_gender=&#x27;男&#x27;;+----------------+| count(stu_num) |+----------------+| 5 |+----------------+ max() 计算最大值，查询满足条件的记录中指定列的最大值 12345678910111213select max(stu_age) from stus;+--------------+| max(stu_age) |+--------------+| 21 |+--------------+select max(stu_age) from stus where stu_gender=&#x27;女&#x27;;+--------------+| max(stu_age) |+--------------+| 21 |+--------------+ min() 计算最小值，查询满足条件的记录中指定列的最小值 12345678910111213select min(stu_age) from stus;+--------------+| min(stu_age) |+--------------+| 14 |+--------------+select min(stu_age) from stus where stu_gender=&#x27;女&#x27;;+--------------+| min(stu_age) |+--------------+| 18 |+--------------+ sum() 计算和，查询满足条件的记录中 指定的列的值的总和 123456789101112131415# 计算所有学生年龄的综合select sum(stu_age) from stus;+--------------+| sum(stu_age) |+--------------+| 133 |+--------------+# 计算所有性别为男的学生的年龄的综合select sum(stu_age) from stus where stu_gender=&#x27;男&#x27;;+--------------+| sum(stu_age) |+--------------+| 94 |+--------------+ avg() 求平均值，查询满足条件的记录中 计算指定列的平均值 12345678910111213select avg(stu_age) from stus;+--------------+| avg(stu_age) |+--------------+| 19.0000 |+--------------+select avg(stu_age) from stus where stu_gender=&#x27;男&#x27;;+--------------+| avg(stu_age) |+--------------+| 18.8000 |+--------------+ 6.7.7 日期函数 和 字符串函数日期函数 当我们向日期类型的列添加数据时，可以通过字符串类型赋值（字符串的格式必须为 yyyy-MM-dd hh:mm:ss） 如果我们想要获取当前系统时间添加到日期类型的列，可以使用now() 或者 sysdate() 示例： 123456789101112131415161718192021222324252627282930313233343536373839desc stus;+---------------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------------+-------------+------+-----+---------+-------+| stu_num | char(8) | NO | PRI | NULL | || stu_name | varchar(20) | NO | | NULL | || stu_gender | char(2) | YES | | NULL | || stu_age | int | NO | | NULL | || stu_tel | char(11) | NO | UNI | NULL | || stu_qq | varchar(11) | YES | UNI | NULL | || stu_enterence | datetime | YES | | NULL | |+---------------+-------------+------+-----+---------+-------+# 通过字符串类型 给日期类型的列赋值insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_enterence)values(&#x27;20200108&#x27;,&#x27;张小三&#x27;,&#x27;女&#x27;,20,&#x27;13434343344&#x27;,&#x27;123111&#x27;,&#x27;2021-09-01 09:00:00&#x27;);# 通过now()获取当前时间insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_enterence)values(&#x27;20210109&#x27;,&#x27;张小四&#x27;,&#x27;女&#x27;,20,&#x27;13434343355&#x27;,&#x27;1233333&#x27;,now());# 通过sysdate()获取当前时间insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_enterence)values(&#x27;20210110&#x27;,&#x27;李雷&#x27;,&#x27;男&#x27;,16,&#x27;13434343366&#x27;,&#x27;123333344&#x27;,sysdate());# 通过now和sysdate获取当前系统时间mysql&gt; select now();+---------------------+| now() |+---------------------+| 2021-09-10 16:22:19 |+---------------------+mysql&gt; select sysdate();+---------------------+| sysdate() |+---------------------+| 2021-09-10 16:22:26 |+---------------------+ 字符串函数 就是通过SQL指令对字符串进行处理 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# concat(colnum1,colunm2,...) 拼接多列select concat(stu_name,&#x27;-&#x27;,stu_gender) from stus;+---------------------------------+| concat(stu_name,&#x27;-&#x27;,stu_gender) |+---------------------------------+| 韩梅梅-女 || Tom-男 || Lucy-女 || 林涛-男 |+---------------------------------+# upper(column) 将字段的值转换成大写mysql&gt; select upper(stu_name) from stus;+-----------------+| upper(stu_name) |+-----------------+| 韩梅梅 || TOM || LUCY || POLLY || THEO || 林涛 |+-----------------+# lower(column) 将指定列的值转换成小写mysql&gt; select lower(stu_name) from stus;+-----------------+| lower(stu_name) |+-----------------+| 韩梅梅 || tom || lucy || polly || theo |+-----------------+# substring(column,start,len) 从指定列中截取部分显示 start从1开始mysql&gt; select stu_name,substring(stu_tel,8,4) from stus;+-----------+------------------------+| stu_name | substring(stu_tel,8,4) |+-----------+------------------------+| 韩梅梅 | 3311 || Tom | 3302 || Lucy | 3334 |+-----------+------------------------+ 6.7.8 分组查询 - group by 分组——就是将数据表中的记录按照指定的类进行分组 语法 12345select 分组字段/聚合函数 from 表名 [where 条件] group by 分组列名 [having 条件][order by 排序字段] select 后使用* 显示对查询的结果进行分组之后，显示每组的第一条记录（这种显示通常是无意义的） select后通常显示分组字段和聚合函数(对分组后的数据进行统计、求和、平均值等) 语句执行属性： 1️⃣先根据where条件从数据库查询记录 2️⃣group by对查询记录进行分组 3️⃣执行having对分组后的数据进行筛选 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 先对查询的学生信息按性别进行分组（分成了男、女两组），然后再分别统计每组学生的个数select stu_gender,count(stu_num) from stus group by stu_gender;+------------+----------------+| stu_gender | count(stu_num) |+------------+----------------+| 女 | 4 || 男 | 5 |+------------+----------------+# 先对查询的学生信息按性别进行分组（分成了男、女两组），然后再计算每组的平均年龄select stu_gender,avg(stu_age) from stus group by stu_gender;+------------+--------------+| stu_gender | avg(stu_age) |+------------+--------------+| 女 | 19.7500 || 男 | 18.2000 |+------------+--------------+# 先对学生按年龄进行分组（分了16、17、18、20、21、22六组），然后统计各组的学生数量，还可以对最终的结果排序select stu_age,count(stu_num) from stus group by stu_age order by stu_age;+---------+----------------+| stu_age | count(stu_num) |+---------+----------------+| 16 | 2 || 17 | 1 || 18 | 1 || 20 | 3 || 21 | 1 || 22 | 1 |+---------+----------------+# 查询所有学生，按年龄进行分组，然后分别统计每组的人数，再筛选当前组人数&gt;1的组，再按年龄升序显示出来select stu_age,count(stu_num) from stus group by stu_age having count(stu_num)&gt;1 order by stu_age;+---------+----------------+| stu_age | count(stu_num) |+---------+----------------+| 16 | 2 || 20 | 3 |+---------+----------------+# 查询性别为&#x27;男&#x27;的学生，按年龄进行分组，然后分别统计每组的人数，再筛选当前组人数&gt;1的组，再按年龄升序显示出来mysql&gt; select stu_age,count(stu_num) -&gt; from stus -&gt; where stu_gender=&#x27;男&#x27; -&gt; group by stu_age -&gt; having count(stu_num)&gt;1 -&gt; order by stu_age;+---------+----------------+| stu_age | count(stu_num) |+---------+----------------+| 16 | 2 || 20 | 2 |+---------+----------------+ 6.7.9 分页查询 - limit 当数据表中的记录比较多的时候，如果一次性全部查询出来显示给用户，用户的可读性&#x2F;体验性就不太好，因此我们可以将这些数据分页进行展示。 语法 1234select ... from ... where ...limit param1,param2 param1 int , 表示获取查询语句的结果中的第一条数据的索引（索引从0开始） param2 int, 表示获取的查询记录的条数（如果剩下的数据条数&lt;param2，则返回剩下的所有记录） 案例 对数据表中的学生信息进行分页显示，总共有10条数据，我们每页显示3条 总记录数 count 10 每页显示 pageSize 3 总页数： pageCount &#x3D; count%pageSize&#x3D;&#x3D;0 ? count&#x2F;pageSize : count&#x2F;pageSize +1; 1234567891011121314151617# 查询第一页：select * from stus [where ...] limit 0,3; (1-1)*3# 查询第二页：select * from stus [where ...] limit 3,3; (2-1)*3# 查询第三页：select * from stus [where ...] limit 6,3; (3-1)*3# 查询第四页：select * from stus [where ...] limit 9,3; (4-1)*3# 如果在一张数据表中：# pageNum表示查询的页码# pageSize表示每页显示的条数# 通用分页语句如下：select * from &lt;tableName&gt; [where ...] limit (pageNum-1)*pageSize,pageSize; 七、数据表的关联关系7.1 关联关系介绍 MySQL是一个关系型数据库，不仅可以存储数据，还可以维护数据与数据之间的关系——通过在数据表中添加字段建立外键约束 数据与数据之间的关联关系分为四种： 一对一关联 一对多关联 多对一关联 多对多关联 7.2 一对一关联 人 — 身份证 一个人只有一个身份证、一个身份证只对应一个人 学生 — 学籍 一个学生只有一个学籍、一个学籍也对应唯一的一个学生 用户 — 用户详情 一个用户只有一个详情、一个详情也只对应一个用户 方案1： 主键关联——两张数据表中主键相同的数据为相互对应的数据 方案2：唯一外键 —— 在任意一张表中添加一个字段添加外键约束与另一张表主键关联，并且将外键列添加唯一约束 7.3 一对多与多对一 班级 — 学生 （一对多） 一个班级包含多个学生 学生 — 班级 （多对一） 多个学生可以属于同一个班级 图书 — 分类 商品 —- 商品类别 方案：在多的一端添加外键 ，与一的一端主键进行关联 7.4 多对多关联 学生 — 课程 一个学生可以选择多门课、一门课程也可以由多个学生选择 会员 — 社团 一个会员可以参加多个社团、一个社团也可以招纳多个会员 方法：额外创建一张关系表来维护多对多关联——在关系表中定义两个外键，分别与两个数据表的主键进行关联 7.5 外键约束 外键约束——将一个列添加外键约束与另一张表的主键(唯一列)进行关联之后，这个外键约束的列添加的数据必须要在关联的主键字段中存在 案例：学生表 与 班级表 先创建班级表 12345create table classes( class_id int primary key auto_increment, class_name varchar(40) not null unique, class_remark varchar(200)); 创建学生表（在学生表中添加外键与班级表的主键进行关联） 123456789101112131415161718192021222324# 【方式一】在创建表的时候，定义cid字段，并添加外键约束# 由于cid 列 要与classes表的class_id进行关联，因此cid字段类型和长度要与 class_id一致create table students( stu_num char(8) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, cid int, constraint FK_STUDENTS_CLASSES foreign key(cid) references classes(class_id));#【方式二】先创建表，再添加外键约束create table students( stu_num char(8) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, cid int);# 在创建表之后，为cid添加外键约束alter table students add constraint FK_STUDENTS_CLASSES foreign key(cid) references classes(class_id);# 删除外键约束alter table students drop foreign key FK_STUDENTS_CLASSES; 向班级表添加班级信息 1234567891011121314insert into classes(class_name,class_remark) values(&#x27;Java2104&#x27;,&#x27;...&#x27;);insert into classes(class_name,class_remark) values(&#x27;Java2105&#x27;,&#x27;...&#x27;);insert into classes(class_name,class_remark) values(&#x27;Java2106&#x27;,&#x27;...&#x27;);insert into classes(class_name,class_remark) values(&#x27;Python2106&#x27;,&#x27;...&#x27;);select * from classes;+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 1 | Java2104 | ... || 2 | Java2105 | ... || 3 | Java2106 | ... || 4 | Python2106 | ... |+----------+------------+--------------+ 向学生表中添加学生信息 123456insert into students(stu_num,stu_name,stu_gender,stu_age,cid)values(&#x27;20210102&#x27;,&#x27;李斯&#x27;,&#x27;女&#x27;,20, 4 );# 添加学生时，设置给cid外键列的值必须在其关联的主表classes的classs_id列存在insert into students(stu_num,stu_name,stu_gender,stu_age,cid)values(&#x27;20210103&#x27;,&#x27;王五&#x27;,&#x27;男&#x27;,20, 6 ); 7.6 外键约束-级联 当学生表中存在学生信息关联班级表的某条记录时，就不能对班级表的这条记录进行修改ID和删除操作，如下： 123456789101112131415161718192021222324252627mysql&gt; select * from classes;+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 1 | Java2104 | ... | # 班级表中class_id=1的班级信息 被学生表中的记录关联了| 2 | Java2105 | ... | # 我们就不能修改Java2104的class_id,并且不能删除 | 3 | Java2106 | ... || 4 | Python2106 | ... |+----------+------------+--------------+mysql&gt; select * from students;+----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210101 | 张三 | 男 | 18 | 1 || 20210102 | 李四 | 男 | 18 | 1 || 20210103 | 王五 | 男 | 18 | 1 || 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+mysql&gt; update classes set class_id=5 where class_name=&#x27;Java2104&#x27;;ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`db_test2`.`students`, CONSTRAINT `FK_STUDENTS_CLASSES` FOREIGN KEY (`cid`) REFERENCES `classes` (`class_id`))mysql&gt; delete from classes where class_id=1;ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`db_test2`.`students`, CONSTRAINT `FK_STUDENTS_CLASSES` FOREIGN KEY (`cid`) REFERENCES `classes` (`class_id`)) 如果一定要修改Java2104 的班级ID，该如何实现呢 ？ 将引用Java2104班级id的学生记录中的cid修改为 NULL 在修改班级信息表中Java2104记录的 class_id 将学生表中cid设置为NULL的记录的cid重新修改为 Java2104这个班级的新的id 12345678910111213141516171819202122232425262728291️⃣update students set cid=NULL where cid=1; # 结果如下：+----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210101 | 张三 | 男 | 18 | NULL || 20210102 | 李四 | 男 | 18 | NULL || 20210103 | 王五 | 男 | 18 | NULL || 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+2️⃣update classes set class_id=5 where class_name=&#x27;Java2104&#x27;; # 结果如下+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 2 | Java2105 | ... || 3 | Java2106 | ... || 4 | Python2106 | ... || 5 | Java2104 | ... |+----------+------------+--------------+3️⃣update students set cid=5 where cid IS NULL; # 结果如下+----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210101 | 张三 | 男 | 18 | 5 || 20210102 | 李四 | 男 | 18 | 5 || 20210103 | 王五 | 男 | 18 | 5 || 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+ 我们可以使用级联操作来实现： 在添加外键时，设置级联修改 和 级联删除 12345# 删除原有的外键alter table students drop foreign key FK_STUDENTS_CLASSES;# 重新添加外键，并设置级联修改和级联删除alter table students add constraint FK_STUDENTS_CLASSES foreign key(cid) references classes(class_id) ON UPDATE CASCADE ON DELETE CASCADE; 测试级联修改： 12345678910111213141516171819202122232425262728293031323334353637383940# 班级信息+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 2 | Java2105 | ... || 3 | Java2106 | ... || 4 | Python2106 | ... || 5 | Java2104 | ... |+----------+------------+--------------+# 学生信息+----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210101 | 张三 | 男 | 18 | 5 || 20210102 | 李四 | 男 | 18 | 5 || 20210103 | 王五 | 男 | 18 | 5 || 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+# 直接修改Java2104的class_id,关联Java2104这个班级的学生记录的cid也会同步修改update classes set class_id=1 where class_name=&#x27;Java2104&#x27;;# 班级信息+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 2 | Java2105 | ... || 3 | Java2106 | ... || 4 | Python2106 | ... || 1 | Java2104 | ... |+----------+------------+--------------+# 学生信息+----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210101 | 张三 | 男 | 18 | 1 || 20210102 | 李四 | 男 | 18 | 1 || 20210103 | 王五 | 男 | 18 | 1 || 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+ 测试级联删除 123456789101112131415# 删除class_id=1的班级信息，学生表引用此班级信息的记录也会被同步删除delete from classes where class_id=1;+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 2 | Java2105 | ... || 3 | Java2106 | ... || 4 | Python2106 | ... |+----------+------------+--------------++----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+ 八、连接查询 通过对DQL的学习，我们可以很轻松的从一张数据表中查询出需要的数据；在企业的应用开发中，我们经常需要从多张表中查询数据（例如：我们查询学生信息的时候需要同时查询学生的班级信息），可以通过连接查询从多张数据表提取数据: 在MySQL中可以使用join实现多表的联合查询——连接查询，join按照其功能不同分为三个操作： inner join 内连接 left join 左连接 right join 右连接 8.1 数据准备8.1.1 创建数据表创建班级信息表 和 学生信息表 12345678910111213create table classes( class_id int primary key auto_increment, class_name varchar(40) not null unique, class_remark varchar(200));create table students( stu_num char(8) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, cid int, constraint FK_STUDENTS_CLASSES foreign key(cid) references classes(class_id) ON UPDATE CASCADE ON DELETE CASCADE); 8.1.2 添加数据添加班级信息 123456789# Java2104 包含三个学生信息insert into classes(class_name,class_remark) values(&#x27;Java2104&#x27;,&#x27;...&#x27;);# Java2105 包含两个学生信息insert into classes(class_name,class_remark) values(&#x27;Java2105&#x27;,&#x27;...&#x27;);# 以下两个班级在学生表中没有对应的学生信息insert into classes(class_name,class_remark) values(&#x27;Java2106&#x27;,&#x27;...&#x27;);insert into classes(class_name,class_remark) values(&#x27;Python2105&#x27;,&#x27;...&#x27;); 添加学生信息 1234567891011121314151617# 以下三个学生信息 属于 class_id=1 的班级 （Java2104）insert into students(stu_num,stu_name,stu_gender,stu_age,cid) values(&#x27;20210101&#x27;,&#x27;张三&#x27;,&#x27;男&#x27;,20,1);insert into students(stu_num,stu_name,stu_gender,stu_age,cid) values(&#x27;20210102&#x27;,&#x27;李四&#x27;,&#x27;女&#x27;,20,1);insert into students(stu_num,stu_name,stu_gender,stu_age,cid) values(&#x27;20210103&#x27;,&#x27;王五&#x27;,&#x27;男&#x27;,20,1);# 以下三个学生信息 属于 class_id=2 的班级 （Java2105）insert into students(stu_num,stu_name,stu_gender,stu_age,cid) values(&#x27;20210104&#x27;,&#x27;赵柳&#x27;,&#x27;女&#x27;,20,2);insert into students(stu_num,stu_name,stu_gender,stu_age,cid) values(&#x27;20210105&#x27;,&#x27;孙七&#x27;,&#x27;男&#x27;,20,2);# 小红和小明没有设置班级信息insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;20210106&#x27;,&#x27;小红&#x27;,&#x27;女&#x27;,20);insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;20210107&#x27;,&#x27;小明&#x27;,&#x27;男&#x27;,20); 8.2 内连接 INNER JOIN语法 1select ... from tableName1 inner join tableName2 ON 匹配条件 [where 条件]; 8.2.1 笛卡尔积 笛卡尔积（A集合&amp;B集合）：使用A中的每个记录一次关联B中每个记录，笛卡尔积的总数&#x3D;A总数*B总数 如果直接执行select ... from tableName1 inner join tableName2;会获取两种数据表中的数据集合的笛卡尔积（依次使用tableName1 表中的每一条记录 去 匹配 tableName2的每条数据） 8.2.2 内连接条件 两张表时用inner join连接查询之后生产的笛卡尔积数据中很多数据都是无意义的，我们如何消除无意义的数据呢？ —— 添加两张进行连接查询时的条件 使用 on设置两张表连接查询的匹配条件 12345-- 使用where设置过滤条件：先生成笛卡尔积再从笛卡尔积中过滤数据（效率很低）select * from students INNER JOIN classes where students.cid = classes.class_id;-- 使用ON设置连接查询条件：先判断连接条件是否成立，如果成立两张表的数据进行组合生成一条结果记录select * from students INNER JOIN classes ON students.cid = classes.class_id; 结果：只获取两种表中匹配条件成立的数据，任何一张表在另一种表如果没有找到对应匹配则不会出现在查询结果中（例如：小红和小明没有对应的班级信息，Java2106和Python2106没有对应的学生）。 8.2 左连接 LEFT JOIN 需求：请查询出所有的学生信息，如果学生有对应的班级信息，则将对应的班级信息也查询出来 左连接：显示左表中的所有数据，如果在有右表中存在与左表记录满足匹配条件的数据，则进行匹配；如果右表中不存在匹配数据，则显示为Null 12345# 语法select * from leftTabel LEFT JOIN rightTable ON 匹配条件 [where 条件];-- 左连接 : 显示左表中的所有记录select * from students LEFT JOIN classes ON students.cid = classes.class_id; 8.3 右连接 RIGHT JOIN12-- 右连接 ：显示右表中的所有记录select * from students RIGHT JOIN classes ON students.cid = classes.class_id; 8.4 数据表别名 如果在连接查询的多张表中存在相同名字的字段，我们可以使用表名.字段名来进行区分，如果表名太长则不便于SQL语句的编写，我们可以使用数据表别名 使用示例： 1234select s.*,c.class_namefrom students sINNER JOIN classes cON s.cid = c.class_id; 8.5 子查询&#x2F;嵌套查询 子查询 — 先进行一次查询，第一次查询的结果作为第二次查询的源&#x2F;条件（第二次查询是基于第一次的查询结果来进行的） 8.5.1 子查询返回单个值-单行单列案例1：查询班级名称为&#39;Java2104&#39;班级中的学生信息(只知道班级名称，而不知道班级ID) 传统的方式： 12345-- a.查询Java2104班的班级编号select class_id from classes where class_name=&#x27;Java2104&#x27;;-- b.查询此班级编号下的学生信息select * from students where cid = 1; 子查询： 12-- 如果子查询返回的结果是一个值（单列单行），条件可以直接使用关系运算符（= != ....）select * from students where cid = (select class_id from classes where class_name=&#x27;Java2105&#x27;); 8.5.2 子查询返回多个值-多行单列案例2：查询所有Java班级中的学生信息 传统的方式： 12345678910111213141516-- a.查询所有Java班的班级编号select class_id from classes where class_name LIKE &#x27;Java%&#x27;;+--------------+| class_id |+--------------+| 1 || 2 || 3 |+--------------+-- b.查询这些班级编号中的学生信息(union 将多个查询语句的结果整合在一起)select * from students where cid=1UNIONselect * from students where cid=2UNIONselect * from students where cid=3; 子查询 12-- 如果子查询返回的结果是多个值（单列多行），条件使用IN / NOT INselect * from students where cid IN (select class_id from classes where class_name LIKE &#x27;Java%&#x27;); 8.5.3 子查询返回多个值-多行多列案例3：查询cid=1的班级中性别为男的学生信息 123456-- 多条件查询：select * from students where cid=1 and stu_gender=&#x27;男&#x27;;-- 子查询:先查询cid=1班级中的所有学生信息，将这些信息作为一个整体虚拟表(多行多列)-- 再基于这个虚拟表查询性别为男的学生信息（‘虚拟表’需要别名）select * from (select * from students where cid=1) t where t.stu_gender=&#x27;男&#x27;; 九、存储过程9.1 存储过程介绍9.1.1 SQL指令执行过程 从SQL执行执行的流程中我们分析存在的问题： 如果我们需要重复多次执行相同的SQL，SQL执行都需要通过连接传递到MySQL，并且需要经过编译和执行的步骤； 如果我们需要连续执行多个SQL指令，并且第二个SQL指令需要使用第一个SQL指令执行的结果作为参数； 9.1.2 存储过程的介绍 存储过程： 将能够完成特定功能的SQL指令进行封装（SQL指令集），编译之后存储在数据库服务器上，并且为之取一个名字，客户端可以通过名字直接调用这个SQL指令集，获取执行结果。 9.1.3 存储过程优缺点分析存储过程优点： SQL指令无需客户端编写，通过网络传送，可以节省网络开销，同时避免SQL指令在网络传输过程中被恶意篡改保证安全性； 存储过程经过编译创建并保存在数据库中的，执行过程无需重复的进行编译操作，对SQL指令的执行过程进行了性能提升； 存储过程中多个SQL指令之间存在逻辑关系，支持流程控制语句（分支、循环），可以实现更为复杂的业务; 存储过程的缺点： 存储过程是根据不同的数据库进行编译、创建并存储在数据库中；当我们需要切换到其他的数据库产品时，需要重写编写针对于新数据库的存储过程； 存储过程受限于数据库产品，如果需要高性能的优化会成为一个问题； 在互联网项目中，如果需要数据库的高（连接）并发访问，使用存储过程会增加数据库的连接执行时间（因为我们将复杂的业务交给了数据库进行处理） 9.2 创建存储过程9.2.1 存储过程创建语法12345-- 语法:create procedure &lt;proc_name&gt;([IN/OUT args])begin -- SQLend; 9.2.2 示例123456-- 创建一个存储过程实现加法运算: Java语法中，方法是有参数和返回值的-- 存储过程中，是有输入参数 和 输出参数的create procedure proc_test1(IN a int,IN b int,OUT c int)begin SET c = a+b;end; 9.3 调用存储过程1234567-- 调用存储过程-- 定义变量@mset @m = 0;-- 调用存储过程，将3传递给a，将2传递给b，将@m传递给ccall proc_test1(3,2,@m);-- 显示变量值select @m from dual; 9.4 存储过程中变量的使用 存储过程中的变量分为两种：局部变量 和 用户变量 9.4.1 定义局部变量局部变量：定义在存储过程中的变量，只能在存储过程内部使用 局部变量定义语法 12-- 局部变量要定义在存储过程中，而且必须定义在存储过程开始declare &lt;attr_name&gt; &lt;type&gt; [default value]; 局部变量定义示例： 12345678create procedure proc_test2(IN a int,OUT r int)begin declare x int default 0; -- 定义x int类型，默认值为0 declare y int default 1; -- 定义y set x = a*a; set y = a/2; set r = x+y;end; 9.4.2 定义用户变量用户变量：相当于全局变量，定义的用户变量可以通过select @attrName from dual进行查询 123-- 用户变量会存储在mysql数据库的数据字典中（dual）-- 用户变量定义使用set关键字直接定义，变量名要以@开头set @n=1; 9.4.3 给变量设置值 无论是局部变量还是用户变量，都是使用set关键字修改值 123set @n=1;call proc_test2(6,@n);select @n from dual; 9.4.4 将查询结果赋值给变量在存储过程中使用select..into..给变量赋值 123456789-- 查询学生数量create procedure proc_test3(OUT c int)begin select count(stu_num) INTO c from students; -- 将查询到学生数量赋值给cend;-- 调用存储过程call proc_test3(@n);select @n from dual; 9.4.5 用户变量使用注意事项 因为用户变量相当于全局变量，可以在SQL指令以及多个存储过程中共享，在开发中建议尽量少使用用户变量，用户变量过多会导致程序不易理解、难以维护。 9.5 存储过程的参数 MySQL存储过程的参数一共有三种：IN \\ OUT \\ INOUT 9.5.1 IN 输入参数输入参数——在调用存储过程中传递数据给存储过程的参数（在调用的过程必须为具有实际值的变量 或者 字面值） 12345678-- 创建存储过程：添加学生信息create procedure proc_test4(IN snum char(8),IN sname varchar(20), IN gender char(2), IN age int, IN cid int, IN remark varchar(255))begin insert into students(stu_num,stu_name,stu_gender,stu_age,cid,remark) values(snum,sname,gender,age,cid,remark);end;call proc_test4(&#x27;20210108&#x27;,&#x27;小丽&#x27;,&#x27;女&#x27;,20,1,&#x27;aaa&#x27;); 9.5.2 OUT 输出参数输出参数——将存储过程中产生的数据返回给过程调用者，相当于Java方法的返回值，但不同的是一个存储过程可以有多个输出参数 123456789-- 创建存储过程，根据学生学号，查询学生姓名create procedure proc_test5(IN snum char(8),OUT sname varchar(20))begin select stu_name INTO sname from students where stu_num=snum;end;set @name=&#x27;&#x27;;call proc_test5(&#x27;20210108&#x27;,@name);select @name from dual; 9.5.3 INOUT 输入输出参数12345678create procedure proc_test6(INOUT str varchar(20))begin select stu_name INTO str from students where stu_num=str;end;set @name=&#x27;20210108&#x27;;call proc_test6(@name);select @name from dual; 9.6 存储过程中流程控制 在存储过程中支持流程控制语句用于实现逻辑的控制 9.6.1 分支语句 if-then-else 1234567891011-- 单分支：如果条件成立，则执行SQLif conditions then -- SQLend if;-- 如果参数a的值为1，则添加一条班级信息create procedure proc_test7(IN a int)begin if a=1 then insert into classes(class_name,remark) values(&#x27;Java2109&#x27;,&#x27;test&#x27;); end if;end; 12345678910111213141516-- 双分支：如果条件成立则执行SQL1，否则执行SQL2if conditions then -- SQL1else -- SQL2end if;-- 如果参数a的值为1，则添加一条班级信息；否则添加一条学生信息create procedure proc_test7(IN a int)begin if a=1 then insert into classes(class_name,remark) values(&#x27;Java2109&#x27;,&#x27;test&#x27;); else insert into students(stu_num,stu_name,stu_gender,stu_age,cid,remark) values(&#x27;20210110&#x27;,&#x27;小花&#x27;,&#x27;女&#x27;,19,1,&#x27;...&#x27;); end if;end; case 12345678910111213141516-- casecreate procedure proc_test8(IN a int)begin case a when 1 then -- SQL1 如果a的值为1 则执行SQL1 insert into classes(class_name,remark) values(&#x27;Java2110&#x27;,&#x27;wahaha&#x27;); when 2 then -- SQL2 如果a的值为2 则执行SQL2 insert into students(stu_num,stu_name,stu_gender,stu_age,cid,remark) values(&#x27;20210111&#x27;,&#x27;小刚&#x27;,&#x27;男&#x27;,21,2,&#x27;...&#x27;); else -- SQL (如果变量的值和所有when的值都不匹配，则执行else中的这个SQL) update students set stu_age=18 where stu_num=&#x27;20210110&#x27;; end case;end; 9.6.2 循环语句 while 12345678910111213-- whilecreate procedure proc_test9(IN num int)begin declare i int; set i = 0; while i&lt;num do -- SQL insert into classes(class_name,remark) values( CONCAT(&#x27;Java&#x27;,i) ,&#x27;....&#x27;); set i = i+1; end while;end;call proc_test9(4); repeat 12345678910111213-- repeatcreate procedure proc_test10(IN num int)begin declare i int; set i = 1; repeat -- SQL insert into classes(class_name,remark) values( CONCAT(&#x27;Python&#x27;,i) ,&#x27;....&#x27;); set i = i+1; until i &gt; num end repeat;end;call proc_test10(4); loop 12345678910111213141516-- loopcreate procedure proc_test11(IN num int)begin declare i int ; set i =0; myloop:loop -- SQL insert into classes(class_name,remark) values( CONCAT(&#x27;HTML&#x27;,i) ,&#x27;....&#x27;); set i = i+1; if i=num then leave myloop; end if; end loop;end;call proc_test11(5); 9.7 存储过程管理9.7.1 查询存储过程 存储过程是属于某个数据库的，也就是说当我们将存储过程创建在某个数据库之后，只能在当前数据库中调用此存储过程。 查询存储过程：查询某个数据库中有哪些存储过程 12345-- 根据数据库名，查询当前数据库中的存储过程show procedure status where db=&#x27;db_test2&#x27;;-- 查询存储过程的创建细节show create procedure db_test2.proc_test1; 9.7.2 修改存储过程 修改存储过程指的是修改存储过程的特征&#x2F;特性 1alter procedure &lt;proc_name&gt; 特征1 [特征2 特征3 ....] 存储过程的特征参数： CONTAINS SQL 表示子程序包含 SQL 语句，但不包含读或写数据的语句 NO SQL 表示子程序中不包含 SQL 语句 READS SQL DATA 表示子程序中包含读数据的语句 MODIFIES SQL DATA 表示子程序中包含写数据的语句 SQL SECURITY { DEFINER |INVOKER } 指明谁有权限来执行 DEFINER 表示只有定义者自己才能够执行 INVOKER 表示调用者可以执行 COMMENT &#39;string&#39; 表示注释信息 1alter procedure proc_test1 READS SQL DATA; 9.7.3 删除存储过程1234-- 删除存储过程-- drop 删除数据库中的对象 数据库、数据表、列、存储过程、视图、触发器、索引....-- delete 删除数据表中的数据drop procedure proc_test1; 9.8 存储过程练习案例 使用存储过程解决企业项目开发过程中的问题 案例：使用存储过程完成借书操作 9.8.1 数据准备12345678910111213141516171819202122232425262728293031323334-- 创建数据库create database db_test3;-- 使用数据库use db_test3;-- 创建图书信息表：create table books( book_id int primary key auto_increment, book_name varchar(50) not null, book_author varchar(20) not null, book_price decimal(10,2) not null, book_stock int not null, book_desc varchar(200));-- 添加图书信息insert into books(book_name,book_author,book_price,book_stock,book_desc)values(&#x27;Java程序设计&#x27;,&#x27;亮亮&#x27;,38.80,12,&#x27;亮亮老师带你学Java&#x27;);insert into books(book_name,book_author,book_price,book_stock,book_desc)values(&#x27;Java王者之路&#x27;,&#x27;威哥&#x27;,44.40,9,&#x27;千锋威哥，Java王者领路人&#x27;);-- 创建学生信息表create table students( stu_num char(4) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null);-- 添加学生信息insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1001&#x27;,&#x27;张三&#x27;,&#x27;男&#x27;,20);insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1002&#x27;,&#x27;李四&#x27;,&#x27;女&#x27;,20);insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1003&#x27;,&#x27;王五&#x27;,&#x27;男&#x27;,20); 业务分析 哪个学生借哪本书，借了多少本？ 操作： 保存借书记录 修改图书库存 条件： 判断学生是否存在？ 判断图书是否存在、库存是否充足？ 创建借书记录表 1234567891011-- 借书记录表：create table records( rid int primary key auto_increment, snum char(4) not null, bid int not null, borrow_num int not null, is_return int not null, -- 0表示为归还 1 表示已经归还 borrow_date date not null, constraint FK_RECORDS_STUDENTS foreign key(snum) references students(stu_num), constraint FK_RECORDS_BOOKS foreign key(bid) REFERENCES books(book_id)); 9.8.2 创建存储过程实现借书业务1234567891011121314151617181920212223242526272829303132333435363738394041424344454647-- 实现借书业务：-- 参数1： a 输入参数 学号-- 参数2： b 输入参数 图书编号-- 参数3： m 输入参数 借书的数量-- 参数4： state 输出参数 借书的状态（1 借书成功，2 学号不存在，3 图书不存在， 4 库存不足）create procedure proc_borrow_book(IN a char(4),IN b int, IN m int,OUT state int)begin declare stu_count int default 0; declare book_count int default 0; declare stock int default 0; -- 判断学号是否存在：根据参数 a 到学生信息表查询是否有stu_num=a的记录 select count(stu_num) INTO stu_count from students where stu_num=a; if stu_count&gt;0 then -- 学号存在 -- 判断图书ID是否存在：根据参数b 查询图书记录总数 select count(book_id) INTO book_count from books where book_id=b; if book_count &gt;0 then -- 图书存在 -- 判断图书库存是否充足：查询当前图书库存，然后和参数m进行比较 select book_stock INTO stock from books where book_id=b; if stock &gt;= m then -- 执行借书 -- 操作1：在借书记录表中添加记录 insert into records(snum,bid,borrow_num,is_return,borrow_date) values(a,b,m,0,sysdate()); -- 操作2：修改图书库存 update books set book_stock=stock-m where book_id=b; -- 借书成功 set state=1; else -- 库存不足 set state=4; end if; else -- 图书不存在 set state = 3; end if; else -- 不存在 set state = 2; end if;end;-- 调用存储过程借书set @state=0;call proc_borrow_book(&#x27;1001&#x27;,1,2,@state);select @state from dual; 9.8.3 创建存储过程实现还书业务期待… 9.9 游标 问题：如果我们要创建一个存储 过程，需要返回查询语句查询到的多条数据，该如何实现呢？ 9.1.1 游标的概念游标可以用来依次取出查询结果集中的每一条数据——逐条读取查询结果集中的记录 9.1.2 游标的使用步骤1、声明游标 声明游标语法： 1DECLARE cursor_nanme CURSOR FOR select_statement; 实例 1declare mycursor cursor for select book_name,book_author,book_price from books; 2、打开游标 语法 1open mycursor; 3、使用游标 使用游标：提取游标当前指向的记录（提取之后，游标自动下移） 1FETCH mycursor INTO bname,bauthor,bprice; 4、关闭游标 1CLOSE mycursor; 9.1.3 游标使用案例123456789101112131415161718192021222324252627282930313233-- 游标使用案例create procedure proc_test2(OUT result varchar(200))begin declare bname varchar(20); declare bauthor varchar(20); declare bprice decimal(10,2); declare num int; declare i int; declare str varchar(50); -- 此查询语句执行之后返回的是一个结果集（多条记录），使用游标可以来遍历查询结果集 declare mycursor cursor for select book_name,book_author,book_price from books; select count(1) INTO num from books; -- 打开游标 open mycursor; -- 使用游标要结合循环语句 set i=0; while i&lt;num do -- 使用游标：提取游标当前指向的记录（提取之后，游标自动下移） FETCH mycursor INTO bname,bauthor,bprice; set i=i+1; -- set str=concat_ws(&#x27;~&#x27;,bname,bauthor,bprice); select concat_ws(&#x27;~&#x27;,bname,bauthor,bprice) INTO str; set result = concat_ws(&#x27;,&#x27;,result,str); end while; -- 关闭游标 close mycursor;end;-- 案例测试set @r = &#x27;&#x27;;call proc_test2(@r);select @r from dual; 十、触发器10.1 触发器的介绍触发器，就是一种特殊的存储过程。触发器和存储过程一样是一个能够完成特定功能、存储在数据库服务器上的SQL片段，但是触发器无需调用，当对数据表中的数据执行DML操作时自动触发这个SQL片段的执行，无需手动调用。 在MySQL,只有执行insert\\delete\\update操作才能触发触发器的执行。 10.2 触发器的使用10.2.1 案例说明1234567891011121314-- 学生信息表create table students( stu_num char(4) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null);-- 学生信息操作日志表create table stulogs( id int primary key auto_increment, time TIMESTAMP, log_text varchar(200)); 1234-- 当向students表中添加学生信息时，同时要在 stulogs表中添加一条操作日志insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1004&#x27;,&#x27;夏利&#x27;,&#x27;女&#x27;,20);-- 手动进行记录日志insert into stulogs(time,log_text) values(now(),&#x27;添加1004学生信息&#x27;); 案例：当向学生信息表添加、删除、修改学生信息时，使用触发器自定进行日志记录 10.2.2 创建触发器语法 123456create trigger tri_name&lt;before|after&gt; -- 定义触发时机&lt;insert|delete|update&gt; -- 定义DML类型ON &lt;table_name&gt;for each row -- 声明为行级触发器（只要操作一条记录就触发触发器执行一次）sql_statement -- 触发器操作 12345-- 创建触发器：当学生信息表发生添加操作时，则向日志信息表中记录一条日志create trigger tri_test1after insert on studentsfor each rowinsert into stulogs(time,log_text) values(now(), concat(&#x27;添加&#x27;,NEW.stu_num,&#x27;学生信息&#x27;)); 10.2.3 查看触发器1show triggers; 10.2.3 测试触发器 我们创建的触发器是在students表发生insert操作时触发，我们只需执行学生信息的添加操作 123456-- 测试1：添加一个学生信息，触发器执行了一次insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1005&#x27;,&#x27;小明&#x27;,&#x27;男&#x27;,20);-- 测试2：一条SQL指令添加了2条学生信息，触发器就执行了2次insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1006&#x27;,&#x27;小刚&#x27;,&#x27;男&#x27;,20),(&#x27;1007&#x27;,&#x27;李磊&#x27;,&#x27;男&#x27;,20); 10.2.4 删除触发器1drop trigger tri_test1; 10.3 NEW与OLD 触发器用于监听对数据表中数据的insert、delete、update操作，在触发器中通常处理一些DML的关联操作；我们可以使用NEW和OLD关键字在触发器中获取触发这个触发器的DML操作的数据 NEW : 在触发器中用于获取insert操作添加的数据、update操作修改后的记录 OLD：在触发器中用于获取delete操作删除前的数据、update操作修改前的数据 10.3.1 NEW insert操作中：NEW表示添加的新记录 1234create trigger tri_test1after insert on studentsfor each rowinsert into stulogs(time,log_text) values(now(), concat(&#x27;添加&#x27;,NEW.stu_num,&#x27;学生信息&#x27;)); update操作中：NEW 表示修改后的数据 1234-- 创建触发器 : 在监听update操作的触发器中，可以使用NEW获取修改后的数据create trigger tri_test2after update on students for each rowinsert into stulogs(time,log_text) values(now(), concat(&#x27;修改学生信息为：&#x27;,NEW.stu_num,NEW.stu_name)); 10.3.2 OLD delete操作中：OLD表示删除的记录 123create trigger tri_test3after delete on students for each rowinsert into stulogs(time,log_text) values(now(), concat(&#x27;删除&#x27;,OLD.stu_num,&#x27;学生信息&#x27;)); update操作中：OLD表示修改前的记录 123create trigger tri_test2after update on students for each rowinsert into stulogs(time,log_text) values(now(), concat(&#x27;将学生姓名从【&#x27;,OLD.stu_name,&#x27;】修改为【&#x27;,NEW.stu_name,&#x27;】&#x27;)); 10.4 触发器使用总结10.4.1 优点 触发器是自动执行的，当对触发器相关的表执行响应的DML操作时立即执行； 触发器可以实现表中的数据的级联操作（关联操作），有利于保证数据的完整性； 触发器可以对DML操作的数据进行更为复杂的合法性校验 10.4.2 缺点 使用触发器实现的业务逻辑如果出现问题将难以定位，后期维护困难； 大量使用触发器容易导致代码结构杂乱，增加了程序的复杂性； 当触发器操作的数据量比较大时，执行效率会大大降低。 10.4.3 使用建议 在互联网项目中，应避免适应触发器； 对于并发量不大的项目可以选择使用存储过程，但是在互联网引用中不提倡使用存储过程（原因：存储过程时将实现业务的逻辑交给数据库处理，一则增减了数据库的负载，二则不利于数据库的迁移） 十一、视图11.1 视图的概念视图，就是由数据库中一张表或者多张表根据特定的条件查询出得数据构造成得虚拟表 11.2 视图的作用 安全性：如果我们直接将数据表授权给用户操作，那么用户可以CRUD数据表中所有数据，加入我们想要对数据表中的部分数据进行保护，可以将公开的数据生成视图，授权用户访问视图；用户通过查询视图可以获取数据表中公开的数据，从而达到将数据表中的部分数据对用户隐藏。 简单性：如果我们需要查询的数据来源于多张数据表，可以使用多表连接查询来实现；我们通过视图将这些连表查询的结果对用户开放，用户则可以直接通过查询视图获取多表数据，操作更便捷。 11.3 创建视图11.3.1 语法123create view &lt;view_name&gt;ASselect_statement 11.3.2 实例 实例1： 1234567-- 创建视图实例1：将学生表中性别为男的学生生成一个视图create view view_test1ASselect * from students where stu_gender=&#x27;男&#x27;;-- 查询视图select * from view_test1; 示例2： 123456789-- 创建视图示例2：查询学生借书的信息（学生名、图书名、借书数量）create view view_test2ASselect s.stu_name,b.book_name,borrow_numfrom books b inner join records r inner join students son b.book_id=r.bid and r.snum=s.stu_num;-- 查询视图select * from view_test2; 11.4 视图数据的特性 视图是虚拟表，查询视图的数据是来源于数据表的。当对视图进行操作时，对原数据表中的数据是否由影响呢？ 查询操作：如果在数据表中添加了新的数据，而且这个数据满足创建视图时查询语句的条件，通过查询视图也可以查询出新增的数据；当删除原表中满足查询条件的数据时，也会从视图中删除。 新增数据：如果在视图中添加数据，数据会被添加到原数据表 删除数据：如果从视图删除数据，数据也将从原表中删除 修改操作：如果通过修改数据，则也将修改原数据表中的数据 视图的使用建议: 对复杂查询简化操作，并且不会对数据进行修改的情况下可以使用视图。 11.5 查询视图结构12-- 查询视图结构desc view_test2; 11.6 修改视图123456789-- 方式1create OR REPLACE view view_test1ASselect * from students where stu_gender=&#x27;女&#x27;;-- 方式2alter view view_test1ASselect * from students where stu_gender=&#x27;男&#x27;; 11.7 删除视图 删除数据表时会同时删除数据表中的数据，删除视图时不会影响原数据表中的数据 12-- 删除视图drop view view_test1; 十二、索引 数据库是用来存储数据，在互联网应用中数据库中存储的数据可能会很多(大数据)，数据表中数据的查询速度会随着数据量的增长逐渐变慢，从而导致响应用户请求的速度变慢——用户体验差，我们如何提高数据库的查询效率呢？ 12.1 索引的介绍索引，就是用来提高数据表中数据的查询效率的。 索引，就是将数据表中某一列&#x2F;某几列的值取出来构造成便于查找的结构进行存储，生成数据表的目录 当我们进行数据查询的时候，则先在目录中进行查找得到对应的数据的地址，然后再到数据表中根据地址快速的获取数据记录，避免全表扫描。 12.2 索引的分类MySQL中的索引，根据创建索引的列的不同，可以分为： 主键索引：在数据表的主键字段创建的索引，这个字段必须被primary key修饰，每张表只能有一个主键 唯一索引：在数据表中的唯一列创建的索引(unique)，此列的所有值只能出现一次，可以为NULL 普通索引：在普通字段上创建的索引，没有唯一性的限制 组合索引：两个及以上字段联合起来创建的索引 说明: 在创建数据表时，将字段声明为主键（添加主键约束），会自动在主键字段创建主键索引； 在创建数据表时，将字段声明为唯一键（添加唯一约束），会自动在唯一字段创建唯一索引； 12.3 创建索引12.3.1 唯一索引123-- 创建唯一索引: 创建唯一索引的列的值不能重复-- create unique index &lt;index_name&gt; on 表名(列名);create unique index index_test1 on tb_testindex(tid); 12.3.2 普通索引123-- 创建普通索引: 不要求创建索引的列的值的唯一性-- create index &lt;index_name&gt; on 表名(列名);create index index_test2 on tb_testindex(name); 12.3.3 组合索引123-- 创建组合索引-- create index &lt;index_name&gt; on 表名(列名1,列名2...);create index index_test3 on tb_testindex(tid,name); 12.3.4 全文索引 MySQL 5.6 版本新增的索引，可以通过此索引进行全文检索操作，因为MySQL全文检索不支持中文，因此这个全文索引不被开发者关注，在应用开发中通常是通过搜索引擎（数据库中间件）实现全文检索 1create fulltext index &lt;index_name&gt; on 表名(字段名); 12.4 索引使用 索引创建完成之后无需调用，当根据创建索引的列进行数据查询的时候，会自动使用索引； 组合索引需要根据创建索引的所有字段进行查询时触发。 在 命令行窗口中可以查看查询语句的查询规划： 1explain select * from tb_testindex where tid=250000\\G; 12.5 查看索引12-- 命令行show create table tb_testindex\\G; 12345-- 查询数据表的索引show indexes from tb_testindex;-- 查询索引show keys from tb_testindex; 12.6 删除索引123-- 删除索引：索引是建立在表的字段上的，不同的表中可能会出现相同名称的索引-- 因此删除索引时需要指定表名drop index index_test3 on tb_testindex; 12.7 索引的使用总结12.7.1 优点 索引大大降低了数据库服务器在执行查询操作时扫描的数据，提高查询效率 索引可以避免服务器排序、将随机IO编程顺序IO 12.7.2 缺点 索引是根据数据表列的创建的，当数据表中数据发生DML操作时，索引页需要更新； 索引文件也会占用磁盘空间； 12.7.3 注意事项 数据表中数据不多时，全表扫面可能更快吗，不要使用索引； 数据量大但是DML操作很频繁时，不建议使用索引； 不要在数据重复读高的列上创建索引（性别）； 创建索引之后，要注意查询SQL语句的编写，避免索引失效。 十三、数据库事务13.1 数据库事务介绍 我们把完成特定的业务的多个数据库DML操作步骤称之为一个事务 事务，就是完成同一个业务的多个DML操作 123456789-- 借书业务-- 操作1：在借书记录表中添加记录insert into records(snum,bid,borrow_num,is_return,borrow_date) values(&#x27;1001&#x27;,1,1,0,sysdate());-- 操作2：修改图书库存update books set book_stock=book_stock-1 where book_id=1;-- 转账业务：张三给李四转账1000-- 操作1：李四的帐号+1000-- 操作2：张三的账户-1000 13.2 数据库事务特性 ACID特性，高频面试题 原子性（Atomicity）：一个事务中的多个DML操作，要么同时执行成功，要么同时执行失败 一致性（Consistency）：事务执行之前和事务执行之后，数据库中的数据是一致的，完整性和一致性不能被破坏 隔离性（Isolation）：数据库允许多个事务同时执行（张三借Java书的同时允许李四借Java书），多个必行的事务之间不能相互影响 持久性（Durability）：事务完整之后，对数据库的操作是永久的 13.3 MySQL事务管理13.3.1 自动提交 在MySQL中，默认DML指令的执行时自动提交的，当我们执行一个DML指令之后，自动同步到数据库中 13.3.2 事务管理 开启事务，就是关闭自动提交 在开始事务第一个操作之前，执行start transaction开启事务 依次执行事务中的每个DML操作 如果在执行的过程中的任何位置出现异常，则执行rollback回滚事务 如果事务中所有的DML操作都执行成功，则在最后执行commit提交事务 1234567891011121314151617-- 借书业务-- 【开启事务】（关闭自动提交---手动提交）start transaction;-- 操作1：在借书记录表中添加记录insert into records(snum,bid,borrow_num,is_return,borrow_date) values(&#x27;1007&#x27;,4,2,0,sysdate());-- select aaa;-- 【事务回滚】（清除连接缓存中的操作,撤销当前事务已经执行的操作）-- rollback;-- 操作2：修改图书库存update books set book_stock=book_stock-2 where book_id=4;-- 【提交事务】（将连接缓存中的操作写入数据文件）commit; 13.4 事务隔离级别 数据库允许多个事务并行，多个事务之间是隔离的、相互独立的；如果事务之间不相互隔离并且操作同一数据时，可能会导致数据的一致性被破坏。 MySQL数据库事务隔离级别： 13.4.1 读未提交（read uncommitted）T2可以读取T1执行但未提交的数据；可能会导致出现脏读 脏读，一个事务读取到了另一个事务中未提交的数据 13.4.2 读已提交（read committed）T2只能读取T1已经提交的数据；避免了脏读，但可能会导致不可重复度（虚读） 不可重复度（虚读）: 在同一个事务中，两次查询操作读取到数据不一致 例如：T2进行第一次查询之后在第二次查询之前，T1修改并提交了数据，T2进行第二次查询时读取到的数据和第一次查询读取到数据不一致。 13.4.3 可重复读（repeatable read）T2执行第一次查询之后，在事务结束之前其他事务不能修改对应的数据；避免了不可重复读(虚读)，但可能会导致幻读 幻读，T2对数据表中的数据进行修改然后查询，在查询之前T1向数据表中新增了一条数据，就导致T2以为修改了所有数据，但却查询出了与修改不一致的数据（T1事务新增的数据） 13.4.4 串行化(serializable)同时只允许一个事务对数据表进行操作；避免了脏读、虚读、幻读问题 隔离级别 脏读 不可重复读(虚读) 幻读 read uncommitted √ √ √ read committed × √ √ repeatable read × × √ serializable × × × 13.4.5 设置数据库事务隔离级别 我们可以通过设置数据库默认的事务隔离级别来控制事务之间的隔离性； 也可以通过客户端与数据库连接设置来设置事务间的隔离性（在应用程序中设置–Spring）； MySQL数据库默认的隔离级别为可重复读 查看MySQL数据库默认的隔离级别 123456-- 在MySQL8.0.3 之前select @@tx_isolation;-- 在MySQL8.0.3 之后select @@transaction_isolation; 设置MySQL默认隔离级别 1set session transaction isolation level &lt;read committed&gt;; 十四、数据库设计 MySQL数据库作为数据存储的介质为应用系统提供数据存储的服务，我们如何设计出合理的数据库、数据表以满足应用系统的数据存储需求呢？ 车库：是用来存放车辆的，车库都需要划分车位，如果不划分车位，车子杂乱无章的存放可能会导致车辆堵塞，同时也可能造成场地的浪费——有限的场地能够停放最多的车辆，同时方便每一辆车的出入 数据库，是用来存放数据的，我们需要设计合理的数据表——能够完成数据的存储，同时能够方便的提取应用系统所需的数据 14.1 数据库设计流程 数据库是为应用系统服务的，数据库存储什么样的数据也是由应用系统来决定的。 当我们进行应用系统开发时，我们首先要明确应用系统的功能需求——软件系统的需求分析 根据应用系统的功能，分析数据实体(实体，就是要存储的数据对象) 电商系统：商品、用户、订单…. 教务管理系统：学生、课程、成绩… 提取实体的数据项（数据项，就是实体的属性） 商品(商品名称、商品图片、商品描述…) 用户(姓名、登录名、登录密码…) 根据数据库设计三范式规范视图的数据项 检查实体的数据项是否满足数据库设计三范式 如果实体的数据项不满足三范式，可能会导致数据的冗余，从而引起数据维护困难、破坏数据一致性等问题 绘制E-R图 （实体关系图，直观的展示实体与实体之间的关系） 数据库建模 三线图进行数据表设计 PowerDesigner PDMan 建库建表 编写SQL指令创建数据库、数据表 添加测试数据，SQL测试 14.2 数据库设计案例 学校图书馆图书管理系统（借书） 14.2.1 数据实体 学生 类别 图书 借书记录 管理员 14.2.2 提取数据项 学生（学号、姓名、性别、年龄、院系编号） 院系（院系编号、院系名称、院系说明…） 类别（类别ID，类别名称，类别描述） 图书（图书ID，图书名称，图书作者，图书封面，图书价格，图书库存…） 借书记录（记录ID，学号，图书编号，数量，是否归还，借书日期，还书日期） 管理员（管理员ID，登录名，登录密码，员工编号） 员工（员工编号，员工姓名，手机，qq，邮箱） 14.2.3 数据库设计三范式第一范式：要求数据表中的字段（列）不可再分 以下表不满足第一范式（在数据库中创建不出不满足第一范式的表） 将细分的列作为单独的一列： 第二范式：不存在非关键字段对关键字段的部分依赖 以下表不满足第二范式 将每个关键字段列出来\\关键字段的组合也列出来，依次检查每个非关键字段 第三范式：不存在非关键字段之间的传递依赖 以下数据表不满足第三范式 将关键字段和被依赖的非关键字段分别作为主键，依次检查所有的非关键字段的依赖关系 14.2.4 数据库建模（E-R图） E-R (Entity-Relationship) 实体关系图，用于直观的体现实体与实体之间的关联关系（一对一、一对多、多对一、多对多） E-R图基本图例 E-R图示例 三线图 统一数据实体的表结构 每个实体创建一张数据表 多对多关联：需额外常见一个数据表维护关系，关系表分别创建外键与两张表关联 一对多、多对一关联：在多的一端添加外键与一的一端的主键建立主外键约束 一对一关联：在任意一端创建外键与另一端建立主外键关联，并且将外键设置为unique 14.2.5 数据库建模（PD） E-R图实际上就是数据模建模的一部分： E-R 图 数据表设计 建库建表 PowerDesigner建模工具 导出数据表 PDMan建模工具 下载并安装PowerDesigner建模工具 PowerDesigner使用 概念数据模型（选择workspace–右键new–Conceptual Data Model），相当于E-R 逻辑数据模型（打开概念数据模型–tools–Generate Logical Data Model）,体现了实体的主外键关联 物理数据模型（打开逻辑数据模型–tools–Generate Physical Data Mode—选择数据库类型及版本） 可以对物理数据模型进行微调 可以通过物理数据模型生成建库建表的SQL语句（在物理数据模型的窗口中—-Database工具条—Generate Database–生成SQL文件） 通过数据库的管理工具执行SQL文件就可以完成数据表的创建 面向对象模型（打开概念数据模型&#x2F;逻辑数据模型&#x2F;物理数据模型—tools–Generate Object-Orentited Model） 可以根据语言设置，生成实体类（Java） 如果想要借助于PD建模工具生成Java代码，创建概念的模型时实体名、属性名都要符合Java程序的命名规范。 在企业项目开发，我们通常是不会使用建模工具来生成数据表、实体类的，因为生成的代码规范不合乎我们的代码需求 14.2.6 数据库建模（PDMan） 下载安装PDMan 创建项目——在项目中创建数据表 在项目中生成关系图","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/categories/JavaWeb/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"day01-JavaWeb","slug":"day01-JavaWeb","date":"2022-09-03T15:03:40.000Z","updated":"2022-09-12T02:00:33.533Z","comments":true,"path":"2022/09/03/day01-JavaWeb/","link":"","permalink":"http://example.com/2022/09/03/day01-JavaWeb/","excerpt":"","text":"一、Java web是什么？1.1 Java web概念 Java web指的是使用Java语言进行web互联网领域项目开发的技术栈——进行web项目开发所需的技术的集合： web前端——在浏览器中用户可以看到的网页 web后端——为前端提供数据的程序 1.2 Web项目 Java语言是可以进行多种类型的项目的开发 Java ME 嵌入式应用程序 （功能手机系统内置应用——俄罗斯方块、贪吃蛇） Java SE 窗体应用程序（下载—安装—双击打开） Android SDK 移动应用开发 HarmonyOS SDK 移动应用开发 Java EE 企业级项目开发（web项目） web项目 - 使用浏览器访问的软件系统 二、Java web学什么？2.1 web项目的结构 2.2 Java web技术体系 1.Java语言基础 Java基本语法：标识符、关键字、运算符、表达式、流程控制、数据类型 Java OOP： 类、属性、方法、对象，抽象继承封装多态 封装类：日期、Math、String、封装类 集合：List、Set、Iterator、Map JavaSE高级：IO、线程、网络 2.数据库 MySQL MySQL下载、安装、配置 SQL 结构化查询语言 添加、查询、修改、 删除 高级使用：存储过程、索引 数据库设计&#x2F;建模 数据库设计案例 3.数据库编程 JDBC 数据库编程介绍 JDBC步骤及实现 JDBCUtil工具类封装 DAO与DTO 4.web前端 网页设计 HTML 超文本标记语言 CSS 层叠样式表 JavaScript 脚本语言 AJAX 异步交互 BootStrap 样式框架 jQuery JS框架 5.Servlet&#x2F;JSP 一种可以将网页数据提交到Java程序，并且将Java程序的数据显示到网页的技术 Tomcat、HTTP Servlet、JSP","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/categories/JavaWeb/"}],"tags":[{"name":"what is javaweb","slug":"what-is-javaweb","permalink":"http://example.com/tags/what-is-javaweb/"}]},{"title":"Hexo base instructions","slug":"Hexo-base-instructions","date":"2022-09-03T14:49:36.000Z","updated":"2022-09-12T01:58:14.005Z","comments":true,"path":"2022/09/03/Hexo-base-instructions/","link":"","permalink":"http://example.com/2022/09/03/Hexo-base-instructions/","excerpt":"","text":"hexo 基础使用指令1，生成新的文章代码： 1hexo new &quot;文章名&quot; （代码中标点符号都为英文）文件会生成在source&#x2F;posts之下 2，本地预览指令： 1hexo s 3，上传指令： 123先 hexo g 再 hexo d或hexo g -d （这两个指令执行之后，网页就会自动更新） 4，新建页面 1hexo new page &quot;页面名&quot;","categories":[{"name":"hexo指令","slug":"hexo指令","permalink":"http://example.com/categories/hexo%E6%8C%87%E4%BB%A4/"}],"tags":[{"name":"hexo基础指令使用","slug":"hexo基础指令使用","permalink":"http://example.com/tags/hexo%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4%E4%BD%BF%E7%94%A8/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-09-03T02:44:45.202Z","updated":"2022-09-12T02:00:14.426Z","comments":true,"path":"2022/09/03/hello-world/","link":"","permalink":"http://example.com/2022/09/03/hello-world/","excerpt":"","text":"First,my name is bitezhang,you can call me 杰哥. Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"HelloWorld","slug":"HelloWorld","permalink":"http://example.com/categories/HelloWorld/"}],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/tags/Hello-World/"}]}],"categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://example.com/categories/JavaWeb/"},{"name":"hexo指令","slug":"hexo指令","permalink":"http://example.com/categories/hexo%E6%8C%87%E4%BB%A4/"},{"name":"HelloWorld","slug":"HelloWorld","permalink":"http://example.com/categories/HelloWorld/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"what is javaweb","slug":"what-is-javaweb","permalink":"http://example.com/tags/what-is-javaweb/"},{"name":"hexo基础指令使用","slug":"hexo基础指令使用","permalink":"http://example.com/tags/hexo%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4%E4%BD%BF%E7%94%A8/"},{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/tags/Hello-World/"}]}