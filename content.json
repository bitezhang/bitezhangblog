{"meta":{"title":"比特张的博客","subtitle":"beiying","description":"个人学习博客","author":"bitezhang","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-10-01T10:57:30.508Z","updated":"2022-10-01T10:57:30.508Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"有什么想对我说的可以在下面留言。 背景图片和头像图片"},{"title":"所有分类","date":"2022-09-10T16:18:33.643Z","updated":"2022-09-10T16:18:33.643Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-09-10T16:19:24.645Z","updated":"2022-09-10T16:19:24.645Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-09-10T16:18:45.503Z","updated":"2022-09-10T16:18:45.503Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2022-09-11T11:59:40.103Z","updated":"2022-09-11T11:59:40.103Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2022-10-10T02:24:39.334Z","updated":"2022-10-10T02:24:39.334Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 &#123;% p center bold, 很抱歉，您访问的页面不存在 %&#125; &#123;% p center small, 可能是输入地址有误或该地址已被删除 %&#125; 加我微信:beiyingzd kiss kiss!"}],"posts":[{"title":"day03-JDBC","slug":"day03-JDBC","date":"2022-09-19T01:09:17.000Z","updated":"2022-10-05T07:05:19.987Z","comments":true,"path":"2022/09/19/day03-JDBC/","link":"","permalink":"http://example.com/2022/09/19/day03-JDBC/","excerpt":"","text":"Course：JDBC 数据库编程 一、JDBC介绍 JDBC (Java DataBase Contectivity) Java与数据库的连接——数据库编程 JDBC 是Java语言（JDK）为完成数据库的访问操作提供的一套统一的标准。 二、JDBC步骤 三、JDBC入门案例 JDBC 是用Java代码完成数据访问的规范 3.1 加载驱动3.1.1 下载驱动jar包 对应数据库匹配版本的驱动jar包 地址https://mvnrepository.com/ 搜索mysql 选择版本下载 MySQL数据库版本为5.x,驱动jar包建议使用5.1.47 MySQL数据库版本为8.x,驱动jar包建议使用8.0.x 3.1.2 将驱动jar文件添加到Java应用 在java应用中创建lib文件夹 将下载好的jar文件拷贝—粘贴到lin目录 将驱动jar文件设置为java库：选择lib&#x2F;驱动jar—右键—Add as Library.. —OK 3.1.3 注册驱动 通过反射机制，将驱动jar文件中提供的驱动类载入到JVM中 12//1.注册驱动（驱动jar包中的驱动类（Driver）的路径：com.mysql.cj.jdbc.Driver）Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); 3.2 创建连接12345678910//2.创建连接：通过数据库驱动管理器 DriverManager（java.sql.Driver）获取连接// JDBC JDK提供的数据库连接的规范 --- java.sql// java.sql.Connection接口 一个对象就表示一个数据库连接// url 数据库的统一资源定位器（定位数据库连接资源）// url参数// characterEncoding 设置编码// useSSL=true 使用SSL通信// useTimezone=true 设置客户端和服务端时区转换String url = &quot;jdbc:mysql://localhost:3306/db_test3&quot;;Connection connection = DriverManager.getConnection(url,&quot;root&quot;,&quot;@QFedu123&quot;); 3.3 编写SQL指令12//3.编写要执行的SQL指令:SQL指令中需要的参数可以通过字符串拼接的形式（会导致SQL注入）String sql = &quot;insert into books(book_id,book_name,book_author,book_price,book_stock,book_desc) values(&#x27;&quot;+id+&quot;&#x27;,&#x27;&quot;+name+&quot;&#x27;,&#x27;&quot;+author+&quot;&#x27;,&quot;+price+&quot;,&quot;+stock+&quot;,&#x27;&quot;+desc+&quot;&#x27;)&quot;; 3.4 加载SQL指令1234//4.加载SQL指令:获取SQL指令的加载器// java.sql.Statement 对象 可以理解为 SQL指令的“加载器”// java.sql.PreparedStatement 对象 SQL指令的“预编译加载器”Statement statement = connection.createStatement(); 3.5 执行SQL、获取结果123456//5.执行SQL获取执行结果// a. 如果SQL指令为DQL,则 ResultSet rs = statement.executeQuery(sql); rs中就是查询结果// b. 如果SQL指令为DML，则 int i = statement.executeUpdate(sql); i就表示DML操作影响的数据行数// 如果i&gt;0，表示DML操作是成功的；如果i=0表示DML操作对数据表中的数据没有影响int i = statement.executeUpdate(sql); 3.6 处理结果123456//6.处理结果（业务）// 添加操作：返回值i&gt;0表示添加成功，否则表示添加失败// 修改操作：返回值i&gt;0表示修改对数据有影响，如果i=0 表示对数据库没有影响// 删除操作：返回值i&gt;0表示删除对数据有影响，如果i=0 表示对数据库没有影响// 查询操作：从ResultSet rs中取出查询结果，封装到Java对象中System.out.println(i&gt;0?&quot;添加成功&quot;:&quot;添加失败&quot;); 3.7 关闭连接12345678910//7.关闭连接// 如果执行DML操作：需要关闭Statement和Connection// 如果执行DQL操作：需要关闭ResultSet、Statement和Connection// 关闭之前先判空、由大到大关闭if(statement != null &amp;&amp; !statement.isClosed())&#123; statement.close();&#125;if(connection !=null &amp;&amp; !connection.isClosed())&#123; connection.close();&#125; 四、JDBC增删查改操作实例 使用JDBC完成数据库的CRUD访问 4.1 insert操作1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestInsertBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; String name = &quot;Java进阶之路&quot;; String author = &quot;老王&quot;; double price = 22.22; int stock = 10; String desc = &quot;这本书很好&quot;; //1.注册驱动（驱动jar包中的驱动类（Driver）的路径：com.mysql.cj.jdbc.Driver） Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2.创建连接：通过数据库驱动管理器 DriverManager（java.sql.Driver）获取连接 String url = &quot;jdbc:mysql://localhost:3306/db_test3&quot;; Connection connection = DriverManager.getConnection(url,&quot;root&quot;,&quot;@QFedu123&quot;); //3.编写要执行的SQL指令 String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(&#x27;&quot;+name+&quot;&#x27;,&#x27;&quot;+author+&quot;&#x27;,&quot;+price+&quot;,&quot;+stock+&quot;,&#x27;&quot;+desc+&quot;&#x27;)&quot;; //4.加载SQL指令:获取SQL指令的加载器 Statement statement = connection.createStatement(); //5.执行SQL获取执行结果 int i = statement.executeUpdate(sql); //6.处理结果（业务） System.out.println(i&gt;0?&quot;添加成功&quot;:&quot;添加失败&quot;); //7.关闭连接 if(statement != null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection !=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 4.2 delete操作1234567891011121314151617181920212223242526272829303132/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestDeleteBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; int bid = 1012; //使用JDBC，根据图书编号删除图书信息 //1.注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2.创建连接 String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); //3.编写SQL String sql = &quot;delete from books where book_id=&quot;+bid; //4.获取SQL加载器 Statement statement = connection.createStatement(); //5.执行SQL int i = statement.executeUpdate(sql); //6.处理结果 System.out.println(i&gt;0?&quot;删除成功&quot;:&quot;删除失败&quot;); //7.关闭连接 if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 4.3 update操作123456789101112131415161718192021222324252627282930313233343536373839package com.qfedu.jdbc.les1;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestUpdateBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; // 根据数据记录的主键 修改其他的字段 // 根据图书ID，修改图书名称、作者、价格、库存、描述 int id = 1011; String name = &quot;Java进阶之路&quot;; String author = &quot;亮亮&quot;; double price = 36.80; int stock = 8; String desc = &quot;这本书非常好&quot;; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); String sql = &quot;update books set book_name=&#x27;&quot;+name+&quot;&#x27;,book_author=&#x27;&quot;+author+&quot;&#x27;,book_price=&quot;+price+&quot;,book_stock=&quot;+stock +&quot;,book_desc=&#x27;&quot;+desc+&quot;&#x27; where book_id=&quot;+id; Statement statement = connection.createStatement(); int i = statement.executeUpdate(sql); System.out.println(i&gt;0?&quot;修改成功&quot;:&quot;修改失败&quot;); if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 4.4 select操作（一条结果） 结果集处理 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.qfedu.jdbc.les1;import java.sql.*;/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestSelectBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //根据图书ID，查询一本图书信息 int bid = 1011; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=&quot;+bid; Statement statement = connection.createStatement(); //通过executeQuery方法执行查询语句，并且将查询的结果存放到一个ResultSet对象中（结果集） ResultSet rs = statement.executeQuery(sql); //处理结果：从rs中获取查询结果 if(rs.next())&#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); System.out.println(bookId+&quot;\\t&quot;+bookName+&quot;\\t&quot;+bookAuthor+&quot;\\t&quot;+bookPrice+&quot;\\t&quot;+bookStock+&quot;\\t&quot;+bookDesc); &#125; //关闭连接 结果集也需要关闭 if(rs!=null &amp;&amp; !rs.isClosed())&#123; rs.close(); &#125; if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 4.5 select操作（多条结果）123456789101112131415161718192021222324252627282930313233343536373839package com.qfedu.jdbc.les1;import java.sql.*;/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestSelectBooks &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //查询所有图书信息 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books&quot;; Statement statement = connection.createStatement(); ResultSet rs = statement.executeQuery(sql); while(rs.next())&#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); System.out.println(bookId+&quot;\\t&quot;+bookName+&quot;\\t&quot;+bookAuthor+&quot;\\t&quot;+bookPrice+&quot;\\t&quot;+bookStock+&quot;\\t&quot;+bookDesc); &#125; if(rs!=null &amp;&amp; !rs.isClosed())&#123; rs.close(); &#125; if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 五、JDBC的核心类与接口 java.sql.DriverManager类 驱动管理器 java.sql.Connection接口 数据库连接 java.sql.Statement接口 SQL指令的“加载&#x2F;执行器” java.sql.ResultSet接口 结果集 5.1 DriverManager类 注册驱动 创建数据库连接 注册驱动 12345// 在Driver类中的静态初始化块中，注册驱动：DriverManager.registerDriver(new Driver());Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);// 在我们的应用程序中手动注册驱动的代码也可以省略 【Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);】// 如果我们没有手动注册驱动，驱动管理器在获取连接的时候发现没有注册驱动则读取 驱动jar/META-INF/servicesjava.sql.Driver文件中配置的驱动类路径进行注册 获取连接 1234// url 数据库服务器的地址// username 数据库连接用户名// password 数据库连接密码Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); 5.2 Connection接口 Connection对象表示Java应用程序与数据库之间的连接 通过Connection接口对象，获取执行SQL语句的Statement对象 完成数据的事务管理 5.2.1 获取Statement对象 Statement接口: 编译执行静态SQL指令 1Statement statement = connection.createStatement(); PreparedStatement接口：继承了Statement接口，预编译动态SQL指令（解决SQL注入问题） 1PreparedStatement preparedStatement = connection.prepareStatement(sql); CallableStatement接口：继承了PreparedStatement接口，可以调用存储过程 1CallableStatement callableStatement = connection.prepareCall(sql); 5.2.2 事务管理12345678//开启事务（关闭事务自动提交）connection.setAutoCommit(false);//事务回滚connection.rollback();//提交事务connection.commit(); 5.3 Statement接口 用于编译、执行SQL指令的 12345// 执行DML操作的SQL指令int i = statement.executeUpdate(sql);// 执行DQL操作的SQL指令ResultSet rs = statement.executeQuery(sql); 5.4 ResultSet接口 ResultSet接口对象，表示查询操作返回的结果集，提供了便利的方法用于获取结果集中的数据 判断结果集中是否还有数据未取出 1234ResultSet rs = statement.executeQuery(select_statement);// 判断rs中是否还有数据rs.next(); 获取rs指向的结果集中某行的数据 1234567int id = rs.getInt(String columnLable); //获取rs指向的行的 列 数据（字段名）int id = rs.getInt(int columnIndex);rs.getString(&quot;&quot;); //获取String类型数据rs.getDouble(&quot;&quot;); //获取Double类型数据....rs.getDate(&quot;&quot;); //获取日期类型数据 六、SQL注入问题6.1 什么是SQL注入问题？ 在JDBC操作SQL指令编写过程中，如果SQL指令中需要数据，我们可以通过字符串拼接的形式将参数拼接到SQL指令中，如String sql = &quot;delete from books where book_id=&quot;+s;(s就是拼接到SQL中的变量) 使用字符串拼接变量的形式来设置SQL语句中的数据，可能会导致因变量值的改变引起SQL指令的原意发生改变，这就被称为SQL注入。SQL注入问题是需要避免的。 例如： 如果s的值为1，SQL指令 ： delete from books where book_id&#x3D;1 如果s的值为1 or 1=1，SQL指令：delete from books where book_id&#x3D;1 or 1&#x3D;1 6.2 如何解决SQL注入问题？ 使用PreparedStatement进行SQL预编译解决SQL注入问题： 在编写SQL指令时，如果SQL指令中需要参数，一律使用?参数占位符 如果SQL指令中有?，在JDBC操作步骤中不再使用Statement，而是从Conection对象获取PreparedStatement对SQL指令进行预编译 PreparedStatement preparedStatement = connection.prepareStatement(sql); 预编译完成之后，通过PreparedStatement对象给预编译后的SQL指令的?复制 prepareadStatement.setInt(参数占位符序号,值); prepareadStatement.setString(参数占位符序号,值); SQL指令中的所有?完成赋值之后，通过PreparedStatement执行SQL执行SQL时不再加载SQL int i &#x3D; prepareadStatement.executeUpdate(); ResultSet rs &#x3D; preparedStatement.executeQuery(); 6.3 使用PreparedStatement预编译案例 删除操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.qfedu.jdbc.les1;import com.mysql.cj.jdbc.Driver;import java.sql.*;import java.util.Scanner;/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestDeleteBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入你要删除的图书的ID：&quot;); String s = scanner.nextLine(); int bid = Integer.parseInt(s); //1.注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2.创建连接 String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); //3.编写SQL:SQL指令中的参数使用?表示 String sql = &quot;delete from books where book_id=?&quot;; //4.如果SQL指令有参数占位符?,则从Connection获取PreparedStatement预编译SQL指令 // 预编译：在SQL指令中的参数赋值之前对SQL执行的语法结构进行编译 PreparedStatement preparedStatement = connection.prepareStatement(sql); // SQL指令预编译之后，给SQL中的?赋值 preparedStatement.setInt(1,bid); //5.执行SQL int i = preparedStatement.executeUpdate(); //6.处理结果 System.out.println(i&gt;0?&quot;删除成功&quot;:&quot;删除失败&quot;); //7.关闭连接 if(preparedStatement!=null &amp;&amp; !preparedStatement.isClosed())&#123; preparedStatement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 修改操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.qfedu.jdbc.les1;import java.sql.*;/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestInsertBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; String name = &quot;Java进阶之路&quot;; String author = &quot;老王&quot;; double price = 22.22; int stock = 10; String desc = &quot;这本书很好&quot;; //1.注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2.创建连接 String url = &quot;jdbc:mysql://localhost:3306/db_test3&quot;; Connection connection = DriverManager.getConnection(url,&quot;root&quot;,&quot;@QFedu123&quot;); //3.编写要执行的SQL指令:SQL指令中所需的参数一律使用? String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; //4.SQL中有? 使用PreparedStatement预编译SQL PreparedStatement preparedStatement = connection.prepareStatement(sql); // 给SQL指令中的?复制 preparedStatement.setString(1,name); preparedStatement.setString(2,author); preparedStatement.setDouble(3,price); preparedStatement.setInt(4,stock); preparedStatement.setString(5,desc); //5.执行SQL获取执行结果 int i = preparedStatement.executeUpdate(); //6.处理结果（业务） System.out.println(i&gt;0?&quot;添加成功&quot;:&quot;添加失败&quot;); //7.关闭连接 if(preparedStatement != null &amp;&amp; !preparedStatement.isClosed())&#123; preparedStatement.close(); &#125; if(connection !=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 练习1：修改操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.qfedu.jdbc.les1;import java.sql.*;/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestUpdateBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; // 根据数据记录的主键 修改其他的字段 // 根据图书ID，修改图书名称、作者、价格、库存、描述 int id = 1011; String name = &quot;Java进阶之路&quot;; String author = &quot;亮亮&quot;; double price = 36.80; int stock = 8; String desc = &quot;这本书非常好&quot;; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); //1. String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; //2. PreparedStatement preparedStatement = connection.prepareStatement(sql); //3. preparedStatement.setString(1,name); preparedStatement.setString(2,author); preparedStatement.setDouble(3,price); preparedStatement.setInt(4,stock); preparedStatement.setString(5,desc); //4. int i = preparedStatement.executeUpdate(); System.out.println(i&gt;0?&quot;修改成功&quot;:&quot;修改失败&quot;); //5. if(preparedStatement!=null &amp;&amp; !preparedStatement.isClosed())&#123; preparedStatement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 练习2：根据ID查询图书信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.qfedu.jdbc.les1;import java.sql.*;/** * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestSelectBook &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //根据图书ID，查询一本图书信息 int bid = 1013; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;@QFedu123&quot;); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1,bid); //通过executeQuery方法执行查询语句，并且将查询的结果存放到一个ResultSet对象中（结果集） ResultSet rs = preparedStatement.executeQuery(); //处理结果：从rs中获取查询结果 if(rs.next())&#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); System.out.println(bookId+&quot;\\t&quot;+bookName+&quot;\\t&quot;+bookAuthor+&quot;\\t&quot;+bookPrice+&quot;\\t&quot;+bookStock+&quot;\\t&quot;+bookDesc); &#125; //关闭连接 结果集也需要关闭 if(rs!=null &amp;&amp; !rs.isClosed())&#123; rs.close(); &#125; if(preparedStatement!=null &amp;&amp; !preparedStatement.isClosed())&#123; preparedStatement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;&#125; 备注 如果SQL指令中需要参数，则使用PreparedStatement进行SQL预编译，如果SQL指令中没有参数建议使用Statement（Statement执行效率要高于PreparedStatement）。 七、工具类封装7.1 代码的复用性在我们的应用程序中，如果需要完成相同的操作，相同的代码无需重复编写，我们只需一次编写多次调用即可！ JDBC数据库编程是由一个固定的步骤： 注册驱动 创建连接 编写SQL 获取Statement对象 执行SQL 处理结果 关闭连接 7.2 工具类封装 DBManager DBUtil JDBCUtil DBHelper 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.qfedu.jdbc.utils;import java.sql.*;/** * @Descript JDBC数据库连接帮助类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class DBHelper &#123; /*将创建数据库连接所需的字符串定义为常量，集中管理*/ private static final String DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;; private static final String URL = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; private static final String USERNAME = &quot;root&quot;; private static final String PASSWORD = &quot;@QFedu123&quot;; /** * 注册驱动只需执行一次，因此我们放在帮助类的静态初始化块中完成 */ static&#123; try &#123; Class.forName(DRIVER); &#125; catch (ClassNotFoundException e) &#123; System.out.println(&quot;-----------注册驱动失败&quot;); &#125; &#125; /** * 创建数据库连接对象 */ public static Connection getConnection()&#123; Connection connection = null; try &#123; connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); &#125; catch (SQLException e) &#123; System.out.println(&quot;-----------创建连接失败&quot;); &#125; return connection; &#125; /** * 关闭连接 * 多态的应用：使用Statement接口做参数，既可以传递Statement接口对象， * 也可以传递PreparedStatement接口对象 */ public static void close(Statement statement, Connection connection)&#123; close(null,statement,connection); &#125; /** * 关闭连接 */ public static void close(ResultSet resultSet,Statement statement, Connection connection)&#123; try &#123; if(resultSet!=null &amp;&amp; !resultSet.isClosed())&#123; resultSet.close(); &#125; if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; if(connection!=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; &#125;catch (Exception e)&#123; System.out.println(&quot;~~~~~关闭数据库连接失败&quot;); &#125; &#125;&#125; 八、DAO与DTO的封装 DAO Data Access Object 数据访问对象 DTO Data Transfer Object 数据传输对象（实体类） 用于传输DML操作参数及DQL的查询结果 8.1 CRUD方法的封装 面向对象的特征之一——封装 我们将能够完成某个CRUD操作的代码单独定义成一个方法，当需要完成此CRUD操作时调用这个方法即可; insert操作封装 delete操作封装 update操作封装 8.2 DTO实体类封装 问题：在封装CRUD方法时，对于查询操作而言，需要将查询到的数据库记录返回给调用者，但是一个查询方法只能返回一个值，而一条数据库记录有多个值，如何将一条数据库记录的多个值返回呢？ 处理：在Java程序中创建一个属性与数据库表匹配的类，通过此类的对象封装查询到的数据，我们把用于传递JDBC增删查改操作的数据的对象称之为数据传输对象——DTO(实体类：带有属性，其对象可以存放数据的类) 实体类创建规则： 1234567* 1.类中属性的个数和类型，与对应的数据表保持一致* 2.提供所有属性的get和set方法：Alt+Insert --- Getter And Setter --- 选择所有属性 --- OK* 3.提供全参构造器：Alt+Insert --- Constructor --- 选择所有属性 --- OK* 4.提供无参构造器：Alt+Insert --- Constructor --- SelectNone* 5.重写toString方法：Alt+Insert --- toString --- OK* 6.[暂略] 重写hashcode和equals* 7.[暂略]实现序列化Serializable接口 实体类实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.qfedu.jdbc.dto;import java.io.Serializable;/** * @Descript 存放图书信息的类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Book implements Serializable &#123; private int bookId; private String bookName; private String bookAuthor; private double bookPrice; private int bookStock; private String bookDesc; @Override public String toString() &#123; return &quot;Book&#123;&quot; + &quot;bookId=&quot; + bookId + &quot;, bookName=&#x27;&quot; + bookName + &#x27;\\&#x27;&#x27; + &quot;, bookAuthor=&#x27;&quot; + bookAuthor + &#x27;\\&#x27;&#x27; + &quot;, bookPrice=&quot; + bookPrice + &quot;, bookStock=&quot; + bookStock + &quot;, bookDesc=&#x27;&quot; + bookDesc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public Book() &#123; &#125; public Book(int bookId, String bookName, String bookAuthor, double bookPrice, int bookStock, String bookDesc) &#123; this.bookId = bookId; this.bookName = bookName; this.bookAuthor = bookAuthor; this.bookPrice = bookPrice; this.bookStock = bookStock; this.bookDesc = bookDesc; &#125; //get和set方法&#125; 使用实体类封装查询操作返回的结果： 1234567891011121314151617181920212223242526/*** 根据图书ID查询一条图书记录*/public Book queryBook(int bid) throws SQLException&#123; Book book = null; Connection connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1,bid); //通过executeQuery方法执行查询语句，并且将查询的结果存放到一个ResultSet对象中（结果集） ResultSet rs = preparedStatement.executeQuery(); //处理结果：从rs中获取查询结果 if(rs.next())&#123; int id = rs.getInt(&quot;book_id&quot;); String name = rs.getString(&quot;book_name&quot;); String author = rs.getString(&quot;book_author&quot;); double price = rs.getDouble(&quot;book_price&quot;); int stock = rs.getInt(&quot;book_stock&quot;); String desc = rs.getString(&quot;book_desc&quot;); //我们需要将查询到的一条数据库图书记录的6个值返回 book = new Book(id,name,author,price,stock,desc); &#125; //关闭连接 结果集也需要关闭 DBHelper.close(rs,preparedStatement,connection); return book;&#125; 8.3 实体类封装查询结果 查询的每条结果分别存放到一个DTO对象中，再将多个DTO对象存放到一个List集合中，返回这个List集合 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.qfedu.jdbc.les1;import com.qfedu.jdbc.dto.Book;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * @Description * @Author Java涛哥 @ 千锋教育 * @千锋Java微信公众号 Java架构栈 */public class TestSelectBooks &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; List&lt;Book&gt; list = new TestSelectBooks().listBooks(); for(Book b:list)&#123; System.out.println(b.getBookName()+&quot;\\t&quot;+b.getBookAuthor()); &#125; &#125; public List&lt;Book&gt; listBooks() throws SQLException&#123; List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); //查询所有图书信息 Connection connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books&quot;; Statement statement = connection.createStatement(); ResultSet rs = statement.executeQuery(sql); while(rs.next())&#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); Book book = new Book(bookId, bookName, bookAuthor, bookPrice, bookStock, bookDesc); bookList.add(book); &#125; DBHelper.close(rs,statement,connection); return bookList; &#125;&#125; 8.4 实体类传递添加、修改操作参数 在JDBC的添加、修改等方法中需要多个数据，我们可以通过实体类来进行参数传递 8.4.1 添加操作1234567891011121314151617public boolean insertBook(Book book) throws SQLException &#123; boolean flag = false; //调用工具类，获取数据库连接对象 Connection connection = DBHelper.getConnection(); String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,book.getBookName()); preparedStatement.setString(2,book.getBookAuthor()); preparedStatement.setDouble(3,book.getBookPrice()); preparedStatement.setInt(4,book.getBookStock()); preparedStatement.setString(5,book.getBookDesc()); int i = preparedStatement.executeUpdate(); flag = i&gt;0; //关闭连接 DBHelper.close(preparedStatement,connection); return flag;&#125; 8.4.2 修改操作12345678910111213141516public boolean updateBook(Book book) throws SQLException&#123; boolean flag = false; Connection connection = DBHelper.getConnection(); String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,book.getBookName()); preparedStatement.setString(2,book.getBookAuthor()); preparedStatement.setDouble(3,book.getBookPrice()); preparedStatement.setInt(4,book.getBookStock()); preparedStatement.setString(5,book.getBookDesc()); preparedStatement.setInt(6,book.getBookId()); int i = preparedStatement.executeUpdate(); flag = i&gt;0; DBHelper.close(preparedStatement,connection); return flag;&#125; 8.5 DAO类封装 DAO封装：将对数据库中同一张数据表的JDBC操作方法封装到同一个Java类中，这个类就是访问此数据表的数据访问对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import java.util.ArrayList;import java.util.List;/** * @Descript DAO Data Access Object 数据访问对象 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookDAO &#123; public boolean deleteBook(int bid) throws SQLException &#123; boolean flag = false; //使用JDBC，根据图书编号删除图书信息 //1.注册驱动 创建连接 Connection connection = DBHelper.getConnection(); //3.编写SQL String sql = &quot;delete from books where book_id=?&quot;; //4.如果SQL指令有参数占位符?,则从Connection获取PreparedStatement预编译SQL指令 // 预编译：在SQL指令中的参数赋值之前对SQL执行的语法结构进行编译 PreparedStatement preparedStatement = connection.prepareStatement(sql); // SQL指令预编译之后，给SQL中的?赋值 preparedStatement.setInt(1,bid); //5.执行SQL int i = preparedStatement.executeUpdate(); //6.处理结果 flag = i&gt;0; //7.关闭连接 DBHelper.close(preparedStatement,connection); return true; &#125; /** * 添加图书 * @return 如果添加成功返回true，如果添加失败则返回false * @throws SQLException */ public boolean insertBook(Book book) throws SQLException &#123; boolean flag = false; //调用工具类，获取数据库连接对象 Connection connection = DBHelper.getConnection(); String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,book.getBookName()); preparedStatement.setString(2,book.getBookAuthor()); preparedStatement.setDouble(3,book.getBookPrice()); preparedStatement.setInt(4,book.getBookStock()); preparedStatement.setString(5,book.getBookDesc()); int i = preparedStatement.executeUpdate(); // 如果i&gt;0，表示DML操作是成功的；如果i=0表示DML操作对数据表中的数据没有影响 flag = i&gt;0; //关闭连接 DBHelper.close(preparedStatement,connection); return flag; &#125; /** * 根据图书ID查询一条图书记录 */ public Book queryBook(int bid) throws SQLException&#123; Book book = null; Connection connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1,bid); //通过executeQuery方法执行查询语句，并且将查询的结果存放到一个ResultSet对象中（结果集） ResultSet rs = preparedStatement.executeQuery(); //处理结果：从rs中获取查询结果 if(rs.next())&#123; int id = rs.getInt(&quot;book_id&quot;); String name = rs.getString(&quot;book_name&quot;); String author = rs.getString(&quot;book_author&quot;); double price = rs.getDouble(&quot;book_price&quot;); int stock = rs.getInt(&quot;book_stock&quot;); String desc = rs.getString(&quot;book_desc&quot;); //我们需要将查询到的一条数据库图书记录的6个值返回 book = new Book(id,name,author,price,stock,desc); &#125; //关闭连接 结果集也需要关闭 DBHelper.close(rs,preparedStatement,connection); return book; &#125; public List&lt;Book&gt; listBooks() throws SQLException&#123; List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); //查询所有图书信息 Connection connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books&quot;; Statement statement = connection.createStatement(); ResultSet rs = statement.executeQuery(sql); while(rs.next())&#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); Book book = new Book(bookId, bookName, bookAuthor, bookPrice, bookStock, bookDesc); bookList.add(book); &#125; DBHelper.close(rs,statement,connection); return bookList; &#125; public boolean updateBook(Book book) throws SQLException&#123; boolean flag = false; Connection connection = DBHelper.getConnection(); String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,book.getBookName()); preparedStatement.setString(2,book.getBookAuthor()); preparedStatement.setDouble(3,book.getBookPrice()); preparedStatement.setInt(4,book.getBookStock()); preparedStatement.setString(5,book.getBookDesc()); preparedStatement.setInt(6,book.getBookId()); int i = preparedStatement.executeUpdate(); flag = i&gt;0; DBHelper.close(preparedStatement,connection); return flag; &#125;&#125; 8.6 DAO类代码优化 1.在应用程序开发中，如果方法中抛出异常且自己可以处理，则直接通过try&#x2F;catch进行捕获处理； 2.JDBC操作方法的连接需要放在finally中进行关闭； 3.将数据库连接Connection、Statement、ResultSet等需要关闭的数据库对象定义在try之前; 4.因为所有的JDBC操作都需要Conection、Statement对象，查询方法都需要ResultSet对象，因此在DAO中可以将这些对象定义成类的成员变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package com.qfedu.jdbc.dao;import com.qfedu.jdbc.dto.Book;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * @Descript DAO Data Access Object 数据访问对象 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookDAO &#123; private Connection connection; private Statement statement; private PreparedStatement preparedStatement; private ResultSet rs; public boolean deleteBook(int bid) &#123; boolean flag = false; try&#123; connection = DBHelper.getConnection(); String sql = &quot;delete from books where book_id=?&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1,bid); int i = preparedStatement.executeUpdate(); flag = i&gt;0; &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(preparedStatement,connection); &#125; return flag; &#125; public boolean insertBook(Book book) &#123; boolean flag = false; try&#123; //调用工具类，获取数据库连接对象 connection = DBHelper.getConnection(); String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,book.getBookName()); preparedStatement.setString(2,book.getBookAuthor()); preparedStatement.setDouble(3,book.getBookPrice()); preparedStatement.setInt(4,book.getBookStock()); preparedStatement.setString(5,book.getBookDesc()); int i = preparedStatement.executeUpdate(); // 如果i&gt;0，表示DML操作是成功的；如果i=0表示DML操作对数据表中的数据没有影响 flag = i&gt;0; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(preparedStatement,connection); &#125; return flag; &#125; public Book queryBook(int bid) &#123; Book book = null; try &#123; connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1, bid); //通过executeQuery方法执行查询语句，并且将查询的结果存放到一个ResultSet对象中（结果集） rs = preparedStatement.executeQuery(); //处理结果：从rs中获取查询结果 if (rs.next()) &#123; int id = rs.getInt(&quot;book_id&quot;); String name = rs.getString(&quot;book_name&quot;); String author = rs.getString(&quot;book_author&quot;); double price = rs.getDouble(&quot;book_price&quot;); int stock = rs.getInt(&quot;book_stock&quot;); String desc = rs.getString(&quot;book_desc&quot;); //我们需要将查询到的一条数据库图书记录的6个值返回 book = new Book(id, name, author, price, stock, desc); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; finally &#123; DBHelper.close(rs, preparedStatement, connection); &#125; return book; &#125; public List&lt;Book&gt; listBooks()&#123; List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); try &#123; connection = DBHelper.getConnection(); String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books&quot;; statement = connection.createStatement(); rs = statement.executeQuery(sql); while (rs.next()) &#123; int bookId = rs.getInt(&quot;book_id&quot;); String bookName = rs.getString(&quot;book_name&quot;); String bookAuthor = rs.getString(&quot;book_author&quot;); double bookPrice = rs.getDouble(&quot;book_price&quot;); int bookStock = rs.getInt(&quot;book_stock&quot;); String bookDesc = rs.getString(&quot;book_desc&quot;); Book book = new Book(bookId, bookName, bookAuthor, bookPrice, bookStock, bookDesc); bookList.add(book); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(rs, statement, connection); &#125; return bookList; &#125; public boolean updateBook(Book book) &#123; boolean flag = false; try &#123; connection = DBHelper.getConnection(); String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1, book.getBookName()); preparedStatement.setString(2, book.getBookAuthor()); preparedStatement.setDouble(3, book.getBookPrice()); preparedStatement.setInt(4, book.getBookStock()); preparedStatement.setString(5, book.getBookDesc()); preparedStatement.setInt(6, book.getBookId()); int i = preparedStatement.executeUpdate(); flag = i &gt; 0; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; finally &#123; DBHelper.close(preparedStatement, connection); &#125; return flag; &#125;&#125; 九、JDBC综合案例 完成学生信息的CRUD操作 9.1 JDBC数据库编程的流程 创建数据库、数据表 123456create table students( stu_num char(8) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null); 创建新的Java工程 创建JDBC的工具类：DBHelper 创建DTO类（用于封装参数及查询结果） 创建DAO类（用于完成CRUD操作） 9.2 创建JDBC工具类 在Java工程中创建package :com.qfedu.jdbc.utils 在com.qfedu.jdbc.utils包中创建工具类DBHelper 编写DBHelper工具类： 添加驱动jar文件 编写DBHelper代码 9.3 创建DTO类 在Java工程中创建package：com.qfedu.jdbc.dto 在com.qfedu.jdbc.dto创建数据表对应的实体类Student 编写实体类 1234567891011121314151617181920212223242526272829303132333435package com.qfedu.jdbc.dto;/** * @Descript 用于传递学生信息的实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Student &#123; private String stuNum; private String stuName; private String stuGender; private int stuAge; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;stuNum=&#x27;&quot; + stuNum + &#x27;\\&#x27;&#x27; + &quot;, stuName=&#x27;&quot; + stuName + &#x27;\\&#x27;&#x27; + &quot;, stuGender=&#x27;&quot; + stuGender + &#x27;\\&#x27;&#x27; + &quot;, stuAge=&quot; + stuAge + &#x27;&#125;&#x27;; &#125; public Student() &#123; &#125; public Student(String stuNum, String stuName, String stuGender, int stuAge) &#123; this.stuNum = stuNum; this.stuName = stuName; this.stuGender = stuGender; this.stuAge = stuAge; &#125; //get set&#125; 9.4 创建DAO类 创建DAO类，完成JDBC操作 在Java项目中创建package:com.qfedu.jdbc.dao 在com.qfedu.jdbc.dao包中创建类StudentDAO 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.qfedu.jdbc.dao;import com.qfedu.jdbc.dto.Student;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * @Descript students表的数据访问类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class StudentDAO &#123; private Connection connection; private Statement statement; private PreparedStatement preparedStatement; private ResultSet resultSet; //1、添加学生信息 public boolean insert(Student student)&#123; boolean flag = false; try &#123; connection = DBHelper.getConnectin(); String sql = &quot;insert into students(stu_num,stu_name,stu_gender,stu_age) values(?,?,?,?)&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,student.getStuNum()); preparedStatement.setString(2,student.getStuName()); preparedStatement.setString(3,student.getStuGender()); preparedStatement.setInt(4,student.getStuAge()); int i = preparedStatement.executeUpdate(); flag = i&gt;0; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(preparedStatement,connection); &#125; return flag; &#125; //2、根据学号查询一个学生记录 public Student queryStudent(String snum)&#123; Student student = null; try&#123; connection = DBHelper.getConnectin(); String sql = &quot;select stu_num,stu_name,stu_gender,stu_age from students where stu_num=?&quot;; preparedStatement = connection.prepareStatement(sql); preparedStatement.setString(1,snum); resultSet = preparedStatement.executeQuery(); if(resultSet.next())&#123; String stuNum = resultSet.getString(&quot;stu_num&quot;); String stuName = resultSet.getString(&quot;stu_name&quot;); String stuGender = resultSet.getString(&quot;stu_gender&quot;); int stuAge = resultSet.getInt(&quot;stu_age&quot;); student = new Student(stuNum,stuName,stuGender,stuAge); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(resultSet,preparedStatement,connection); &#125; return student; &#125; //3、查询多个学生信息 public List&lt;Student&gt; listStudents()&#123; List&lt;Student&gt; studentList = new ArrayList&lt;&gt;(); try&#123; connection = DBHelper.getConnectin(); String sql = &quot;select stu_num,stu_name,stu_gender,stu_age from students&quot;; statement = connection.createStatement(); resultSet = statement.executeQuery(sql); while(resultSet.next())&#123; String stuNum = resultSet.getString(&quot;stu_num&quot;); String stuName = resultSet.getString(&quot;stu_name&quot;); String stuGender = resultSet.getString(&quot;stu_gender&quot;); int stuAge = resultSet.getInt(&quot;stu_age&quot;); Student s = new Student(stuNum,stuName,stuGender,stuAge); studentList.add(s); &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; finally &#123; DBHelper.close(resultSet,statement,connection); &#125; return studentList; &#125;&#125; 9.5 测试DAO类中的方法 使用junit对DAO中创建的JDBC方法进行单元测试 9.5.1 下载导入junit依赖到项目中 下载：https://mvnrepository.com/ （如果使用junit 4.10 + 版本单元测试，需要以下两个jar文件） junit-4.12.jar hamcrest-core-1.3.jar 将junit-4.12.jar、hamcrest-core-1.3.jar拷贝项目的lib文件夹 选择拷贝到项目中的jar文件—右键—Add as Library 9.5.2 创建单元测试类 如果我们需要对某个类中的方法进行单元测试，我们需要创建这个类的测试类 StudentDAO ———&gt; StudentDAOTest（测试类：类名&#x3D;被测试类+Test） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.qfedu.jdbc.test;import com.qfedu.jdbc.dao.StudentDAO;import com.qfedu.jdbc.dto.Student;import org.junit.Test;import java.util.List;import static org.junit.Assert.*;/** * @Descript 此类是StudentDAO的单元测试类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class StudentDAOTest &#123; //1.在测试类中定义成员变量：创建被测试类的对象 private StudentDAO studentDAO = new StudentDAO(); //2创建测试方法 ： 用来测试StudentDAO类中的insertStudent方法 //a.测试方法名=test+被测试方法名 //b.测试方法无参数无返回值 @Test public void testInsertStudent()&#123; //准备被测试方法所需的参数 Student stu = new Student(&quot;1008&quot;,&quot;Tom&quot;,&quot;男&quot;,20); //调用被测试方法，获取结果 boolean b = studentDAO.insertStudent(stu); //断言返回结果(成立 | 不成立) assertTrue(b); &#125; @Test public void testQueryStudent()&#123; String snum = &quot;1008&quot;; Student student = studentDAO.queryStudent(snum); assertEquals(&quot;Tom2&quot;,student.getStuName()); &#125; @Test public void testListStudents()&#123; List&lt;Student&gt; studentList = studentDAO.listStudents(); assertEquals(8,studentList.size()); &#125;&#125; 十、JDBC事务管理 什么是事务？ 事务的四大特性—ACID 事务的隔离级别 MySQL事务管理： start transaction rollback commit 10.1 JDBC实现借书操作 向records表添加借书记录 修改books表中的库存 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.qfedu.jdbc.dao;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;/** * @Descript * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookDAO &#123; /** * 借书： * @param stuNum 借书的学生学号 * @param bookId 借书的图书编号 * @param num 借书的数量 * @return */ public boolean borrowBook2(String stuNum,int bookId,int num)&#123; boolean flag = false; try &#123; //1.向`records`表添加借书记录 Connection connection = DBHelper.getConnectin(); String sql1 = &quot;insert into records(snum,bid,borrow_num,is_return,borrow_date) values(?,?,?,0,sysdate())&quot;; PreparedStatement preparedStatement = connection.prepareStatement(sql1); preparedStatement.setString(1,stuNum); preparedStatement.setInt(2,bookId); preparedStatement.setInt(3,num); int i = preparedStatement.executeUpdate(); int k = 10/0; //造异常：算术异常 //2.修改`books`表中的库存 Connection connection2 = DBHelper.getConnectin(); String sql2 = &quot;update books set book_stock=book_stock-? where book_id=?&quot;; PreparedStatement preparedStatement2 = connection2.prepareStatement(sql2); preparedStatement2.setInt(1,num); preparedStatement2.setInt(2,bookId); int j = preparedStatement2.executeUpdate(); flag = i&gt;0 &amp;&amp; j&gt;0; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; // 关闭连接 &#125; return flag; &#125;&#125; 分析： 借书业务由两个数据库操作完成，这两个操作要么同时成功，要么同时失败，构成一个数据库事务； JDBC的DML操作默认是自定提交的，因此当第一个DML操作（添加借书记录）完成后，无论第二个操作（修改库存）是否成功，借书记录都会添加到数据库，而且是永久的 JDBC中该如何做事务管理呢？ 10.2 JDBC事务管理 一个事务中的多个DML操作需要基于同一个数据库连接； 创建连接之后，设置事务手动提交（关闭自动提交）；connection.setAutoCommit(false); 当当前事务中的所有DML操作完成之后手动提交；connection.commit(); 当事务中的任何一个步骤出现异常，在catch代码块中执行事务回滚。connection.rollback(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.qfedu.jdbc.dao;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;/** * @Descript * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookDAO &#123; /** * 借书： * @param stuNum 借书的学生学号 * @param bookId 借书的图书编号 * @param num 借书的数量 * @return */ public boolean borrowBook(String stuNum,int bookId,int num)&#123; boolean flag = false; Connection connection = null; PreparedStatement preparedStatement1 = null; PreparedStatement preparedStatement2 = null; try &#123; connection = DBHelper.getConnectin(); //设置使用当前Connection连接操作数据库自动提交关闭 connection.setAutoCommit(false); //1.向`records`表添加借书记录 String sql1 = &quot;insert into records(snum,bid,borrow_num,is_return,borrow_date) values(?,?,?,0,sysdate())&quot;; preparedStatement1 = connection.prepareStatement(sql1); preparedStatement1.setString(1,stuNum); preparedStatement1.setInt(2,bookId); preparedStatement1.setInt(3,num); int i = preparedStatement1.executeUpdate(); int k = 10/0; //造异常：算术异常 //2.修改`books`表中的库存 String sql2 = &quot;update books set book_stock=book_stock-? where book_id=?&quot;; preparedStatement2 = connection.prepareStatement(sql2); preparedStatement2.setInt(1,num); preparedStatement2.setInt(2,bookId); int j = preparedStatement2.executeUpdate(); // 提交事务 connection.commit(); flag = i&gt;0 &amp;&amp; j&gt;0; &#125;catch (Exception e)&#123; try &#123; //一旦事务执行过程中出现异常，执行回滚 connection.rollback(); &#125; catch (SQLException ex) &#123; ex.printStackTrace(); &#125; &#125;finally &#123; DBHelper.close(preparedStatement1,null); DBHelper.close(preparedStatement2,connection); &#125; return flag; &#125; &#125; 10.3 Service层的事务管理 DAO只负责数据库的操作，业务由service层进行管理 10.3.1 Service分层介绍 DAO负责特定的数据库操作 Servcie进行业务处理，Service业务处理过程如果需要数据库操作，则调用DAO完成 10.3.2 Service分层实现 创建RecordDAO，完成insertRecord方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.qfedu.jdbc.dao;import com.qfedu.jdbc.utils.DBHelper;import java.sql.Connection;import java.sql.PreparedStatement;/** * @Descript 完成对借书记录表的JDBC操作 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class RecordDAO &#123; /** * 添加借书记录 * @param snum 借书的学生的学号 * @param bid 借书的图书编号 * @param num 借书的数量 * @return 添加借书记录成功返回true，失败返回false */ public boolean insertRecord(String snum,int bid,int num)&#123; boolean flag = false; Connection connection = null; PreparedStatement preparedStatement1 = null; try&#123; //1.向`records`表添加借书记录 connection = DBHelper.getConnectin(); String sql1 = &quot;insert into records(snum,bid,borrow_num,is_return,borrow_date) values(?,?,?,0,sysdate())&quot;; preparedStatement1 = connection.prepareStatement(sql1); preparedStatement1.setString(1,snum); preparedStatement1.setInt(2,bid); preparedStatement1.setInt(3,num); int i = preparedStatement1.executeUpdate(); flag = i&gt;0; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(preparedStatement1,connection); &#125; return flag; &#125;&#125; 在BookDAO中定义updateStock修改库存方法 1234567891011121314151617181920212223242526272829303132333435363738394041package com.qfedu.jdbc.dao;import com.qfedu.jdbc.utils.DBHelper;import java.sql.*;/** * @Descript * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookDAO &#123; /** * 修改库存 * @param bid 要修改库存的图书编号 * @param num book_stock=book_stock-num * @return */ public boolean updateStock(int bid,int num)&#123; boolean flag = false; Connection connection = null; PreparedStatement preparedStatement2 = null; try&#123; //2.修改`books`表中的库存 connection = DBHelper.getConnectin(); String sql2 = &quot;update books set book_stock=book_stock-? where book_id=?&quot;; preparedStatement2 = connection.prepareStatement(sql2); preparedStatement2.setInt(1,num); preparedStatement2.setInt(2,bid); int j = preparedStatement2.executeUpdate(); flag = j&gt;0; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; DBHelper.close(preparedStatement2,connection); &#125; return flag; &#125;&#125; 创建BookService完成借书业务 1234567891011121314151617181920212223242526272829package com.qfedu.jdbc.service;import com.qfedu.jdbc.dao.BookDAO;import com.qfedu.jdbc.dao.RecordDAO;/** * @Descript 图书管理的业务类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookService &#123; private RecordDAO recordDAO = new RecordDAO(); private BookDAO bookDAO = new BookDAO(); /** * 借书业务，包含两个步骤，这两个步骤要么同时成功，要么同时失败——事务 */ public boolean borrowBook(String stuNum,int bookId,int num)&#123; //1.添加借书记录 boolean b1 = recordDAO.insertRecord(stuNum, bookId, num); //2.修改图书库存 boolean b2 = bookDAO.updateStock(bookId, num); // 结果处理 boolean r = b1 &amp;&amp; b2; return r; &#125;&#125; 10.3.3 Service层的事务管理 Servcie层事务中多个数据库的DML操作是相互独立的，如何保证所有DML要么同时成功，要么同时失败呢？ 事务管理要满足以下条件： 多个DML操作需使用同一个数据库连接 第一个DML操作之前设置事务手动提交 所有DML操作执行完成之后提交事务 出现异常则进行事务回滚 如何让Service事务中的多个DML使用同一个数据库连接？ 在Service获取连接对象，将连接对象传递到DAO中 分析：DAO类中的Connection对象需要通过Service传递给进来，这种对象传递本来也无可厚非，但是当我们通过面向接口开发时（面向接口，是为了能够灵活的定义实现类），容易造成接口的冗余（接口污染） 使用ThreadLocal容器，实现多个DML操作使用相同的连接 存储Connection的容器可以使用List集合 使用List集合做容器，在多线程并发编程中会出现资源竞争问题——多个并发的线程使用的是同一个数据库连接对象（我们的要求是同一个事务中使用同一个连接，而并非多个线程共享连接） 为了解决并发编程的连接对象共享问题，我们可以使用ThreadLocal作为数据库连接对象的容器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.qfedu.jdbc.utils;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * @Descript * @Author 千锋涛哥 * 公众号： Java架构栈 */public class DBHelper &#123; //1.定义数据库连接信息 private static final String DRIVER = &quot;com.mysql.cj.jdbc.Driver&quot;; private static final String URL = &quot;jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8&quot;; private static final String USERNAME = &quot;root&quot;; private static final String PASSWORD = &quot;@QFedu123&quot;; //1️⃣定义ThreadLocal容器 private static final ThreadLocal&lt;Connection&gt; local = new ThreadLocal&lt;&gt;(); //2.静态初始化块注册驱动 static&#123; try &#123; Class.forName(DRIVER); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; //3.创建数据库连接 public static Connection getConnectin()&#123; // 2️⃣从ThreadLocal容器中获取连接 Connection connection = local.get(); try &#123; if(connection == null)&#123; //3️⃣如果容器中没有连接，则创建连接，并将创建的连接存放到容器 connection = DriverManager.getConnection(URL,USERNAME,PASSWORD); local.set(connection); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125; //4. 4️⃣关闭连接 // 如果使用ThreadLocal存储数据库连接，关闭连接时同时要将Connection对象从ThreadLocal中移除 public static void closeConnection()&#123; // 获取到当前线程使用的数据库连接对象 Connection connection = local.get(); try &#123; if(connection !=null &amp;&amp; !connection.isClosed())&#123; connection.close(); &#125; // 将关闭后的连接对象从ThreadLocal中移除 local.remove(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void closeStatement(Statement statement)&#123; closeStatement(null,statement); &#125; public static void closeStatement(ResultSet resultSet, Statement statement)&#123; try &#123; if(resultSet!=null &amp;&amp; !resultSet.isClosed())&#123; resultSet.close(); &#125; if(statement!=null &amp;&amp; !statement.isClosed())&#123; statement.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 十一、数据库连接池11.1 什么是数据库连接池？ 如果每个JDBC操作需要数据库连接都重新创建，使用完成之后都销毁，我们的JVM会因为频繁的创建、销毁连接而占用额外的系统资源。 数据库连接本质上是可被重用的资源（当一个JDBC操作完成之后，其创建的连接是可以被其他JDBC操作使用的），基于这个特性： 我们可以创建一个存放数据库连接的容器（连接池），连接池是有最大容量的 当我们要进行JDBC操作时，直接从这个容器中获取连接 如果容器中没有空闲的连接且连接池中连接的个数没有达到最大值，则创建新的数据库连接存入连接池并给这个操作使用，使用完成之后无需关闭连接直接归还这个容器中即可； 如果容器中没有空闲的连接且连接池中连接的个数达到最大值，当前操作就会进行等待，等待连接池中的某个连接被归还，归还之后再使用； 如果容器中有空闲连接，则无需创建新的连接，直接从容器中获取这个空闲连接进行使用； 连接池：存放数据库连接对象的容器 连接池作用：对数据库连接进行管理，减少因重复创建、销毁连接导致的系统开销 11.2 常用连接池 我们可以编程实现：创建一个数组、集合来存放数据库连接； 目前市面上已经有多种实现的数据库连接池了，我们无需再手动实现，只需引用对应的数据库连接池产品，即可在我们自己的Java应用中使用连接池（站在巨人的肩上） 功能 dbcp druid c3p0 HikariCP 是否支持PSCache 是 是 是 否 监控 jmx jmx&#x2F;log&#x2F;http jmx,log jmx 扩展性 弱 好 弱 弱 sql拦截及解析 无 支持 无 无 代码 简单 中等 复杂 简单 特点 依赖于common-pool 阿里开源，功能全面 历史久远，代码逻辑复杂，且不易维护 优化力度大，功能简单，起源于boneCP 连接池管理 LinkedBlockingDeque 数组 ThreadLocalCopyOnWriteArrayList 基于连接池的性能、使用的便捷性、连接监控等多方面综合情况，druid是目前企业应用中使用最广泛的 Hikari在SpringBoot中默认集成，性能是诸多竞品中最好的 11.3 使用Druid连接池11.3.1 创建Java应用 创建Java工程 添加驱动jar文件 11.3.2 创建连接池属性配置 在src中创建package：com.qfedu.jdbc.utils 在com.qfedu.jdbc.utils中创建druid.properties文件 配置druid连接池的实行 123456789101112131415# 数据库连接信息driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8username=rootpassword=@QFedu123# 连接池属性# 连接池的初始化连接数&lt;创建数据库连接池时默认初始化的连接的个数&gt;initialSize=10# 连接池的最大连接数maxActive=50# 最小空闲连接数（当数据库连接使用率很低时，连接池中的连接会被释放一部分）minIdle=5# 超时等待时间(单位：ms)maxWait=30000 11.3.3 创建连接池工具类 下载并导入druid的jar文件druid-1.2.8.jar 在com.qfedu.jdbc.utils创建DruidUtils工具类（工具类与属性文件druid.properties在同目录下） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.qfedu.jdbc.utils;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;/** * @Descript Druid数据库连接池工具类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class DruidUtils &#123; //1.定义DruidDataSource对象：表示Druid数据库连接池（数据源） private static DruidDataSource druidDataSource; //2.静态代码块初始化定义DruidDataSource对象 static&#123; try &#123; //读取druid.properties文件中配置的属性 InputStream is = DruidUtils.class.getResourceAsStream(&quot;druid.properties&quot;); Properties properties = new Properties(); properties.load(is); //使用属性文件初始化DruidDataSource对象 druidDataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //3.创建静态方法，从连接池对象中获取连接 public static Connection getConnection()&#123; Connection connection = null; try &#123; connection = druidDataSource.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125; &#125; 十二、通用JDBC操作封装 在DAO层的JDBC操作中，对数据的表增、删、改、查操作存在代码的冗余，我们可以对其公共部分进行封装，实现代码的复用。 12.1 DML操作封装 对于数据库的DML操作： 参数不同 SQL通过 SQL参数复制不同 通用的DML操作方法 123456789101112131415161718192021222324252627282930313233343536373839404142package com.qfedu.jdbc.utils;import java.sql.Connection;import java.sql.PreparedStatement;/** * @Descript 公共DAO，用于封装公共的JDBC操作 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class CommonDAO &#123; /** * 公共DML操作 * @param sql 执行的SQL指令 * @return */ /** * sql : delete from students where stu_num=? * args: snum * * sql : insert into students(stu_num,stu_name,stu_gender,stu_age) values(?,?,?,?) * args: 1009 Lucy 女 18 */ public boolean update(String sql, Object... args)&#123; boolean b = false; try&#123; Connection connection = DruidUtils.getConnection(); PreparedStatement preparedStatement = connection.prepareStatement(sql); for (int i = 0; i &lt; args.length ; i++) &#123; preparedStatement.setObject(i+1,args[i]); &#125; int i = preparedStatement.executeUpdate(); b = i&gt;0; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return b; &#125;&#125; 12.2 DQL操作封装 使用泛型设置通用查询方法的返回类型 123456789101112131415package com.qfedu.jdbc.utils;import java.sql.ResultSet;import java.sql.SQLException;/** * @Descript 用于定义结果集映射的接口 * @Author 千锋涛哥 * 公众号： Java架构栈 */public interface RowMapper&lt;T&gt; &#123; public T getRow(ResultSet resultSet) throws SQLException;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.qfedu.jdbc.utils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.List;/** * @Descript 公共DAO，用于封装公共的JDBC操作 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class CommonDAO&lt;T&gt; &#123; /** * 公共DML操作 */ public boolean update(String sql, Object... args)&#123; boolean b = false; try&#123; Connection connection = DruidUtils.getConnection(); PreparedStatement preparedStatement = connection.prepareStatement(sql); for (int i = 0; i &lt; args.length ; i++) &#123; preparedStatement.setObject(i+1,args[i]); &#125; int i = preparedStatement.executeUpdate(); b = i&gt;0; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return b; &#125; /** * 查询 */ public List&lt;T&gt; select(String sql, RowMapper&lt;T&gt; rowMapper,Object...args)&#123; List&lt;T&gt; list = new ArrayList&lt;&gt;(); try&#123; Connection connection = DruidUtils.getConnection(); PreparedStatement preparedStatement = connection.prepareStatement(sql); for (int i = 0; i &lt;args.length ; i++) &#123; preparedStatement.setObject(i+1,args[i]); &#125; ResultSet resultSet = preparedStatement.executeQuery(); while(resultSet.next())&#123; // 从查询结果中取出一条记录（多个值），封装到一个实体类对象中 // getRow就是方法调用者在调用方法时，传递进来的用于映射查询结果的方法 T t = rowMapper.getRow(resultSet); list.add(t); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return list; &#125;&#125; 12.3 基于通用JDBC操作的案例 图书信息进行JDBC操作 创建图书实体类Book 创建BookDAO 12.3.1 创建实体类12345678910111213141516171819/** * @Descript 图书信息实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Book &#123; private int bookId; private String bookName; private String bookAuthor; private double bookPrice; private int bookStock; private String bookDesc; //无参构造器 //全参构造器 //toString //get和set&#125; 12.3.2 创建DAO类 DAO中的操作都是调用CommonDAO实现的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.qfedu.jdbc.dao;import com.qfedu.jdbc.dto.Book;import com.qfedu.jdbc.utils.CommonDAO;import com.qfedu.jdbc.utils.RowMapper;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;/** * @Descript 对图书信息表进行CRUD操作 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookDAO &#123; private CommonDAO&lt;Book&gt; commonDAO = new CommonDAO&lt;&gt;(); public boolean insertBook(Book book)&#123; String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; boolean b = commonDAO.update(sql, book.getBookName(), book.getBookAuthor(), book.getBookPrice(), book.getBookStock(), book.getBookDesc()); return b; &#125; public boolean deleteBook(int bookId)&#123; String sql = &quot;delete from books where book_id=?&quot;; boolean b = commonDAO.update(sql, bookId); return b; &#125; public boolean updateBook(Book book)&#123; String sql=&quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; boolean b = commonDAO.update(sql, book.getBookName(), book.getBookAuthor(), book.getBookPrice(), book.getBookStock(), book.getBookDesc(), book.getBookId()); return b; &#125; public Book queryBook(int bookId)&#123; String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; RowMapper&lt;Book&gt; bookRowMapper = new RowMapper&lt;Book&gt;()&#123; public Book getRow(ResultSet resultSet) throws SQLException &#123; int bid = resultSet.getInt(&quot;book_id&quot;); String bookName = resultSet.getString(&quot;book_name&quot;); String bookAuthor = resultSet.getString(&quot;book_author&quot;); double bookPrice = resultSet.getDouble(&quot;book_price&quot;); int bookStock = resultSet.getInt(&quot;book_stock&quot;); String bookDesc = resultSet.getString(&quot;book_desc&quot;); return new Book(bid,bookName,bookAuthor,bookPrice,bookStock,bookDesc); &#125; &#125;; List&lt;Book&gt; list = commonDAO.select(sql, bookRowMapper, bookId); return list.size()&gt;0?list.get(0):null; &#125; public List&lt;Book&gt; listBooks()&#123; String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books&quot;; List&lt;Book&gt; list = commonDAO.select(sql, resultSet -&gt; &#123; int bid = resultSet.getInt(&quot;book_id&quot;); String bookName = resultSet.getString(&quot;book_name&quot;); String bookAuthor = resultSet.getString(&quot;book_author&quot;); double bookPrice = resultSet.getDouble(&quot;book_price&quot;); int bookStock = resultSet.getInt(&quot;book_stock&quot;); String bookDesc = resultSet.getString(&quot;book_desc&quot;); return new Book(bid, bookName, bookAuthor, bookPrice, bookStock, bookDesc); &#125;); return list; &#125;&#125; 十三、Apache DBUtils13.1 DBUtils介绍 Commons DBUtils是Apache组织提供的一个针对JDBC进行简单封装的开源工具类库，使用DBUtils可以极大简化JDBC应用程序开发，同时不会影响数据库访问的性能。 DBUtils是Java编程中数据库访问的轻巧、使用的工具类库 提供对数据表通用的DML操作 提供对数据表通用的DQL操作（可以把结果封装成对象、集合等类型） DBUtils工具类库中的核心类： QueryRunner，用于执行SQL指令（相当于我们自己封装的CommonDAO类） update() , 用于执行DML指令 query(), 用于执行DQL指令 ResultSetHandler接口，结果集处理器，用于处理查询结果（相当于我们自己的封装的RowMapper接口） BeanHandler实现类：当查询语句返回一条结果时，使用BeanHandler将结果转换成一个对象 BeanListHandler实现类：当查询语句返回多个结果时，使用BeanListHandler将结果转换成一个集合 ScalarHandler实现类：当查询结果返回一个值时，使用ScalarHandler将这个值转换成Java变量类型 13.2 DBUtils的使用准备 新建Java工程 添加依赖： mysql-connector-java-8.0.26.jar druid-1.2.8.jarApache DBUtils建立数据库连接是依赖连接池数据源的，因此我们需要使用连接池 commons-dbutils-1.7.jar 配置druid的属性文件 创建com.qfedu.jdbc.utils包 在包中创建druid.properties文件，配置如下 123456789101112131415# 数据库连接信息driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/db_test3?characterEncoding=utf8username=rootpassword=@QFedu123# 连接池属性# 连接池的初始化连接数&lt;创建数据库连接池时默认初始化的连接的个数&gt;initialSize=10# 连接池的最大连接数maxActive=50# 最小空闲连接数（当数据库连接使用率很低时，连接池中的连接会被释放一部分）minIdle=5# 超时等待时间(单位：ms)maxWait=30000 创建Druid连接池工具类 在com.qfedu.jdbc.utils包创建DruidUtils工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.qfedu.jdbc.utils;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;/** * @Descript * @Author 千锋涛哥 * 公众号： Java架构栈 */public class DruidUtils &#123; private static DruidDataSource druidDataSource; static&#123; try &#123; InputStream is = DruidUtils.class.getResourceAsStream(&quot;druid.properties&quot;); Properties properties = new Properties(); properties.load(is); druidDataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取数据库连接池数据源对象 * @return */ public static DataSource getDataSource()&#123; return druidDataSource; &#125; public static Connection getConnection()&#123; Connection connection = null; try &#123; connection = druidDataSource.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125;&#125; 13.3 DBUtils使用 完成图书信息的数据库操作 创建实体类 123456789101112131415/** * @Descript 图书信息实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Book &#123; private int bookId; private String bookName; private String bookAuthor; private double bookPrice; private int bookStock; private String bookDesc; &#125; 13.3.1 添加操作123456789101112131415public int insertBook(Book book)&#123; int i= 0; try &#123; //1.编写SQL String sql = &quot;insert into books(book_name,book_author,book_price,book_stock,book_desc) values(?,?,?,?,?)&quot;; //2.准备参数 Object[] params = &#123;book.getBookName(),book.getBookAuthor(),book.getBookPrice(),book.getBookStock(),book.getBookDesc()&#125;; //3.调用commons-dbutils中的QueryRunner执行SQL QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); i = queryRunner.update(sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i;&#125; 13.3.2 删除操作1234567891011public int deleteBook(int bookId)&#123; int i = 0; try &#123; String sql = &quot;delete from books where book_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); i = queryRunner.update(sql,bookId); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i;&#125; 13.3.3 修改操作123456789101112public int updateBook(Book book)&#123; int i=0; try &#123; String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_stock=?,book_desc=? where book_id=?&quot;; Object[] params = &#123;book.getBookName(),book.getBookAuthor(),book.getBookPrice(),book.getBookStock(),book.getBookDesc(),book.getBookId()&#125;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); i = queryRunner.update(sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i;&#125; 13.3.4 查询操作查询一条记录 1234567891011121314151617public Book queryBook(int bookId)&#123; Book book = null; try &#123; String sql = &quot;select book_id bookId,book_name bookName,book_author bookAuthor,book_price bookPrice,book_stock bookStock,book_desc bookDesc from books where book_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); //1.对于查询操作，我们需要通过QueryRunner对象调用query方法来执行 //2.所有的query方法都需要一个ResultSetHandler的参数，通过此参数指定query方法的返回类型 // 如果SQL指令执行之后返回的是一行记录，我们通过BeanHandler指定查询结果封装的实体类类型 // 要求：查询结果集的字段名必须与指定的实体类的属性名匹配 // 方案1：创建实体类的时候，实体类中属性的名字与数据表中的列名相同 // 方案2：查询语句字段取别名，让字段别名与实体类属性名一致 book = queryRunner.query(sql, new BeanHandler&lt;Book&gt;(Book.class), bookId); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return book;&#125; 自定义结果集处理 自定义ResultSetHandler 1234567891011121314151617181920212223242526272829303132public Book queryBook2(int bookId)&#123; Book book = null; try &#123; String sql = &quot;select book_id,book_name,book_author,book_price,book_stock,book_desc from books where book_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); //1.对于查询操作，我们需要通过QueryRunner对象调用query方法来执行 //2.所有的query方法都需要一个ResultSetHandler的参数，通过此参数指定query方法的返回类型 // 如果SQL指令执行之后返回的是一行记录，我们通过BeanHandler指定查询结果封装的实体类类型 // 要求：查询结果集的字段名必须与指定的实体类的属性名匹配 // 方案3：自定义ResultSetHandler结果处理 ResultSetHandler&lt;Book&gt; resultSetHandler = new ResultSetHandler&lt;Book&gt;() &#123; @Override public Book handle(ResultSet resultSet) throws SQLException &#123; Book book = null; if(resultSet.next()) &#123; int id = resultSet.getInt(&quot;book_id&quot;); String bookName = resultSet.getString(&quot;book_name&quot;); String bookAuthor = resultSet.getString(&quot;book_author&quot;); double bookPrice = resultSet.getDouble(&quot;book_price&quot;); int bookStock = resultSet.getInt(&quot;book_stock&quot;); String bookDesc = resultSet.getString(&quot;book_desc&quot;); book = new Book(id,bookName,bookAuthor,bookPrice,bookStock,bookDesc); &#125; return book; &#125; &#125;; book = queryRunner.query(sql, resultSetHandler, bookId); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return book;&#125; 查询多条记录 123456789101112public List&lt;Book&gt; listBooks()&#123; List&lt;Book&gt; bookList = null; try &#123; String sql = &quot;select book_id bookId,book_name bookName,book_author bookAuthor,book_price bookPrice,book_stock bookStock,book_desc bookDesc from books&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); //如果SQL指令执行之后返回的是多行记录，我们通过BeanListHandler指定查询结果封装的实体类的集合类型 bookList = queryRunner.query(sql, new BeanListHandler&lt;Book&gt;(Book.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return bookList;&#125; 查询一个值 例如在做分页的时候，我们需要查询数据的总记录数 123456789101112131415public long getCount()&#123; long count = 0; String sql = &quot;select count(1) from books&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); // 如果SQL指令执行之后返回的是一个值时，我们通过ScalarHandler指定返回类型 // QueryRunner在处理统计操作时，是以long类型进行操作的，因此不能直接转成Integer // 如果我们确定这个值在int范围内，我们可以在得到long类型之后进行强转，建议使用long处理 ScalarHandler&lt;Long&gt; scalarHandler = new ScalarHandler&lt;Long&gt;(); try &#123; count = queryRunner.query(sql, scalarHandler); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count;&#125;","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"}]},{"title":"day02-MySQL","slug":"day02-MySQL","date":"2022-09-19T01:08:56.000Z","updated":"2022-10-05T06:55:20.713Z","comments":true,"path":"2022/09/19/day02-MySQL/","link":"","permalink":"http://example.com/2022/09/19/day02-MySQL/","excerpt":"","text":"一、MySQL课程内容1.1 数据库介绍 数据库概念 术语介绍 1.2 MySQL数据库 下载、安装、配置、卸载 MySQL客户端工具的安装及使用 1.3 SQL 结构化查询语言 什么是SQL SQL操作数据（CRUD操作：添加、查询、修改、删除） 1.4 SQL 高级 存储过程 索引 触发器、视图 1.5 数据库设计 数据库设计步骤 数据库设计范式 E-R图 PowerDesigner建模工具、PDMan 1.6 数据库事务 什么是事务 事务特性ACID 事务隔离级别 事务管理 二、数据库介绍2.1 数据库概念 数据库，就是存放数据的仓库 数据库（DataBase，简称DB）是长期存储在计算机内部有结构的、大量的、共享的数据集合。 长期存储：持久存储 有结构： 类型：数据库不仅可以存放数据，而且存放的数据还是有类型的 关系：存储数据与数据之间的关系 大量：大多数数据库都是文件系统的，也就是说存储在数据库中的数据实际上就是存储在磁盘的文件中 共享：多个应用程序可以通过数据库实现数据的共享 2.2 关系型数据库与非关系型数据库 关系型数据库 关系型数据库，采用了关系模型来组织数据的存储，以行和列的形式存储数据并记录数据与数据之间的关系 —— 将数据存储在表格中，可以通过建立表格与表格之间的关联来维护数据与数据之间的关系。 学生信息—- 学生表 班级信息—- 班级表 非关系型数据库 非关系型数据库，采用键值对的模型来存储数据，只完成数据的记录，不会记录数据与数据之间的关系。 在非关系型数据库中基于其特定的存储结构来解决一些大数据应用的难题。 NoSQL(Not only SQL)数据库来指代非关系型数据库。 2.3 常见的数据库产品关系型数据库产品 MySQL 免费 MariaDB Percona Server PostgreSQL Oracle 收费 SQL Server Access Sybase 达梦数据库 非关系型数据库产品 面向检索的列式存储 Column-Oriented HaBase （Hadoop子系统） BigTable （Google） 面向高并发的缓存存储Key-Value Redis MemcacheDB 面向海量数据访问的文档存储 Document–Oriented MongoDB CouchDB 2.4 数据库术语 数据库（Database）：存储的数据的集合，提供数据存储的服务 数据（Data）：实际上指的是描述事物的符号记录 数据库管理系统（Database Management System，DBMS ）： 数据库管理系统，是位于用户与操作系统之间的一层数据管理软件 数据库系统管理员（Database Anministrator，简称为DBA）:负责数据库创建、使用及维护的专门人员 数据库系统（Database System，DBS）：数据库系统管理员、数据库管理系统及数据库组成整个单元 三、MySQL数据库环境准备 MySQL下载、安装、配置、卸载，安装DBMS、使用DBMS 3.1 MySQL版本及下载3.1.1 版本 MySQL 是Oracle的免费的关系型数据库 ， 官网 https://www.mysql.com/ MySQL 目前的最新版本为8.0.26 ，在企业项目中主流版本： 5.0 — 5.5 — 5.6 — 5.7 — 8.0.26 5.x — 2020年 5.7.32 8.x — 2018年8.0.11 — 2019年 8.0.16 — 2021年 8.0.26 MySQL 8.x新特性 性能：官方8.x比5.7速度要快2倍 支持NoSQL存储：5.7开始提供了对NoSQL的支持，8.0.x做了更进一步的改进 窗口函数 索引：隐藏索引、降序索引 可用性、可靠性 3.1.2 下载 官网下载：https://dev.mysql.com/downloads/installer/ 需要注册oracle 服务器在国外，下载速度…. 镜像下载：https://www.filehorse.com/download-mysql-64/download/ 3.2 MySQL 安装 傻瓜式（直接点击下一步） 选择Developer Default模式安装 此模式会安装开发人员需要的常用组件；在安装这些组件时需要对应的环境依赖，我们要暂停，先去安装依赖的环境： 例如：Microsoft Visual C++ 2019 Redistributable Package (x64) is not installed. Latest binary compatible version will be installed if agreed to resolve this requirement. 安装： 选择自定义Custom安装 3.3 MySQL配置3.3.1 端口配置 3.3.2 账号密码设置 3.3.3 服务名称 3.4 MySQL 服务的启动与停止 MySQL是以服务的形式运行在系统中 3.4.1 计算机管理窗口此电脑—右键—管理 3.4.2 windows命令行打开命令行 ： win + R — 输入cmd回车 以管理员身份打开命令行：win+s—- 输入cmd—-选择以管理员身份运行 3.5 MySQL卸载 关闭服务 12## 管理员身份启动 cmd 命令行net stop mysql80 卸载软件 打开控制面板 点击“程序和功能” 卸载MySQL 删除目录 MySQL的安装目录：C:\\Program Files (x86)\\MySQL MySQL的数据文件目录(默认隐藏)：C:\\ProgramData\\MySQL (如果不允许删除，强制删除) 删除注册表 打开注册表： win+r — 输入regedit—回车 删除 HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\MySQL80 删除搜索mysql的相关项（非必须） 四、MySQL的管理工具 当完成数据库的安装之后，mysql是以服务的形式运行在windows&#x2F;linux系统，用户是通过DBMS工具来对MySQL进行操作的，当我们安装完成MySQL之后默认安装了mysql Commcand line Client，此工具是一个命令行形式的工具，通常我们会单独安装可视化的DBMS工具： SQLyog Navicat for MySQL 4.1 MySQL Command line Client使用 打开MySQL Command line Client: 开始菜单 — MySQL — MySQL 8.0 Command line Client 连接MySQL : 输入密码即可 （如果密码错误或者mysql服务没有启动，窗口会闪退） 关闭MySQL Command line Client：输入exit指令回车即可退出 4.2 可视化工具Navicat使用4.2.1 Navicat工具下载及安装 傻瓜式安装 4.2.2 创建连接 打开navicat工具 创建连接： 五、MySQL逻辑结构 MySQL可以存储数据，但是存储在MySQL中的数据需要按照特定的结果进行存储 学生 —— 学校 数据 —— 数据库 5.1 逻辑结构 5.2 记录&#x2F;元组 六、SQL 结构化查询语言6.1 SQL概述 SQL（Structured Query Language）结构化查询语言，用于存取、查询、更新数据以及管理关系型数据库系统 6.1.1 SQL发展 SQL是在1981年由IBM公司推出，一经推出基于其简洁的语法在数据库中得到了广泛的应用，成为主流数据库的通用规范 SQL由ANSI组织确定规范 在不同的数据库产品中遵守SQL的通用规范，但是也对SQL有一些不同的改进，形成了一些数据库的专有指令 MySQL: limit SQLServer ： top Oracle：rownum 6.1.2 SQL分类 根据SQL指令完成的数据库操作的不同，可以将SQL指令分为四类： **DDL Data Definition Language 数据定义语言 ** 用于完成对数据库对象（数据库、数据表、视图、索引等）的创建、删除、修改 DMLData Manipulation Language 数据操作&#x2F;操纵语言 用于完成对数据表中的数据的添加、删除、修改操作 添加：将数据存储到数据表 删除：将数据从数据表移除 修改：对数据表中的数据进行修改 DQL Data Query Language 数据查询语言 用于将数据表中的数据查询出来 DCL Data Control Language 数据控制语言 用于完成事务管理等控制性操作 6.2 SQL基本语法 在MySQL Command Line Client 或者navicat等工具中都可以编写SQL指令 SQL指令不区分大小写 每条SQL表达式结束之后都以;结束 SQL关键字之间以空格进行分隔 SQL之间可以不限制换行（可以有空格的地方就可以有换行） 6.3 DDL 数据定义语言6.3.1 DDL-数据库操作 使用DDL语句可以创建数据库、查询数据库、修改数据库、删除数据库 查询数据库 12345## 显示当前mysql中的数据库列表show databases;## 显示指定名称的数据的创建的SQL指令show create database &lt;dbName&gt;; 创建数据库 12345678## 创建数据库 dbName表示创建的数据库名称，可以自定义create database &lt;dbName&gt;;## 创建数据库，当指定名称的数据库不存在时执行创建create database if not exists &lt;dbName&gt;;## 在创建数据库的同时指定数据库的字符集（字符集：数据存储在数据库中采用的编码格式 utf8 gbk）create database &lt;dbName&gt; character set utf8; 修改数据库 修改数据库字符集 12## 修改数据库的字符集alter database &lt;dbName&gt; character set utf8; # utf8 gbk 删除数据库 删除数据库时会删除当前数据库中所有的数据表以及数据表中的数据 12345## 删除数据库drop database &lt;dbName&gt;;## 如果数据库存在则删除数据库drop database is exists &lt;dbName&gt;; 使用&#x2F;切换数据库 1use &lt;dbName&gt; 6.3.2 DDL-数据表操作创建数据表 数据表实际就是一个二维的表格，一个表格是由多列组成，表格中的每一类称之为表格的一个字段 12345678create table students( stu_num char(8) not null unique, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, stu_tel char(11) not null unique, stu_qq varchar(11) unique); 查询数据表 1show tables; 查询表结构 1desc &lt;tableName&gt;; 删除数据表 12345## 删除数据表drop table &lt;tableName&gt;;## 当数据表存在时删除数据表drop table if exists &lt;tableName&gt;; 修改数据表 1234567891011121314151617## 修改表名alter table &lt;tableName&gt; rename to &lt;newTableName&gt;;## 数据表也是有字符集的，默认字符集和数据库一致alter table &lt;tableName&gt; character set utf8;## 添加列（字段）alter table &lt;tableName&gt; add &lt;columnName&gt; varchar(200);## 修改列（字段）的列表和类型alter table &lt;tableName&gt; change &lt;oldColumnName&gt; &lt;newCloumnName&gt; &lt;type&gt;;## 只修改列（字段）类型alter table &lt;tableName&gt; modify &lt;columnName&gt; &lt;newType&gt;;## 删除列（字段）alter table stus drop &lt;columnName&gt;; 6.4 MySQL数据类型 数据类型，指的是数据表中的列中支持存放的数据的类型 6.4.1 数值类型在mysql中有多种数据类型可以存放数值，不同的类型存放的数值的范围或者形式是不同的 类型 内存空间大小 范围 说明 tinyint 1byte 有符号 -128127无符号 0255 特小型整数（年龄） smallint 2byte （16bit） 有符号 -32768 ~ 32767无符号 0~65535 小型整数 mediumint 3byte 有符号 -2^31 ~ 2^31 - 1无符号 0~2^32-1 中型整数 int/integer 4byte 整数 bigint 8byte 大型整数 float 4byte 单精度 double 8byte 双精度 decimal 第一参数+2 decimal(10,2)表示数值一共有10位小数位有2位 6.4.2 字符串类型 存储字符序列的类型 类型 字符长度 说明 char 0~255 字节 定长字符串，最多可以存储255个字符 ;当我们指定数据表字段为char(n)此列中的数据最长为n个字符，如果添加的数据少于n，则补’\\u0000’至n长度 varchar 0~65536 字节 可变长度字符串，此类型的类最大长度为65535 tinyblob 0~255 字节 存储二进制字符串 blob 0~65535 存储二进制字符串 mediumblob 0~1677215 存储二进制字符串 longblob 0~4294967295 存储二进制字符串 tinytext 0~255 文本数据（字符串） text 0~65535 文本数据（字符串） mediumtext 0~1677215 文本数据（字符串） longtext 0~4294967295 文本数据（字符串） 6.4.3 日期类型 在MySQL数据库中，我们可以使用字符串来存储时间，但是如果我们需要基于时间字段进行查询操作（查询在某个时间段内的数据）就不便于查询实现 类型 格式 说明 date 2021-09-13 日期，只存储年月日 time 11:12:13 时间，只存储时分秒 year 2021 年份 datetime 2021-09-13 11:12:13 日期+时间，存储年月日时分秒 timestamp 20210913 111213 日期+时间 （时间戳） 6.5 字段约束6.5.1 约束介绍 在创建数据表的时候，指定的对数据表的列的数据限制性的要求（对表的列中的数据进行限制） 为什么要给表中的列添加约束呢？ 保证数据的有效性 保证数据的完整性 保证数据的正确性 字段常见的约束有哪些呢？ 非空约束（not null）：限制此列的值必须提供，不能为null 唯一约束（unique）：在表中的多条数据，此列的值不能重复 主键约束（primary key）：非空+唯一，能够唯一标识数据表中的一条数据 外键约束（foreign key）：建立不同表之间的关联关系 6.5.2 非空约束 限制数据表中此列的值必须提供 创建表：设置图书表的 book_name not null 12345create table books( book_isbn char(4), book_name varchar(10) not null, book_author varchar(6)); 添加数据： 6.5.3 唯一约束 在表中的多条数据，此列的值不能重复 创建表：设置图书表的book_isbn为 unique 12345create table books( book_isbn char(4) unique, book_name varchar(10) not null, book_author varchar(6)); 添加数据： 6.5.4 主键约束 主键——就是数据表中记录的唯一标识，在一张表中只能有一个主键（主键可以是一个列，也可以是多个列的组合） 当一个字段声明为主键之后，添加数据时： 此字段数据不能为null 此字段数据不能重复 创建表时添加主键约束 12345create table books( book_isbn char(4) primary key, book_name varchar(10) not null, book_author varchar(6)); 或者 123456create table books( book_isbn char(4), book_name varchar(10) not null, book_author varchar(6), primary key(book_isbn)); 删除数据表主键约束 1alter table books drop primary key; 创建表之后添加主键约束 123456789## 创建表时没有添加主键约束create table books( book_isbn char(4), book_name varchar(10) not null, book_author varchar(6));## 创建表之后添加主键约束 alter table books modify book_isbn char(4) primary key; 6.5.5 主键自动增长 在我们创建一张数据表时，如果数据表中有列可以作为主键（例如：学生表的学号、图书表的isbn）我们可以直接这是这个列为主键； 当有些数据表中没有合适的列作为主键时，我们可以额外定义一个与记录本身无关的列（ID）作为主键，此列数据无具体的含义主要用于标识一条记录，在mysql中我们可以将此列定义为int，同时设置为自动增长，当我们向数据表中新增一条记录时，无需提供ID列的值，它会自动生成。 定义主键自动增长 定义int类型字段自动增长：auto_increment 12345create table types( type_id int primary key auto_increment, type_name varchar(20) not null, type_remark varchar(100)); 注意：自动增长从1开始，每添加一条记录，自动的增长的列会自定+1，当我们把某条记录删除之后再添加数据，自动增长的数据也不会重复生成（自动增长只保证唯一性、不保证连续性） 6.5.6 联合主键 联合组件——将数据表中的多列组合在一起设置为表的主键 定义联合主键 123456create table grades( stu_num char(8), course_id int, score int, primary key(stu_num,course_id)); 注意：在实际企业项目的数据库设计中，联合主键使用频率并不高；当一个张数据表中没有明确的字段可以作为主键时，我们可以额外添加一个ID字段作为主键。 6.5.7 外键约束在多表关联部分讲解 6.6 DML 数据操纵语言 用于完成对数据表中数据的插入、删除、修改操作 12345678create table students( stu_num char(8) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, stu_tel char(11) not null unique, stu_qq varchar(11) unique); 6.6.1 插入数据语法 1insert into &lt;tableName&gt;(columnName,columnName....) values(value1,value2....); 示例 12345678910111213## 向数据表中指定的列添加数据（不允许为空的列必须提供数据）insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel) values(&#x27;20210101&#x27;,&#x27;张三&#x27;,&#x27;男&#x27;,21,&#x27;13030303300&#x27;);## 数据表名后的字段名列表顺序可以不与表中一致，但是values中值的顺序必须与表名后字段名顺序对应insert into stus(stu_num,stu_name,stu_age,stu_tel,stu_gender)values(&#x27;20210103&#x27;,&#x27;王五&#x27;,20,&#x27;13030303302&#x27;,&#x27;女&#x27;);## 当要向表中的所有列添加数据时，数据表名后面的字段列表可以省略，但是values中的值的顺序要与数据表定义的字段保持一致; insert into stus values(&#x27;20210105&#x27;,&#x27;孙琦&#x27;,&#x27;男&#x27;,21,&#x27;13030303304&#x27;,&#x27;666666&#x27;);## 不过在项目开发中，即使要向所有列添加数据,也建议将列名的列表显式写出来(增强SQL的稳定性)insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq) values(&#x27;20210105&#x27;,&#x27;孙琦&#x27;,&#x27;男&#x27;,21,&#x27;13030303304&#x27;,&#x27;666666&#x27;); 6.6.2 删除数据 从数据表中删除满足特定条件（所有）的记录 语法 1delete from &lt;tableName&gt; [where conditions]; 实例 12345678## 删除学号为20210102的学生信息delete from stus where stu_num=&#x27;20210102&#x27;;## 删除年龄大于20岁的学生信息(如果满足where子句的记录有多条，则删除多条记录)delete from stus where stu_age&gt;20;## 如果删除语句没有where子句，则表示删除当前数据表中的所有记录(敏感操作)delete from stus; 6.6.3 修改数据 对数据表中已经添加的记录进行修改 语法 1update &lt;tableName&gt; set columnName=value [where conditions] 示例 1234567891011## 将学号为20210105的学生姓名修改为“孙七”（只修改一列）update stus set stu_name=&#x27;孙七&#x27; where stu_num=&#x27;20210105&#x27;;## 将学号为20210103的学生 性别修改为“男”,同时将QQ修改为 777777（修改多列）update stus set stu_gender=&#x27;男&#x27;,stu_qq=&#x27;777777&#x27; where stu_num=&#x27;20210103&#x27;;## 根据主键修改其他所有列 update stus set stu_name=&#x27;韩梅梅&#x27;,stu_gender=&#x27;女&#x27;,stu_age=18,stu_tel=&#x27;13131313311&#x27; ,stu_qq=&#x27;999999&#x27; where stu_num=&#x27;20210102&#x27;; ## 如果update语句没有where子句，则表示修改当前表中所有行（记录）update stus set stu_name=&#x27;Tom&#x27;; 6.7 DQL 数据查询语言 从数据表中提取满足特定条件的记录 单表查询 多表联合查询 6.7.1 查询基础语法12345## select 关键字后指定要显示查询到的记录的哪些列select colnumName1[,colnumName2,colnumName3...] from &lt;tableName&gt; [where conditions];## 如果要显示查询到的记录的所有列，则可以使用 * 替代字段名列表 （在项目开发中不建议使用*）select * from stus; 6.7.2 where 子句 在删除、修改及查询的语句后都可以添加where子句（条件），用于筛选满足特定的添加的数据进行删除、修改和查询操作。 123delete from tableName where conditions;update tabeName set ... where conditions;select .... from tableName where conditions; 条件关系运算符 123456789101112131415161718192021## = 等于select * from stus where stu_num = &#x27;20210101&#x27;;## != &lt;&gt; 不等于select * from stus where stu_num != &#x27;20210101&#x27;;select * from stus where stu_num &lt;&gt; &#x27;20210101&#x27;;## &gt; 大于select * from stus where stu_age&gt;18;## &lt; 小于select * from stus where stu_age&lt;20;## &gt;= 大于等于select * from stus where stu_age&gt;=20;## &lt;= 小于等于select * from stus where stu_age&lt;=20;## between and 区间查询 between v1 and v2 [v1,v2]select * from stus where stu_age between 18 and 20; 条件逻辑运算符 在where子句中，可以将多个条件通过逻辑预算(and or not )进行连接，通过多个条件来筛选要操作的数据。 12345678## and 并且 筛选多个条件同时满足的记录select * from stus where stu_gender=&#x27;女&#x27; and stu_age&lt;21;## or 或者 筛选多个条件中至少满足一个条件的记录select * from stus where stu_gender=&#x27;女&#x27; or stu_age&lt;21;## not 取反select * from stus where stu_age not between 18 and 20; 6.7.3 LIKE 子句 在where子句的条件中，我们可以使用like关键字来实现模糊查询 语法 1select * from tableName where columnName like &#x27;reg&#x27;; 在like关键字后的reg表达式中 %表示任意多个字符 【%o% 包含字母o】 _表示任意一个字符 【_o% 第二个字母为o】 示例 1234567891011# 查询学生姓名包含字母o的学生信息select * from stus where stu_name like &#x27;%o%&#x27;;# 查询学生姓名第一个字为`张`的学生信息select * from stus where stu_name like &#x27;张%&#x27;;# 查询学生姓名最后一个字母为o的学生信息select * from stus where stu_name like &#x27;%o&#x27;;# 查询学生姓名中第二个字母为o的学生信息select * from stus where stu_name like &#x27;_o%&#x27;; 6.7.4 对查询结果的处理设置查询的列 声明显示查询结果的指定列 1select colnumName1,columnName2,... from stus where stu_age&gt;20; 计算列 对从数据表中查询的记录的列进行一定的运算之后显示出来 12345678910111213## 出生年份 = 当前年份 - 年龄select stu_name,2021-stu_age from stus;+-----------+--------------+| stu_name | 2021-stu_age |+-----------+--------------+| omg | 2000 || 韩梅梅 | 2003 || Tom | 2001 || Lucy | 2000 || Polly | 2000 || Theo | 2004 |+-----------+--------------+ as 字段取别名 我们可以为查询结果的列名 去一个语义性更强的别名 (如下案例中as关键字也可以省略) 1234567891011121314151617181920212223select stu_name,2021-stu_age as stu_birth_year from stus;+-----------+----------------+| stu_name | stu_birth_year |+-----------+----------------+| omg | 2000 || 韩梅梅 | 2003 || Tom | 2001 || Lucy | 2000 || Polly | 2000 || Theo | 2004 |+-----------+----------------+ select stu_name as 姓名,2021-stu_age as 出生年份 from stus;+-----------+--------------+| 姓名 | 出生年份 |+-----------+--------------+| omg | 2000 || 韩梅梅 | 2003 || Tom | 2001 || Lucy | 2000 || Polly | 2000 || Theo | 2004 |+-----------+--------------+ distinct 消除重复行 从查询的结果中将重复的记录消除 distinct 123456789101112131415161718192021select stu_age from stus;+---------+| stu_age |+---------+| 21 || 18 || 20 || 21 || 21 || 17 |+---------+select distinct stu_age from stus;+---------+| stu_age |+---------+| 21 || 18 || 20 || 17 |+---------+ 6.7.5 排序 - order by 将查询到的满足条件的记录按照指定的列的值升序&#x2F;降序排列 语法 1select * from tableName where conditions order by columnName asc|desc; order by columnName 表示将查询结果按照指定的列排序 asc 按照指定的列升序（默认） desc 按照指定的列降序 实例 12345678910111213141516171819202122232425# 单字段排序select * from stus where stu_age&gt;15 order by stu_gender desc;+----------+-----------+------------+---------+-------------+--------+| stu_num | stu_name | stu_gender | stu_age | stu_tel | stu_qq |+----------+-----------+------------+---------+-------------+--------+| 20210101 | omg | 男 | 21 | 13030303300 | NULL || 20210103 | Tom | 男 | 20 | 13030303302 | 777777 || 20210105 | Polly | 男 | 21 | 13030303304 | 666666 || 20210106 | Theo | 男 | 17 | 13232323322 | NULL || 20210102 | 韩梅梅 | 女 | 18 | 13131313311 | 999999 || 20210104 | Lucy | 女 | 21 | 13131323334 | NULL |+----------+-----------+------------+---------+-------------+--------+# 多字段排序 ： 先满足第一个排序规则，当第一个排序的列的值相同时再按照第二个列的规则排序select * from stus where stu_age&gt;15 order by stu_gender asc,stu_age desc;+----------+-----------+------------+---------+-------------+--------+| stu_num | stu_name | stu_gender | stu_age | stu_tel | stu_qq |+----------+-----------+------------+---------+-------------+--------+| 20210104 | Lucy | 女 | 21 | 13131323334 | NULL || 20210102 | 韩梅梅 | 女 | 18 | 13131313311 | 999999 || 20210101 | omg | 男 | 21 | 13030303300 | NULL || 20210105 | Polly | 男 | 21 | 13030303304 | 666666 || 20210103 | Tom | 男 | 20 | 13030303302 | 777777 || 20210106 | Theo | 男 | 17 | 13232323322 | NULL |+----------+-----------+------------+---------+-------------+--------+ 6.7.6 聚合函数 SQL中提供了一些可以对查询的记录的列进行计算的函数——聚合函数 count max min sum avg count() 统计函数，统计满足条件的指定字段值的个数（记录数） 123456789101112131415# 统计学生表中学生总数select count(stu_num) from stus;+----------------+| count(stu_num) |+----------------+| 7 |+----------------+# 统计学生表中性别为男的学生总数select count(stu_num) from stus where stu_gender=&#x27;男&#x27;;+----------------+| count(stu_num) |+----------------+| 5 |+----------------+ max() 计算最大值，查询满足条件的记录中指定列的最大值 12345678910111213select max(stu_age) from stus;+--------------+| max(stu_age) |+--------------+| 21 |+--------------+select max(stu_age) from stus where stu_gender=&#x27;女&#x27;;+--------------+| max(stu_age) |+--------------+| 21 |+--------------+ min() 计算最小值，查询满足条件的记录中指定列的最小值 12345678910111213select min(stu_age) from stus;+--------------+| min(stu_age) |+--------------+| 14 |+--------------+select min(stu_age) from stus where stu_gender=&#x27;女&#x27;;+--------------+| min(stu_age) |+--------------+| 18 |+--------------+ sum() 计算和，查询满足条件的记录中 指定的列的值的总和 123456789101112131415# 计算所有学生年龄的综合select sum(stu_age) from stus;+--------------+| sum(stu_age) |+--------------+| 133 |+--------------+# 计算所有性别为男的学生的年龄的综合select sum(stu_age) from stus where stu_gender=&#x27;男&#x27;;+--------------+| sum(stu_age) |+--------------+| 94 |+--------------+ avg() 求平均值，查询满足条件的记录中 计算指定列的平均值 12345678910111213select avg(stu_age) from stus;+--------------+| avg(stu_age) |+--------------+| 19.0000 |+--------------+select avg(stu_age) from stus where stu_gender=&#x27;男&#x27;;+--------------+| avg(stu_age) |+--------------+| 18.8000 |+--------------+ 6.7.7 日期函数 和 字符串函数日期函数 当我们向日期类型的列添加数据时，可以通过字符串类型赋值（字符串的格式必须为 yyyy-MM-dd hh:mm:ss） 如果我们想要获取当前系统时间添加到日期类型的列，可以使用now() 或者 sysdate() 示例： 123456789101112131415161718192021222324252627282930313233343536373839desc stus;+---------------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+---------------+-------------+------+-----+---------+-------+| stu_num | char(8) | NO | PRI | NULL | || stu_name | varchar(20) | NO | | NULL | || stu_gender | char(2) | YES | | NULL | || stu_age | int | NO | | NULL | || stu_tel | char(11) | NO | UNI | NULL | || stu_qq | varchar(11) | YES | UNI | NULL | || stu_enterence | datetime | YES | | NULL | |+---------------+-------------+------+-----+---------+-------+# 通过字符串类型 给日期类型的列赋值insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_enterence)values(&#x27;20200108&#x27;,&#x27;张小三&#x27;,&#x27;女&#x27;,20,&#x27;13434343344&#x27;,&#x27;123111&#x27;,&#x27;2021-09-01 09:00:00&#x27;);# 通过now()获取当前时间insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_enterence)values(&#x27;20210109&#x27;,&#x27;张小四&#x27;,&#x27;女&#x27;,20,&#x27;13434343355&#x27;,&#x27;1233333&#x27;,now());# 通过sysdate()获取当前时间insert into stus(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_enterence)values(&#x27;20210110&#x27;,&#x27;李雷&#x27;,&#x27;男&#x27;,16,&#x27;13434343366&#x27;,&#x27;123333344&#x27;,sysdate());# 通过now和sysdate获取当前系统时间mysql&gt; select now();+---------------------+| now() |+---------------------+| 2021-09-10 16:22:19 |+---------------------+mysql&gt; select sysdate();+---------------------+| sysdate() |+---------------------+| 2021-09-10 16:22:26 |+---------------------+ 字符串函数 就是通过SQL指令对字符串进行处理 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# concat(colnum1,colunm2,...) 拼接多列select concat(stu_name,&#x27;-&#x27;,stu_gender) from stus;+---------------------------------+| concat(stu_name,&#x27;-&#x27;,stu_gender) |+---------------------------------+| 韩梅梅-女 || Tom-男 || Lucy-女 || 林涛-男 |+---------------------------------+# upper(column) 将字段的值转换成大写mysql&gt; select upper(stu_name) from stus;+-----------------+| upper(stu_name) |+-----------------+| 韩梅梅 || TOM || LUCY || POLLY || THEO || 林涛 |+-----------------+# lower(column) 将指定列的值转换成小写mysql&gt; select lower(stu_name) from stus;+-----------------+| lower(stu_name) |+-----------------+| 韩梅梅 || tom || lucy || polly || theo |+-----------------+# substring(column,start,len) 从指定列中截取部分显示 start从1开始mysql&gt; select stu_name,substring(stu_tel,8,4) from stus;+-----------+------------------------+| stu_name | substring(stu_tel,8,4) |+-----------+------------------------+| 韩梅梅 | 3311 || Tom | 3302 || Lucy | 3334 |+-----------+------------------------+ 6.7.8 分组查询 - group by 分组——就是将数据表中的记录按照指定的类进行分组 语法 12345select 分组字段/聚合函数 from 表名 [where 条件] group by 分组列名 [having 条件][order by 排序字段] select 后使用* 显示对查询的结果进行分组之后，显示每组的第一条记录（这种显示通常是无意义的） select后通常显示分组字段和聚合函数(对分组后的数据进行统计、求和、平均值等) 语句执行属性： 1️⃣先根据where条件从数据库查询记录 2️⃣group by对查询记录进行分组 3️⃣执行having对分组后的数据进行筛选 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 先对查询的学生信息按性别进行分组（分成了男、女两组），然后再分别统计每组学生的个数select stu_gender,count(stu_num) from stus group by stu_gender;+------------+----------------+| stu_gender | count(stu_num) |+------------+----------------+| 女 | 4 || 男 | 5 |+------------+----------------+# 先对查询的学生信息按性别进行分组（分成了男、女两组），然后再计算每组的平均年龄select stu_gender,avg(stu_age) from stus group by stu_gender;+------------+--------------+| stu_gender | avg(stu_age) |+------------+--------------+| 女 | 19.7500 || 男 | 18.2000 |+------------+--------------+# 先对学生按年龄进行分组（分了16、17、18、20、21、22六组），然后统计各组的学生数量，还可以对最终的结果排序select stu_age,count(stu_num) from stus group by stu_age order by stu_age;+---------+----------------+| stu_age | count(stu_num) |+---------+----------------+| 16 | 2 || 17 | 1 || 18 | 1 || 20 | 3 || 21 | 1 || 22 | 1 |+---------+----------------+# 查询所有学生，按年龄进行分组，然后分别统计每组的人数，再筛选当前组人数&gt;1的组，再按年龄升序显示出来select stu_age,count(stu_num) from stus group by stu_age having count(stu_num)&gt;1 order by stu_age;+---------+----------------+| stu_age | count(stu_num) |+---------+----------------+| 16 | 2 || 20 | 3 |+---------+----------------+# 查询性别为&#x27;男&#x27;的学生，按年龄进行分组，然后分别统计每组的人数，再筛选当前组人数&gt;1的组，再按年龄升序显示出来mysql&gt; select stu_age,count(stu_num) -&gt; from stus -&gt; where stu_gender=&#x27;男&#x27; -&gt; group by stu_age -&gt; having count(stu_num)&gt;1 -&gt; order by stu_age;+---------+----------------+| stu_age | count(stu_num) |+---------+----------------+| 16 | 2 || 20 | 2 |+---------+----------------+ 6.7.9 分页查询 - limit 当数据表中的记录比较多的时候，如果一次性全部查询出来显示给用户，用户的可读性&#x2F;体验性就不太好，因此我们可以将这些数据分页进行展示。 语法 1234select ... from ... where ...limit param1,param2 param1 int , 表示获取查询语句的结果中的第一条数据的索引（索引从0开始） param2 int, 表示获取的查询记录的条数（如果剩下的数据条数&lt;param2，则返回剩下的所有记录） 案例 对数据表中的学生信息进行分页显示，总共有10条数据，我们每页显示3条 总记录数 count 10 每页显示 pageSize 3 总页数： pageCount &#x3D; count%pageSize&#x3D;&#x3D;0 ? count&#x2F;pageSize : count&#x2F;pageSize +1; 1234567891011121314151617# 查询第一页：select * from stus [where ...] limit 0,3; (1-1)*3# 查询第二页：select * from stus [where ...] limit 3,3; (2-1)*3# 查询第三页：select * from stus [where ...] limit 6,3; (3-1)*3# 查询第四页：select * from stus [where ...] limit 9,3; (4-1)*3# 如果在一张数据表中：# pageNum表示查询的页码# pageSize表示每页显示的条数# 通用分页语句如下：select * from &lt;tableName&gt; [where ...] limit (pageNum-1)*pageSize,pageSize; 七、数据表的关联关系7.1 关联关系介绍 MySQL是一个关系型数据库，不仅可以存储数据，还可以维护数据与数据之间的关系——通过在数据表中添加字段建立外键约束 数据与数据之间的关联关系分为四种： 一对一关联 一对多关联 多对一关联 多对多关联 7.2 一对一关联 人 — 身份证 一个人只有一个身份证、一个身份证只对应一个人 学生 — 学籍 一个学生只有一个学籍、一个学籍也对应唯一的一个学生 用户 — 用户详情 一个用户只有一个详情、一个详情也只对应一个用户 方案1： 主键关联——两张数据表中主键相同的数据为相互对应的数据 方案2：唯一外键 —— 在任意一张表中添加一个字段添加外键约束与另一张表主键关联，并且将外键列添加唯一约束 7.3 一对多与多对一 班级 — 学生 （一对多） 一个班级包含多个学生 学生 — 班级 （多对一） 多个学生可以属于同一个班级 图书 — 分类 商品 —- 商品类别 方案：在多的一端添加外键 ，与一的一端主键进行关联 7.4 多对多关联 学生 — 课程 一个学生可以选择多门课、一门课程也可以由多个学生选择 会员 — 社团 一个会员可以参加多个社团、一个社团也可以招纳多个会员 方法：额外创建一张关系表来维护多对多关联——在关系表中定义两个外键，分别与两个数据表的主键进行关联 7.5 外键约束 外键约束——将一个列添加外键约束与另一张表的主键(唯一列)进行关联之后，这个外键约束的列添加的数据必须要在关联的主键字段中存在 案例：学生表 与 班级表 先创建班级表 12345create table classes( class_id int primary key auto_increment, class_name varchar(40) not null unique, class_remark varchar(200)); 创建学生表（在学生表中添加外键与班级表的主键进行关联） 123456789101112131415161718192021222324# 【方式一】在创建表的时候，定义cid字段，并添加外键约束# 由于cid 列 要与classes表的class_id进行关联，因此cid字段类型和长度要与 class_id一致create table students( stu_num char(8) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, cid int, constraint FK_STUDENTS_CLASSES foreign key(cid) references classes(class_id));#【方式二】先创建表，再添加外键约束create table students( stu_num char(8) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, cid int);# 在创建表之后，为cid添加外键约束alter table students add constraint FK_STUDENTS_CLASSES foreign key(cid) references classes(class_id);# 删除外键约束alter table students drop foreign key FK_STUDENTS_CLASSES; 向班级表添加班级信息 1234567891011121314insert into classes(class_name,class_remark) values(&#x27;Java2104&#x27;,&#x27;...&#x27;);insert into classes(class_name,class_remark) values(&#x27;Java2105&#x27;,&#x27;...&#x27;);insert into classes(class_name,class_remark) values(&#x27;Java2106&#x27;,&#x27;...&#x27;);insert into classes(class_name,class_remark) values(&#x27;Python2106&#x27;,&#x27;...&#x27;);select * from classes;+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 1 | Java2104 | ... || 2 | Java2105 | ... || 3 | Java2106 | ... || 4 | Python2106 | ... |+----------+------------+--------------+ 向学生表中添加学生信息 123456insert into students(stu_num,stu_name,stu_gender,stu_age,cid)values(&#x27;20210102&#x27;,&#x27;李斯&#x27;,&#x27;女&#x27;,20, 4 );# 添加学生时，设置给cid外键列的值必须在其关联的主表classes的classs_id列存在insert into students(stu_num,stu_name,stu_gender,stu_age,cid)values(&#x27;20210103&#x27;,&#x27;王五&#x27;,&#x27;男&#x27;,20, 6 ); 7.6 外键约束-级联 当学生表中存在学生信息关联班级表的某条记录时，就不能对班级表的这条记录进行修改ID和删除操作，如下： 123456789101112131415161718192021222324252627mysql&gt; select * from classes;+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 1 | Java2104 | ... | # 班级表中class_id=1的班级信息 被学生表中的记录关联了| 2 | Java2105 | ... | # 我们就不能修改Java2104的class_id,并且不能删除 | 3 | Java2106 | ... || 4 | Python2106 | ... |+----------+------------+--------------+mysql&gt; select * from students;+----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210101 | 张三 | 男 | 18 | 1 || 20210102 | 李四 | 男 | 18 | 1 || 20210103 | 王五 | 男 | 18 | 1 || 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+mysql&gt; update classes set class_id=5 where class_name=&#x27;Java2104&#x27;;ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`db_test2`.`students`, CONSTRAINT `FK_STUDENTS_CLASSES` FOREIGN KEY (`cid`) REFERENCES `classes` (`class_id`))mysql&gt; delete from classes where class_id=1;ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`db_test2`.`students`, CONSTRAINT `FK_STUDENTS_CLASSES` FOREIGN KEY (`cid`) REFERENCES `classes` (`class_id`)) 如果一定要修改Java2104 的班级ID，该如何实现呢 ？ 将引用Java2104班级id的学生记录中的cid修改为 NULL 在修改班级信息表中Java2104记录的 class_id 将学生表中cid设置为NULL的记录的cid重新修改为 Java2104这个班级的新的id 12345678910111213141516171819202122232425262728291️⃣update students set cid=NULL where cid=1; # 结果如下：+----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210101 | 张三 | 男 | 18 | NULL || 20210102 | 李四 | 男 | 18 | NULL || 20210103 | 王五 | 男 | 18 | NULL || 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+2️⃣update classes set class_id=5 where class_name=&#x27;Java2104&#x27;; # 结果如下+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 2 | Java2105 | ... || 3 | Java2106 | ... || 4 | Python2106 | ... || 5 | Java2104 | ... |+----------+------------+--------------+3️⃣update students set cid=5 where cid IS NULL; # 结果如下+----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210101 | 张三 | 男 | 18 | 5 || 20210102 | 李四 | 男 | 18 | 5 || 20210103 | 王五 | 男 | 18 | 5 || 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+ 我们可以使用级联操作来实现： 在添加外键时，设置级联修改 和 级联删除 12345# 删除原有的外键alter table students drop foreign key FK_STUDENTS_CLASSES;# 重新添加外键，并设置级联修改和级联删除alter table students add constraint FK_STUDENTS_CLASSES foreign key(cid) references classes(class_id) ON UPDATE CASCADE ON DELETE CASCADE; 测试级联修改： 12345678910111213141516171819202122232425262728293031323334353637383940# 班级信息+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 2 | Java2105 | ... || 3 | Java2106 | ... || 4 | Python2106 | ... || 5 | Java2104 | ... |+----------+------------+--------------+# 学生信息+----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210101 | 张三 | 男 | 18 | 5 || 20210102 | 李四 | 男 | 18 | 5 || 20210103 | 王五 | 男 | 18 | 5 || 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+# 直接修改Java2104的class_id,关联Java2104这个班级的学生记录的cid也会同步修改update classes set class_id=1 where class_name=&#x27;Java2104&#x27;;# 班级信息+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 2 | Java2105 | ... || 3 | Java2106 | ... || 4 | Python2106 | ... || 1 | Java2104 | ... |+----------+------------+--------------+# 学生信息+----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210101 | 张三 | 男 | 18 | 1 || 20210102 | 李四 | 男 | 18 | 1 || 20210103 | 王五 | 男 | 18 | 1 || 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+ 测试级联删除 123456789101112131415# 删除class_id=1的班级信息，学生表引用此班级信息的记录也会被同步删除delete from classes where class_id=1;+----------+------------+--------------+| class_id | class_name | class_remark |+----------+------------+--------------+| 2 | Java2105 | ... || 3 | Java2106 | ... || 4 | Python2106 | ... |+----------+------------+--------------++----------+----------+------------+---------+------+| stu_num | stu_name | stu_gender | stu_age | cid |+----------+----------+------------+---------+------+| 20210104 | 赵柳 | 女 | 18 | 2 |+----------+----------+------------+---------+------+ 八、连接查询 通过对DQL的学习，我们可以很轻松的从一张数据表中查询出需要的数据；在企业的应用开发中，我们经常需要从多张表中查询数据（例如：我们查询学生信息的时候需要同时查询学生的班级信息），可以通过连接查询从多张数据表提取数据: 在MySQL中可以使用join实现多表的联合查询——连接查询，join按照其功能不同分为三个操作： inner join 内连接 left join 左连接 right join 右连接 8.1 数据准备8.1.1 创建数据表创建班级信息表 和 学生信息表 12345678910111213create table classes( class_id int primary key auto_increment, class_name varchar(40) not null unique, class_remark varchar(200));create table students( stu_num char(8) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, cid int, constraint FK_STUDENTS_CLASSES foreign key(cid) references classes(class_id) ON UPDATE CASCADE ON DELETE CASCADE); 8.1.2 添加数据添加班级信息 123456789# Java2104 包含三个学生信息insert into classes(class_name,class_remark) values(&#x27;Java2104&#x27;,&#x27;...&#x27;);# Java2105 包含两个学生信息insert into classes(class_name,class_remark) values(&#x27;Java2105&#x27;,&#x27;...&#x27;);# 以下两个班级在学生表中没有对应的学生信息insert into classes(class_name,class_remark) values(&#x27;Java2106&#x27;,&#x27;...&#x27;);insert into classes(class_name,class_remark) values(&#x27;Python2105&#x27;,&#x27;...&#x27;); 添加学生信息 1234567891011121314151617# 以下三个学生信息 属于 class_id=1 的班级 （Java2104）insert into students(stu_num,stu_name,stu_gender,stu_age,cid) values(&#x27;20210101&#x27;,&#x27;张三&#x27;,&#x27;男&#x27;,20,1);insert into students(stu_num,stu_name,stu_gender,stu_age,cid) values(&#x27;20210102&#x27;,&#x27;李四&#x27;,&#x27;女&#x27;,20,1);insert into students(stu_num,stu_name,stu_gender,stu_age,cid) values(&#x27;20210103&#x27;,&#x27;王五&#x27;,&#x27;男&#x27;,20,1);# 以下三个学生信息 属于 class_id=2 的班级 （Java2105）insert into students(stu_num,stu_name,stu_gender,stu_age,cid) values(&#x27;20210104&#x27;,&#x27;赵柳&#x27;,&#x27;女&#x27;,20,2);insert into students(stu_num,stu_name,stu_gender,stu_age,cid) values(&#x27;20210105&#x27;,&#x27;孙七&#x27;,&#x27;男&#x27;,20,2);# 小红和小明没有设置班级信息insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;20210106&#x27;,&#x27;小红&#x27;,&#x27;女&#x27;,20);insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;20210107&#x27;,&#x27;小明&#x27;,&#x27;男&#x27;,20); 8.2 内连接 INNER JOIN语法 1select ... from tableName1 inner join tableName2 ON 匹配条件 [where 条件]; 8.2.1 笛卡尔积 笛卡尔积（A集合&amp;B集合）：使用A中的每个记录一次关联B中每个记录，笛卡尔积的总数&#x3D;A总数*B总数 如果直接执行select ... from tableName1 inner join tableName2;会获取两种数据表中的数据集合的笛卡尔积（依次使用tableName1 表中的每一条记录 去 匹配 tableName2的每条数据） 8.2.2 内连接条件 两张表时用inner join连接查询之后生产的笛卡尔积数据中很多数据都是无意义的，我们如何消除无意义的数据呢？ —— 添加两张进行连接查询时的条件 使用 on设置两张表连接查询的匹配条件 12345-- 使用where设置过滤条件：先生成笛卡尔积再从笛卡尔积中过滤数据（效率很低）select * from students INNER JOIN classes where students.cid = classes.class_id;-- 使用ON设置连接查询条件：先判断连接条件是否成立，如果成立两张表的数据进行组合生成一条结果记录select * from students INNER JOIN classes ON students.cid = classes.class_id; 结果：只获取两种表中匹配条件成立的数据，任何一张表在另一种表如果没有找到对应匹配则不会出现在查询结果中（例如：小红和小明没有对应的班级信息，Java2106和Python2106没有对应的学生）。 8.2 左连接 LEFT JOIN 需求：请查询出所有的学生信息，如果学生有对应的班级信息，则将对应的班级信息也查询出来 左连接：显示左表中的所有数据，如果在有右表中存在与左表记录满足匹配条件的数据，则进行匹配；如果右表中不存在匹配数据，则显示为Null 12345# 语法select * from leftTabel LEFT JOIN rightTable ON 匹配条件 [where 条件];-- 左连接 : 显示左表中的所有记录select * from students LEFT JOIN classes ON students.cid = classes.class_id; 8.3 右连接 RIGHT JOIN12-- 右连接 ：显示右表中的所有记录select * from students RIGHT JOIN classes ON students.cid = classes.class_id; 8.4 数据表别名 如果在连接查询的多张表中存在相同名字的字段，我们可以使用表名.字段名来进行区分，如果表名太长则不便于SQL语句的编写，我们可以使用数据表别名 使用示例： 1234select s.*,c.class_namefrom students sINNER JOIN classes cON s.cid = c.class_id; 8.5 子查询&#x2F;嵌套查询 子查询 — 先进行一次查询，第一次查询的结果作为第二次查询的源&#x2F;条件（第二次查询是基于第一次的查询结果来进行的） 8.5.1 子查询返回单个值-单行单列案例1：查询班级名称为&#39;Java2104&#39;班级中的学生信息(只知道班级名称，而不知道班级ID) 传统的方式： 12345-- a.查询Java2104班的班级编号select class_id from classes where class_name=&#x27;Java2104&#x27;;-- b.查询此班级编号下的学生信息select * from students where cid = 1; 子查询： 12-- 如果子查询返回的结果是一个值（单列单行），条件可以直接使用关系运算符（= != ....）select * from students where cid = (select class_id from classes where class_name=&#x27;Java2105&#x27;); 8.5.2 子查询返回多个值-多行单列案例2：查询所有Java班级中的学生信息 传统的方式： 12345678910111213141516-- a.查询所有Java班的班级编号select class_id from classes where class_name LIKE &#x27;Java%&#x27;;+--------------+| class_id |+--------------+| 1 || 2 || 3 |+--------------+-- b.查询这些班级编号中的学生信息(union 将多个查询语句的结果整合在一起)select * from students where cid=1UNIONselect * from students where cid=2UNIONselect * from students where cid=3; 子查询 12-- 如果子查询返回的结果是多个值（单列多行），条件使用IN / NOT INselect * from students where cid IN (select class_id from classes where class_name LIKE &#x27;Java%&#x27;); 8.5.3 子查询返回多个值-多行多列案例3：查询cid=1的班级中性别为男的学生信息 123456-- 多条件查询：select * from students where cid=1 and stu_gender=&#x27;男&#x27;;-- 子查询:先查询cid=1班级中的所有学生信息，将这些信息作为一个整体虚拟表(多行多列)-- 再基于这个虚拟表查询性别为男的学生信息（‘虚拟表’需要别名）select * from (select * from students where cid=1) t where t.stu_gender=&#x27;男&#x27;; 九、存储过程9.1 存储过程介绍9.1.1 SQL指令执行过程 从SQL执行执行的流程中我们分析存在的问题： 如果我们需要重复多次执行相同的SQL，SQL执行都需要通过连接传递到MySQL，并且需要经过编译和执行的步骤； 如果我们需要连续执行多个SQL指令，并且第二个SQL指令需要使用第一个SQL指令执行的结果作为参数； 9.1.2 存储过程的介绍 存储过程： 将能够完成特定功能的SQL指令进行封装（SQL指令集），编译之后存储在数据库服务器上，并且为之取一个名字，客户端可以通过名字直接调用这个SQL指令集，获取执行结果。 9.1.3 存储过程优缺点分析存储过程优点： SQL指令无需客户端编写，通过网络传送，可以节省网络开销，同时避免SQL指令在网络传输过程中被恶意篡改保证安全性； 存储过程经过编译创建并保存在数据库中的，执行过程无需重复的进行编译操作，对SQL指令的执行过程进行了性能提升； 存储过程中多个SQL指令之间存在逻辑关系，支持流程控制语句（分支、循环），可以实现更为复杂的业务; 存储过程的缺点： 存储过程是根据不同的数据库进行编译、创建并存储在数据库中；当我们需要切换到其他的数据库产品时，需要重写编写针对于新数据库的存储过程； 存储过程受限于数据库产品，如果需要高性能的优化会成为一个问题； 在互联网项目中，如果需要数据库的高（连接）并发访问，使用存储过程会增加数据库的连接执行时间（因为我们将复杂的业务交给了数据库进行处理） 9.2 创建存储过程9.2.1 存储过程创建语法12345-- 语法:create procedure &lt;proc_name&gt;([IN/OUT args])begin -- SQLend; 9.2.2 示例123456-- 创建一个存储过程实现加法运算: Java语法中，方法是有参数和返回值的-- 存储过程中，是有输入参数 和 输出参数的create procedure proc_test1(IN a int,IN b int,OUT c int)begin SET c = a+b;end; 9.3 调用存储过程1234567-- 调用存储过程-- 定义变量@mset @m = 0;-- 调用存储过程，将3传递给a，将2传递给b，将@m传递给ccall proc_test1(3,2,@m);-- 显示变量值select @m from dual; 9.4 存储过程中变量的使用 存储过程中的变量分为两种：局部变量 和 用户变量 9.4.1 定义局部变量局部变量：定义在存储过程中的变量，只能在存储过程内部使用 局部变量定义语法 12-- 局部变量要定义在存储过程中，而且必须定义在存储过程开始declare &lt;attr_name&gt; &lt;type&gt; [default value]; 局部变量定义示例： 12345678create procedure proc_test2(IN a int,OUT r int)begin declare x int default 0; -- 定义x int类型，默认值为0 declare y int default 1; -- 定义y set x = a*a; set y = a/2; set r = x+y;end; 9.4.2 定义用户变量用户变量：相当于全局变量，定义的用户变量可以通过select @attrName from dual进行查询 123-- 用户变量会存储在mysql数据库的数据字典中（dual）-- 用户变量定义使用set关键字直接定义，变量名要以@开头set @n=1; 9.4.3 给变量设置值 无论是局部变量还是用户变量，都是使用set关键字修改值 123set @n=1;call proc_test2(6,@n);select @n from dual; 9.4.4 将查询结果赋值给变量在存储过程中使用select..into..给变量赋值 123456789-- 查询学生数量create procedure proc_test3(OUT c int)begin select count(stu_num) INTO c from students; -- 将查询到学生数量赋值给cend;-- 调用存储过程call proc_test3(@n);select @n from dual; 9.4.5 用户变量使用注意事项 因为用户变量相当于全局变量，可以在SQL指令以及多个存储过程中共享，在开发中建议尽量少使用用户变量，用户变量过多会导致程序不易理解、难以维护。 9.5 存储过程的参数 MySQL存储过程的参数一共有三种：IN \\ OUT \\ INOUT 9.5.1 IN 输入参数输入参数——在调用存储过程中传递数据给存储过程的参数（在调用的过程必须为具有实际值的变量 或者 字面值） 12345678-- 创建存储过程：添加学生信息create procedure proc_test4(IN snum char(8),IN sname varchar(20), IN gender char(2), IN age int, IN cid int, IN remark varchar(255))begin insert into students(stu_num,stu_name,stu_gender,stu_age,cid,remark) values(snum,sname,gender,age,cid,remark);end;call proc_test4(&#x27;20210108&#x27;,&#x27;小丽&#x27;,&#x27;女&#x27;,20,1,&#x27;aaa&#x27;); 9.5.2 OUT 输出参数输出参数——将存储过程中产生的数据返回给过程调用者，相当于Java方法的返回值，但不同的是一个存储过程可以有多个输出参数 123456789-- 创建存储过程，根据学生学号，查询学生姓名create procedure proc_test5(IN snum char(8),OUT sname varchar(20))begin select stu_name INTO sname from students where stu_num=snum;end;set @name=&#x27;&#x27;;call proc_test5(&#x27;20210108&#x27;,@name);select @name from dual; 9.5.3 INOUT 输入输出参数12345678create procedure proc_test6(INOUT str varchar(20))begin select stu_name INTO str from students where stu_num=str;end;set @name=&#x27;20210108&#x27;;call proc_test6(@name);select @name from dual; 9.6 存储过程中流程控制 在存储过程中支持流程控制语句用于实现逻辑的控制 9.6.1 分支语句 if-then-else 1234567891011-- 单分支：如果条件成立，则执行SQLif conditions then -- SQLend if;-- 如果参数a的值为1，则添加一条班级信息create procedure proc_test7(IN a int)begin if a=1 then insert into classes(class_name,remark) values(&#x27;Java2109&#x27;,&#x27;test&#x27;); end if;end; 12345678910111213141516-- 双分支：如果条件成立则执行SQL1，否则执行SQL2if conditions then -- SQL1else -- SQL2end if;-- 如果参数a的值为1，则添加一条班级信息；否则添加一条学生信息create procedure proc_test7(IN a int)begin if a=1 then insert into classes(class_name,remark) values(&#x27;Java2109&#x27;,&#x27;test&#x27;); else insert into students(stu_num,stu_name,stu_gender,stu_age,cid,remark) values(&#x27;20210110&#x27;,&#x27;小花&#x27;,&#x27;女&#x27;,19,1,&#x27;...&#x27;); end if;end; case 12345678910111213141516-- casecreate procedure proc_test8(IN a int)begin case a when 1 then -- SQL1 如果a的值为1 则执行SQL1 insert into classes(class_name,remark) values(&#x27;Java2110&#x27;,&#x27;wahaha&#x27;); when 2 then -- SQL2 如果a的值为2 则执行SQL2 insert into students(stu_num,stu_name,stu_gender,stu_age,cid,remark) values(&#x27;20210111&#x27;,&#x27;小刚&#x27;,&#x27;男&#x27;,21,2,&#x27;...&#x27;); else -- SQL (如果变量的值和所有when的值都不匹配，则执行else中的这个SQL) update students set stu_age=18 where stu_num=&#x27;20210110&#x27;; end case;end; 9.6.2 循环语句 while 12345678910111213-- whilecreate procedure proc_test9(IN num int)begin declare i int; set i = 0; while i&lt;num do -- SQL insert into classes(class_name,remark) values( CONCAT(&#x27;Java&#x27;,i) ,&#x27;....&#x27;); set i = i+1; end while;end;call proc_test9(4); repeat 12345678910111213-- repeatcreate procedure proc_test10(IN num int)begin declare i int; set i = 1; repeat -- SQL insert into classes(class_name,remark) values( CONCAT(&#x27;Python&#x27;,i) ,&#x27;....&#x27;); set i = i+1; until i &gt; num end repeat;end;call proc_test10(4); loop 12345678910111213141516-- loopcreate procedure proc_test11(IN num int)begin declare i int ; set i =0; myloop:loop -- SQL insert into classes(class_name,remark) values( CONCAT(&#x27;HTML&#x27;,i) ,&#x27;....&#x27;); set i = i+1; if i=num then leave myloop; end if; end loop;end;call proc_test11(5); 9.7 存储过程管理9.7.1 查询存储过程 存储过程是属于某个数据库的，也就是说当我们将存储过程创建在某个数据库之后，只能在当前数据库中调用此存储过程。 查询存储过程：查询某个数据库中有哪些存储过程 12345-- 根据数据库名，查询当前数据库中的存储过程show procedure status where db=&#x27;db_test2&#x27;;-- 查询存储过程的创建细节show create procedure db_test2.proc_test1; 9.7.2 修改存储过程 修改存储过程指的是修改存储过程的特征&#x2F;特性 1alter procedure &lt;proc_name&gt; 特征1 [特征2 特征3 ....] 存储过程的特征参数： CONTAINS SQL 表示子程序包含 SQL 语句，但不包含读或写数据的语句 NO SQL 表示子程序中不包含 SQL 语句 READS SQL DATA 表示子程序中包含读数据的语句 MODIFIES SQL DATA 表示子程序中包含写数据的语句 SQL SECURITY { DEFINER |INVOKER } 指明谁有权限来执行 DEFINER 表示只有定义者自己才能够执行 INVOKER 表示调用者可以执行 COMMENT &#39;string&#39; 表示注释信息 1alter procedure proc_test1 READS SQL DATA; 9.7.3 删除存储过程1234-- 删除存储过程-- drop 删除数据库中的对象 数据库、数据表、列、存储过程、视图、触发器、索引....-- delete 删除数据表中的数据drop procedure proc_test1; 9.8 存储过程练习案例 使用存储过程解决企业项目开发过程中的问题 案例：使用存储过程完成借书操作 9.8.1 数据准备12345678910111213141516171819202122232425262728293031323334-- 创建数据库create database db_test3;-- 使用数据库use db_test3;-- 创建图书信息表：create table books( book_id int primary key auto_increment, book_name varchar(50) not null, book_author varchar(20) not null, book_price decimal(10,2) not null, book_stock int not null, book_desc varchar(200));-- 添加图书信息insert into books(book_name,book_author,book_price,book_stock,book_desc)values(&#x27;Java程序设计&#x27;,&#x27;亮亮&#x27;,38.80,12,&#x27;亮亮老师带你学Java&#x27;);insert into books(book_name,book_author,book_price,book_stock,book_desc)values(&#x27;Java王者之路&#x27;,&#x27;威哥&#x27;,44.40,9,&#x27;千锋威哥，Java王者领路人&#x27;);-- 创建学生信息表create table students( stu_num char(4) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null);-- 添加学生信息insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1001&#x27;,&#x27;张三&#x27;,&#x27;男&#x27;,20);insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1002&#x27;,&#x27;李四&#x27;,&#x27;女&#x27;,20);insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1003&#x27;,&#x27;王五&#x27;,&#x27;男&#x27;,20); 业务分析 哪个学生借哪本书，借了多少本？ 操作： 保存借书记录 修改图书库存 条件： 判断学生是否存在？ 判断图书是否存在、库存是否充足？ 创建借书记录表 1234567891011-- 借书记录表：create table records( rid int primary key auto_increment, snum char(4) not null, bid int not null, borrow_num int not null, is_return int not null, -- 0表示为归还 1 表示已经归还 borrow_date date not null, constraint FK_RECORDS_STUDENTS foreign key(snum) references students(stu_num), constraint FK_RECORDS_BOOKS foreign key(bid) REFERENCES books(book_id)); 9.8.2 创建存储过程实现借书业务1234567891011121314151617181920212223242526272829303132333435363738394041424344454647-- 实现借书业务：-- 参数1： a 输入参数 学号-- 参数2： b 输入参数 图书编号-- 参数3： m 输入参数 借书的数量-- 参数4： state 输出参数 借书的状态（1 借书成功，2 学号不存在，3 图书不存在， 4 库存不足）create procedure proc_borrow_book(IN a char(4),IN b int, IN m int,OUT state int)begin declare stu_count int default 0; declare book_count int default 0; declare stock int default 0; -- 判断学号是否存在：根据参数 a 到学生信息表查询是否有stu_num=a的记录 select count(stu_num) INTO stu_count from students where stu_num=a; if stu_count&gt;0 then -- 学号存在 -- 判断图书ID是否存在：根据参数b 查询图书记录总数 select count(book_id) INTO book_count from books where book_id=b; if book_count &gt;0 then -- 图书存在 -- 判断图书库存是否充足：查询当前图书库存，然后和参数m进行比较 select book_stock INTO stock from books where book_id=b; if stock &gt;= m then -- 执行借书 -- 操作1：在借书记录表中添加记录 insert into records(snum,bid,borrow_num,is_return,borrow_date) values(a,b,m,0,sysdate()); -- 操作2：修改图书库存 update books set book_stock=stock-m where book_id=b; -- 借书成功 set state=1; else -- 库存不足 set state=4; end if; else -- 图书不存在 set state = 3; end if; else -- 不存在 set state = 2; end if;end;-- 调用存储过程借书set @state=0;call proc_borrow_book(&#x27;1001&#x27;,1,2,@state);select @state from dual; 9.8.3 创建存储过程实现还书业务期待… 9.9 游标 问题：如果我们要创建一个存储 过程，需要返回查询语句查询到的多条数据，该如何实现呢？ 9.1.1 游标的概念游标可以用来依次取出查询结果集中的每一条数据——逐条读取查询结果集中的记录 9.1.2 游标的使用步骤1、声明游标 声明游标语法： 1DECLARE cursor_nanme CURSOR FOR select_statement; 实例 1declare mycursor cursor for select book_name,book_author,book_price from books; 2、打开游标 语法 1open mycursor; 3、使用游标 使用游标：提取游标当前指向的记录（提取之后，游标自动下移） 1FETCH mycursor INTO bname,bauthor,bprice; 4、关闭游标 1CLOSE mycursor; 9.1.3 游标使用案例123456789101112131415161718192021222324252627282930313233-- 游标使用案例create procedure proc_test2(OUT result varchar(200))begin declare bname varchar(20); declare bauthor varchar(20); declare bprice decimal(10,2); declare num int; declare i int; declare str varchar(50); -- 此查询语句执行之后返回的是一个结果集（多条记录），使用游标可以来遍历查询结果集 declare mycursor cursor for select book_name,book_author,book_price from books; select count(1) INTO num from books; -- 打开游标 open mycursor; -- 使用游标要结合循环语句 set i=0; while i&lt;num do -- 使用游标：提取游标当前指向的记录（提取之后，游标自动下移） FETCH mycursor INTO bname,bauthor,bprice; set i=i+1; -- set str=concat_ws(&#x27;~&#x27;,bname,bauthor,bprice); select concat_ws(&#x27;~&#x27;,bname,bauthor,bprice) INTO str; set result = concat_ws(&#x27;,&#x27;,result,str); end while; -- 关闭游标 close mycursor;end;-- 案例测试set @r = &#x27;&#x27;;call proc_test2(@r);select @r from dual; 十、触发器10.1 触发器的介绍触发器，就是一种特殊的存储过程。触发器和存储过程一样是一个能够完成特定功能、存储在数据库服务器上的SQL片段，但是触发器无需调用，当对数据表中的数据执行DML操作时自动触发这个SQL片段的执行，无需手动调用。 在MySQL,只有执行insert\\delete\\update操作才能触发触发器的执行。 10.2 触发器的使用10.2.1 案例说明1234567891011121314-- 学生信息表create table students( stu_num char(4) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null);-- 学生信息操作日志表create table stulogs( id int primary key auto_increment, time TIMESTAMP, log_text varchar(200)); 1234-- 当向students表中添加学生信息时，同时要在 stulogs表中添加一条操作日志insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1004&#x27;,&#x27;夏利&#x27;,&#x27;女&#x27;,20);-- 手动进行记录日志insert into stulogs(time,log_text) values(now(),&#x27;添加1004学生信息&#x27;); 案例：当向学生信息表添加、删除、修改学生信息时，使用触发器自定进行日志记录 10.2.2 创建触发器语法 123456create trigger tri_name&lt;before|after&gt; -- 定义触发时机&lt;insert|delete|update&gt; -- 定义DML类型ON &lt;table_name&gt;for each row -- 声明为行级触发器（只要操作一条记录就触发触发器执行一次）sql_statement -- 触发器操作 12345-- 创建触发器：当学生信息表发生添加操作时，则向日志信息表中记录一条日志create trigger tri_test1after insert on studentsfor each rowinsert into stulogs(time,log_text) values(now(), concat(&#x27;添加&#x27;,NEW.stu_num,&#x27;学生信息&#x27;)); 10.2.3 查看触发器1show triggers; 10.2.3 测试触发器 我们创建的触发器是在students表发生insert操作时触发，我们只需执行学生信息的添加操作 123456-- 测试1：添加一个学生信息，触发器执行了一次insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1005&#x27;,&#x27;小明&#x27;,&#x27;男&#x27;,20);-- 测试2：一条SQL指令添加了2条学生信息，触发器就执行了2次insert into students(stu_num,stu_name,stu_gender,stu_age) values(&#x27;1006&#x27;,&#x27;小刚&#x27;,&#x27;男&#x27;,20),(&#x27;1007&#x27;,&#x27;李磊&#x27;,&#x27;男&#x27;,20); 10.2.4 删除触发器1drop trigger tri_test1; 10.3 NEW与OLD 触发器用于监听对数据表中数据的insert、delete、update操作，在触发器中通常处理一些DML的关联操作；我们可以使用NEW和OLD关键字在触发器中获取触发这个触发器的DML操作的数据 NEW : 在触发器中用于获取insert操作添加的数据、update操作修改后的记录 OLD：在触发器中用于获取delete操作删除前的数据、update操作修改前的数据 10.3.1 NEW insert操作中：NEW表示添加的新记录 1234create trigger tri_test1after insert on studentsfor each rowinsert into stulogs(time,log_text) values(now(), concat(&#x27;添加&#x27;,NEW.stu_num,&#x27;学生信息&#x27;)); update操作中：NEW 表示修改后的数据 1234-- 创建触发器 : 在监听update操作的触发器中，可以使用NEW获取修改后的数据create trigger tri_test2after update on students for each rowinsert into stulogs(time,log_text) values(now(), concat(&#x27;修改学生信息为：&#x27;,NEW.stu_num,NEW.stu_name)); 10.3.2 OLD delete操作中：OLD表示删除的记录 123create trigger tri_test3after delete on students for each rowinsert into stulogs(time,log_text) values(now(), concat(&#x27;删除&#x27;,OLD.stu_num,&#x27;学生信息&#x27;)); update操作中：OLD表示修改前的记录 123create trigger tri_test2after update on students for each rowinsert into stulogs(time,log_text) values(now(), concat(&#x27;将学生姓名从【&#x27;,OLD.stu_name,&#x27;】修改为【&#x27;,NEW.stu_name,&#x27;】&#x27;)); 10.4 触发器使用总结10.4.1 优点 触发器是自动执行的，当对触发器相关的表执行响应的DML操作时立即执行； 触发器可以实现表中的数据的级联操作（关联操作），有利于保证数据的完整性； 触发器可以对DML操作的数据进行更为复杂的合法性校验 10.4.2 缺点 使用触发器实现的业务逻辑如果出现问题将难以定位，后期维护困难； 大量使用触发器容易导致代码结构杂乱，增加了程序的复杂性； 当触发器操作的数据量比较大时，执行效率会大大降低。 10.4.3 使用建议 在互联网项目中，应避免适应触发器； 对于并发量不大的项目可以选择使用存储过程，但是在互联网引用中不提倡使用存储过程（原因：存储过程时将实现业务的逻辑交给数据库处理，一则增减了数据库的负载，二则不利于数据库的迁移） 十一、视图11.1 视图的概念视图，就是由数据库中一张表或者多张表根据特定的条件查询出得数据构造成得虚拟表 11.2 视图的作用 安全性：如果我们直接将数据表授权给用户操作，那么用户可以CRUD数据表中所有数据，加入我们想要对数据表中的部分数据进行保护，可以将公开的数据生成视图，授权用户访问视图；用户通过查询视图可以获取数据表中公开的数据，从而达到将数据表中的部分数据对用户隐藏。 简单性：如果我们需要查询的数据来源于多张数据表，可以使用多表连接查询来实现；我们通过视图将这些连表查询的结果对用户开放，用户则可以直接通过查询视图获取多表数据，操作更便捷。 11.3 创建视图11.3.1 语法123create view &lt;view_name&gt;ASselect_statement 11.3.2 实例 实例1： 1234567-- 创建视图实例1：将学生表中性别为男的学生生成一个视图create view view_test1ASselect * from students where stu_gender=&#x27;男&#x27;;-- 查询视图select * from view_test1; 示例2： 123456789-- 创建视图示例2：查询学生借书的信息（学生名、图书名、借书数量）create view view_test2ASselect s.stu_name,b.book_name,borrow_numfrom books b inner join records r inner join students son b.book_id=r.bid and r.snum=s.stu_num;-- 查询视图select * from view_test2; 11.4 视图数据的特性 视图是虚拟表，查询视图的数据是来源于数据表的。当对视图进行操作时，对原数据表中的数据是否由影响呢？ 查询操作：如果在数据表中添加了新的数据，而且这个数据满足创建视图时查询语句的条件，通过查询视图也可以查询出新增的数据；当删除原表中满足查询条件的数据时，也会从视图中删除。 新增数据：如果在视图中添加数据，数据会被添加到原数据表 删除数据：如果从视图删除数据，数据也将从原表中删除 修改操作：如果通过修改数据，则也将修改原数据表中的数据 视图的使用建议: 对复杂查询简化操作，并且不会对数据进行修改的情况下可以使用视图。 11.5 查询视图结构12-- 查询视图结构desc view_test2; 11.6 修改视图123456789-- 方式1create OR REPLACE view view_test1ASselect * from students where stu_gender=&#x27;女&#x27;;-- 方式2alter view view_test1ASselect * from students where stu_gender=&#x27;男&#x27;; 11.7 删除视图 删除数据表时会同时删除数据表中的数据，删除视图时不会影响原数据表中的数据 12-- 删除视图drop view view_test1; 十二、索引 数据库是用来存储数据，在互联网应用中数据库中存储的数据可能会很多(大数据)，数据表中数据的查询速度会随着数据量的增长逐渐变慢，从而导致响应用户请求的速度变慢——用户体验差，我们如何提高数据库的查询效率呢？ 12.1 索引的介绍索引，就是用来提高数据表中数据的查询效率的。 索引，就是将数据表中某一列&#x2F;某几列的值取出来构造成便于查找的结构进行存储，生成数据表的目录 当我们进行数据查询的时候，则先在目录中进行查找得到对应的数据的地址，然后再到数据表中根据地址快速的获取数据记录，避免全表扫描。 12.2 索引的分类MySQL中的索引，根据创建索引的列的不同，可以分为： 主键索引：在数据表的主键字段创建的索引，这个字段必须被primary key修饰，每张表只能有一个主键 唯一索引：在数据表中的唯一列创建的索引(unique)，此列的所有值只能出现一次，可以为NULL 普通索引：在普通字段上创建的索引，没有唯一性的限制 组合索引：两个及以上字段联合起来创建的索引 说明: 在创建数据表时，将字段声明为主键（添加主键约束），会自动在主键字段创建主键索引； 在创建数据表时，将字段声明为唯一键（添加唯一约束），会自动在唯一字段创建唯一索引； 12.3 创建索引12.3.1 唯一索引123-- 创建唯一索引: 创建唯一索引的列的值不能重复-- create unique index &lt;index_name&gt; on 表名(列名);create unique index index_test1 on tb_testindex(tid); 12.3.2 普通索引123-- 创建普通索引: 不要求创建索引的列的值的唯一性-- create index &lt;index_name&gt; on 表名(列名);create index index_test2 on tb_testindex(name); 12.3.3 组合索引123-- 创建组合索引-- create index &lt;index_name&gt; on 表名(列名1,列名2...);create index index_test3 on tb_testindex(tid,name); 12.3.4 全文索引 MySQL 5.6 版本新增的索引，可以通过此索引进行全文检索操作，因为MySQL全文检索不支持中文，因此这个全文索引不被开发者关注，在应用开发中通常是通过搜索引擎（数据库中间件）实现全文检索 1create fulltext index &lt;index_name&gt; on 表名(字段名); 12.4 索引使用 索引创建完成之后无需调用，当根据创建索引的列进行数据查询的时候，会自动使用索引； 组合索引需要根据创建索引的所有字段进行查询时触发。 在 命令行窗口中可以查看查询语句的查询规划： 1explain select * from tb_testindex where tid=250000\\G; 12.5 查看索引12-- 命令行show create table tb_testindex\\G; 12345-- 查询数据表的索引show indexes from tb_testindex;-- 查询索引show keys from tb_testindex; 12.6 删除索引123-- 删除索引：索引是建立在表的字段上的，不同的表中可能会出现相同名称的索引-- 因此删除索引时需要指定表名drop index index_test3 on tb_testindex; 12.7 索引的使用总结12.7.1 优点 索引大大降低了数据库服务器在执行查询操作时扫描的数据，提高查询效率 索引可以避免服务器排序、将随机IO编程顺序IO 12.7.2 缺点 索引是根据数据表列的创建的，当数据表中数据发生DML操作时，索引页需要更新； 索引文件也会占用磁盘空间； 12.7.3 注意事项 数据表中数据不多时，全表扫面可能更快吗，不要使用索引； 数据量大但是DML操作很频繁时，不建议使用索引； 不要在数据重复读高的列上创建索引（性别）； 创建索引之后，要注意查询SQL语句的编写，避免索引失效。 十三、数据库事务13.1 数据库事务介绍 我们把完成特定的业务的多个数据库DML操作步骤称之为一个事务 事务，就是完成同一个业务的多个DML操作 123456789-- 借书业务-- 操作1：在借书记录表中添加记录insert into records(snum,bid,borrow_num,is_return,borrow_date) values(&#x27;1001&#x27;,1,1,0,sysdate());-- 操作2：修改图书库存update books set book_stock=book_stock-1 where book_id=1;-- 转账业务：张三给李四转账1000-- 操作1：李四的帐号+1000-- 操作2：张三的账户-1000 13.2 数据库事务特性 ACID特性，高频面试题 原子性（Atomicity）：一个事务中的多个DML操作，要么同时执行成功，要么同时执行失败 一致性（Consistency）：事务执行之前和事务执行之后，数据库中的数据是一致的，完整性和一致性不能被破坏 隔离性（Isolation）：数据库允许多个事务同时执行（张三借Java书的同时允许李四借Java书），多个必行的事务之间不能相互影响 持久性（Durability）：事务完整之后，对数据库的操作是永久的 13.3 MySQL事务管理13.3.1 自动提交 在MySQL中，默认DML指令的执行时自动提交的，当我们执行一个DML指令之后，自动同步到数据库中 13.3.2 事务管理 开启事务，就是关闭自动提交 在开始事务第一个操作之前，执行start transaction开启事务 依次执行事务中的每个DML操作 如果在执行的过程中的任何位置出现异常，则执行rollback回滚事务 如果事务中所有的DML操作都执行成功，则在最后执行commit提交事务 1234567891011121314151617-- 借书业务-- 【开启事务】（关闭自动提交---手动提交）start transaction;-- 操作1：在借书记录表中添加记录insert into records(snum,bid,borrow_num,is_return,borrow_date) values(&#x27;1007&#x27;,4,2,0,sysdate());-- select aaa;-- 【事务回滚】（清除连接缓存中的操作,撤销当前事务已经执行的操作）-- rollback;-- 操作2：修改图书库存update books set book_stock=book_stock-2 where book_id=4;-- 【提交事务】（将连接缓存中的操作写入数据文件）commit; 13.4 事务隔离级别 数据库允许多个事务并行，多个事务之间是隔离的、相互独立的；如果事务之间不相互隔离并且操作同一数据时，可能会导致数据的一致性被破坏。 MySQL数据库事务隔离级别： 13.4.1 读未提交（read uncommitted）T2可以读取T1执行但未提交的数据；可能会导致出现脏读 脏读，一个事务读取到了另一个事务中未提交的数据 13.4.2 读已提交（read committed）T2只能读取T1已经提交的数据；避免了脏读，但可能会导致不可重复度（虚读） 不可重复度（虚读）: 在同一个事务中，两次查询操作读取到数据不一致 例如：T2进行第一次查询之后在第二次查询之前，T1修改并提交了数据，T2进行第二次查询时读取到的数据和第一次查询读取到数据不一致。 13.4.3 可重复读（repeatable read）T2执行第一次查询之后，在事务结束之前其他事务不能修改对应的数据；避免了不可重复读(虚读)，但可能会导致幻读 幻读，T2对数据表中的数据进行修改然后查询，在查询之前T1向数据表中新增了一条数据，就导致T2以为修改了所有数据，但却查询出了与修改不一致的数据（T1事务新增的数据） 13.4.4 串行化(serializable)同时只允许一个事务对数据表进行操作；避免了脏读、虚读、幻读问题 隔离级别 脏读 不可重复读(虚读) 幻读 read uncommitted √ √ √ read committed × √ √ repeatable read × × √ serializable × × × 13.4.5 设置数据库事务隔离级别 我们可以通过设置数据库默认的事务隔离级别来控制事务之间的隔离性； 也可以通过客户端与数据库连接设置来设置事务间的隔离性（在应用程序中设置–Spring）； MySQL数据库默认的隔离级别为可重复读 查看MySQL数据库默认的隔离级别 123456-- 在MySQL8.0.3 之前select @@tx_isolation;-- 在MySQL8.0.3 之后select @@transaction_isolation; 设置MySQL默认隔离级别 1set session transaction isolation level &lt;read committed&gt;; 十四、数据库设计 MySQL数据库作为数据存储的介质为应用系统提供数据存储的服务，我们如何设计出合理的数据库、数据表以满足应用系统的数据存储需求呢？ 车库：是用来存放车辆的，车库都需要划分车位，如果不划分车位，车子杂乱无章的存放可能会导致车辆堵塞，同时也可能造成场地的浪费——有限的场地能够停放最多的车辆，同时方便每一辆车的出入 数据库，是用来存放数据的，我们需要设计合理的数据表——能够完成数据的存储，同时能够方便的提取应用系统所需的数据 14.1 数据库设计流程 数据库是为应用系统服务的，数据库存储什么样的数据也是由应用系统来决定的。 当我们进行应用系统开发时，我们首先要明确应用系统的功能需求——软件系统的需求分析 根据应用系统的功能，分析数据实体(实体，就是要存储的数据对象) 电商系统：商品、用户、订单…. 教务管理系统：学生、课程、成绩… 提取实体的数据项（数据项，就是实体的属性） 商品(商品名称、商品图片、商品描述…) 用户(姓名、登录名、登录密码…) 根据数据库设计三范式规范视图的数据项 检查实体的数据项是否满足数据库设计三范式 如果实体的数据项不满足三范式，可能会导致数据的冗余，从而引起数据维护困难、破坏数据一致性等问题 绘制E-R图 （实体关系图，直观的展示实体与实体之间的关系） 数据库建模 三线图进行数据表设计 PowerDesigner PDMan 建库建表 编写SQL指令创建数据库、数据表 添加测试数据，SQL测试 14.2 数据库设计案例 学校图书馆图书管理系统（借书） 14.2.1 数据实体 学生 类别 图书 借书记录 管理员 14.2.2 提取数据项 学生（学号、姓名、性别、年龄、院系编号） 院系（院系编号、院系名称、院系说明…） 类别（类别ID，类别名称，类别描述） 图书（图书ID，图书名称，图书作者，图书封面，图书价格，图书库存…） 借书记录（记录ID，学号，图书编号，数量，是否归还，借书日期，还书日期） 管理员（管理员ID，登录名，登录密码，员工编号） 员工（员工编号，员工姓名，手机，qq，邮箱） 14.2.3 数据库设计三范式第一范式：要求数据表中的字段（列）不可再分 以下表不满足第一范式（在数据库中创建不出不满足第一范式的表） 将细分的列作为单独的一列： 第二范式：不存在非关键字段对关键字段的部分依赖 以下表不满足第二范式 将每个关键字段列出来\\关键字段的组合也列出来，依次检查每个非关键字段 第三范式：不存在非关键字段之间的传递依赖 以下数据表不满足第三范式 将关键字段和被依赖的非关键字段分别作为主键，依次检查所有的非关键字段的依赖关系 14.2.4 数据库建模（E-R图） E-R (Entity-Relationship) 实体关系图，用于直观的体现实体与实体之间的关联关系（一对一、一对多、多对一、多对多） E-R图基本图例 E-R图示例 三线图 统一数据实体的表结构 每个实体创建一张数据表 多对多关联：需额外常见一个数据表维护关系，关系表分别创建外键与两张表关联 一对多、多对一关联：在多的一端添加外键与一的一端的主键建立主外键约束 一对一关联：在任意一端创建外键与另一端建立主外键关联，并且将外键设置为unique 14.2.5 数据库建模（PD） E-R图实际上就是数据模建模的一部分： E-R 图 数据表设计 建库建表 PowerDesigner建模工具 导出数据表 PDMan建模工具 下载并安装PowerDesigner建模工具 PowerDesigner使用 概念数据模型（选择workspace–右键new–Conceptual Data Model），相当于E-R 逻辑数据模型（打开概念数据模型–tools–Generate Logical Data Model）,体现了实体的主外键关联 物理数据模型（打开逻辑数据模型–tools–Generate Physical Data Mode—选择数据库类型及版本） 可以对物理数据模型进行微调 可以通过物理数据模型生成建库建表的SQL语句（在物理数据模型的窗口中—-Database工具条—Generate Database–生成SQL文件） 通过数据库的管理工具执行SQL文件就可以完成数据表的创建 面向对象模型（打开概念数据模型&#x2F;逻辑数据模型&#x2F;物理数据模型—tools–Generate Object-Orentited Model） 可以根据语言设置，生成实体类（Java） 如果想要借助于PD建模工具生成Java代码，创建概念的模型时实体名、属性名都要符合Java程序的命名规范。 在企业项目开发，我们通常是不会使用建模工具来生成数据表、实体类的，因为生成的代码规范不合乎我们的代码需求 14.2.6 数据库建模（PDMan） 下载安装PDMan 创建项目——在项目中创建数据表 在项目中生成关系图","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"day10-jQuery","slug":"day10-jQuery","date":"2022-09-16T15:30:55.000Z","updated":"2022-10-01T03:02:44.913Z","comments":true,"path":"2022/09/16/day10-jQuery/","link":"","permalink":"http://example.com/2022/09/16/day10-jQuery/","excerpt":"","text":"一、jQuery简介1.1 web前端的知识回顾 HTML 决定了网页的内容 CSS 决定了标签的样式 JavaScript 决定了网页的功能：对标签属性、样式的操作、DOM节点操作、ajax异步交互 在使用JS完成对应功能时，需要程序员自行完成代码的编写，开发相对还是比较繁琐的 1.2 jQuery什么？ jQuery就是一个JavaScript的框架，简化了JS的语法和操作，定义了HTML属性操作、样式操作、DOM操作等相关函数，实现了对ajax异步请求封装。 jQuery就是一个提供了很多预定义函数的JS文件。 二、jQuery入门使用2.1 下载jQuery函数库官网：https://jquery.com/ 下载：https://jquery.com/download/ 2.2 在网页中引入jQuery文件2.2.1 本地文件引入 先下载jquery.js文件 将jquery.js文件拷贝粘贴到web项目中 在html文件或者jsp文件，通过script标签引入jQuery文件 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 引入jQuery --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2.2.2 CDN引入 CDN 内容分发网络，将jQuery.js文件提前部署到一个服务器，我们可以通过jquery文件在服务器上的访问路径来引入此jquery.js文件： jQuery官方提供的CDN地址： http://code.jquery.com/jquery-3.6.0.js http://code.jquery.com/jquery-3.6.0.min.js 在html、jsp文件中,通过script标签直接引入jquery的cdn地址即可 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 引入jQuery --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://code.jquery.com/jquery-3.6.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2.3 jQuery入门示例 使用示例：点击按钮隐藏图片 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 引入jQuery --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://code.jquery.com/jquery-3.6.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=&quot;img1&quot; src=&quot;imgs/img01.png&quot; height=&quot;200&quot;/&gt;&lt;br/&gt; &lt;button id=&quot;btn&quot;&gt;测试&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; //点击按钮隐藏图片 $(&quot;#btn&quot;).click(function()&#123; $(&quot;#img1&quot;).hide(); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 三、jQuery API https://www.94xh.com/index.html 3.1 核心函数 jQuery()函数，选择器函数， 用于获取HTML文档中的元素 ，简写为 $() jQuery([selector,[context]]) 根据特定的规则从HTML文档中获取元素(特定的规则：选择器语法) 12$(&quot;#btn&quot;); //获取当前文档中id=btn的元素$(&quot;.inputStyle&quot;); //获取当前文档中class=inputStyle的元素 **jQuery(html,[ownerDocument]) **创建一个新的HTML元素 1$(&quot;&lt;textarea&gt;&lt;/textarea&gt;&quot;) jQuery(fn) 表示当网页文档加载完毕执行fn, 等价于 jQuery(document).ready(fn). 123456$(function()&#123; //给id=btn的按钮绑定点击事件 $(&quot;#btn&quot;).click(function()&#123; alert(111); &#125;);&#125;); $(selector).事件(fn): 当选择器选择的元素发生对应的事件就执行fn 12345//1.当前文档加载完毕执行fn$(document).ready(fn);//2.当id=btn的元素发生点击事件，就执行fn$(&quot;#btn&quot;).click(fn); 3.2 选择器 在 jQuery()函数的参数中传递不同的选择器表达式，就可以获取网页文档中不同的元素 3.2.1 基本选择器 ID选择器： $(“#id”) 12// 获取网页文档中id=btn的元素，相当于 document.getElementById(&quot;id&quot;)$(&quot;#btn&quot;) 标签选择器： $(“tagName”) 12// 获取网页文档中所有的img标签元素，相当于 document.getElementsByTagName(&quot;tagName&quot;);$(&quot;img&quot;) class选择器： $(“.class”) 12//获取网页文档中所有class=inputStyle的元素,相当于 document.getElementsByClassName(&quot;inputStyle&quot;)$(&quot;.inputStyle&quot;) 3.2.2 复合选择器 复合选择器——将多个基本选择器通过特定的符号进行连接，以实现更为精确的选择 $(“selector1 selector2”) 选择所有selector1 匹配的元素里面的匹配selector2的元素 $(“selector1,selector2”) 选择所有匹配selector1和selector2的元素（并集） $(“selector1 &gt; selector2”) 选择匹配selector1元素的子标签中匹配selector2的元素 $(“selector1 + selector2”) 匹配所有紧接在 selector1 元素后的 selector2元素 $(“selector1 ~ selector2”) 匹配所有在 selector1 元素后的 selector2元素 3.2.3 选择器筛选 在选择器匹配的元素中根据特定的筛选条件（索引、属性）更灵活的选择要操作的元素 选择器筛选语法 说明 $(“selector:first“) 匹配selector选择的元素集合中的第一个 $(“selector:last“) 匹配selector选择的元素集合中的最后一个 $(“selector:odd“) 匹配selector选择的元素集合中索引为奇数的元素(1,3,5,7,…) $(“selector:even“) 匹配selector选择的元素集合中索引为偶数的元素(0,2,4,6,…) $(“selector:eq(index)“) 匹配selector选择的元素集合中索引为index的元素 $(“selector:lt(index)“) 匹配selector选择的元素集合中索引小于index的元素 $(“selector:gt(index)“) 匹配selector选择的元素集合中索引大于index的元素 $(“selector[attrName=attrValue]“) 匹配selector选择的元素集合中attrName属性值为attrValue的元素 $(“selector[attrName!=attrValue]“) 3.3 筛选函数 jQuery中提供了一些函数，对选择器匹配的元素集合进行筛选 筛选函数 说明 $(“selector”).first() 从选择器匹配的元素集合中选择第一个元素 $(“selector”).last() 从选择器匹配的元素集合中选择最后一个元素 $(“selector”).eq(index) 匹配selector选择的元素集合中索引为index的元素 $(“input”).each(function(){ var r &#x3D; $(this).hasClass(&quot;inputStyle1&quot;); console.log(r);}); 判断某个元素是否有class&#x3D;’inputStyle1’,返回boolean $(“selector1”).filter(&quot;selector2&quot;) 从selector1匹配的元素集合中选择匹配selector2的元素 $(“selector”).is(tag) 判断选择器选择的元素是否为指定的标签 $(“selector1”).find(selector2) 从selector1匹配的元素集合中的元素里面，选择匹配selector2的元素 3.4 属性操作函数 jQuery提供了一组函数用于对HTML标签进行属性操作 attr(): 获取&#x2F;设置元素属性 1234567//1.获取元素属性值var v1 = $(&quot;img&quot;).attr(&quot;src&quot;);var v2 = $(&quot;img&quot;).attr(&quot;width&quot;);//2.设置元素属性$(&quot;img&quot;).attr(&quot;src&quot;,&quot;imgs/img02.png&quot;);$(&quot;img&quot;).attr(&quot;width&quot;,200); val()：获取&#x2F;设置元素的value属性值 12345//1.获取元素value属性值var v3 = $(&quot;#userName&quot;).val();//2.设置元素的value属性值$(&quot;#userName&quot;).val(&quot;这是设置的值&quot;); removeAttr(&#39;属性名&#39;)：移除元素属性 12//removeAttr() 移除元素属性$(&quot;img&quot;).removeAttr(&quot;width&quot;); prop(&#123;&#125;):同时设置元素的多个属性 1$(&quot;#img2&quot;).prop(&#123;width:200,src:&quot;imgs/img03.png&quot;,alt:&quot;看不到吗？&quot;&#125;); addClass(styleName)、removeClass(styleName)、toggleClass(styleName) 操作标签class属性值 12345678//addClass() 为元素class属性添加一个样式名$(&quot;#div1&quot;).addClass(&quot;style1&quot;);//removeClass() 删除元素class属性中指定的样式名$(&quot;#div1&quot;).removeClass(&quot;style2&quot;);//toggleClass 从元素的class属性中添加/移除指定的样式名$(&quot;#div1&quot;).toggleClass(&quot;style1&quot;); text()、html() 相当于innerHTML操作 text(“”) : 将参数以文本的形式设置到选择器匹配元素的里面，即使设置的内容是HTML标签，也不会当成标签解析 html(“”) : 将参数以HTML标签的形式设置到匹配的元素里面，参数内容会被浏览器解析为HTML标签，显示对应的标签效果。 12$(&quot;#div2&quot;).html(&quot;&lt;img src=&#x27;imgs/img02.png&#x27; height=&#x27;80&#x27;/&gt;&quot;); //会在div中显示一张图片$(&quot;#div2&quot;).text(&quot;&lt;img src=&#x27;imgs/img02.png&#x27; height=&#x27;80&#x27;/&gt;&quot;); //会将参数直接以文本形式显示出来 3.5 样式操作函数 css() 设置&#x2F;获取元素的样式属性 123456789//1.设置标签的样式$(&quot;#div1&quot;).css(&quot;width&quot;,&quot;200px&quot;);$(&quot;#div1&quot;).css(&quot;height&quot;,&quot;200px&quot;);$(&quot;#div1&quot;).css(&quot;border&quot;,&quot;1px red solid&quot;);//多个样式也可以一起设置$(&quot;#div1&quot;).css(&#123;width:&quot;100px&quot;,height:&quot;100px&quot;,background:&quot;#ff0000&quot;&#125;);//2.获取标签指定的样式var v = $(&quot;#div1&quot;).css(&quot;height&quot;); position() 获取元素的位置信息 123var position = $(&quot;#div1&quot;).position();console.log(position.top);console.log(position.left); 获取尺寸的函数： width() &#x2F; height(); innerWitdh() &#x2F; innerHeight(); outerWidth()&#x2F; outerHeight(); 3.6 文档处理函数 DOM操作 3.6.1 添加子节点 append appendTo 1234567// parent.append(child) : 在父节点中拼接子节点 (子节点会添加到父节点中的最后)// child可以是一个HTML标签字符串，表示新建一个HTML元素拼接到parent// child也可以是通过选择器选择的当前文档中的元素（被选择的元素发生移动）$(&quot;#div1&quot;).append(&quot;&lt;img src=&#x27;imgs/img03.png&#x27; height=&#x27;100&#x27;/&gt;&quot;);// child.appendTo(parent) : 将子节点拼接到父节点里面$(&quot;&lt;img src=&#x27;imgs/img03.png&#x27; height=&#x27;100&#x27;/&gt;&quot;).appendTo($(&quot;#div1&quot;)); 3.6.2 插入节点 before insertBefore 12345// node1.before(node2): 在node1的前面插入node2$(&quot;#img2&quot;).before(&quot;&lt;img src=&#x27;imgs/img03.png&#x27; height=&#x27;100&#x27;/&gt;&quot;);// node2.insertBefore(node1): 将node2插入到node1之前$(&quot;&lt;img src=&#x27;imgs/img03.png&#x27; height=&#x27;100&#x27;/&gt;&quot;).insertBefore($(&quot;#img2&quot;)); after insertAfter 12345// node1.after(node2) : 在node1的后面插入node2//$(&quot;#img1&quot;).after(&quot;&lt;img src=&#x27;imgs/img03.png&#x27; height=&#x27;100&#x27;/&gt;&quot;);node2.insertAfter(node1): 将node2插入到node1的后面$(&quot;&lt;img src=&#x27;imgs/img03.png&#x27; height=&#x27;100&#x27;/&gt;&quot;).insertAfter($(&quot;#img1&quot;)); 3.6.3 替换节点 replaceWith 12// node1.replaceWith(node2) : 使用node2替换node1$(&quot;#img2&quot;).replaceWith(&quot;&lt;img src=&#x27;imgs/img03.png&#x27; height=&#x27;100&#x27;/&gt;&quot;); 3.6.4 删除节点 empty 123//parent.empty():清楚当前标签中所有的子标签$(&quot;#div1&quot;).empty();$(&quot;body&quot;).empty(); remove 12// node.remove() :删除当前节点$(&quot;#img1&quot;).remove(); 3.6.5 节点包裹 wrap unwrap 12345//node1.wrap(node2) : 使用node2将node1包裹起来$(&quot;#img3&quot;).wrap(&quot;&lt;div style=&#x27;border:2px pink solid&#x27;&gt;&lt;/div&gt;&quot;)//node.unwrap() : 删除当前标签的父标签$(&quot;#img4&quot;).unwrap(); 3.7 事件函数 用于为页面中的元素绑定事件 元素事件绑定语法： 123456$(&quot;selector&quot;).事件函数(fn);//例如: 当id=btn的元素发生点击事件时，就执行对应的fn$(&quot;#btn&quot;).click(function()&#123; &#125;); 3.7.1 文档加载事件 ready() 文档加载完毕时触发 123$(document).ready(function()&#123; //alert(1);&#125;); 3.7.2 焦点事件 blur() 元素失去焦点时触发 123$(&quot;#userName&quot;).blur(function()&#123; console.log(&quot;---输入框失去焦点&quot;);&#125;); focus() 元素获得焦点时触发 123$(&quot;#userName&quot;).focus(function()&#123; console.log(&quot;---输入框获得焦点&quot;);&#125;); 3.7.3 鼠标事件 mousedown() 鼠标左键按下 mouseup() 鼠标左键松开 mouseenter() 鼠标指针穿过 mouseleave() 鼠标离开 （与 mouseout 事件不同，只有在鼠标指针离开被选元素时，才会触发 mouseleave 事件。如果鼠标指针离开任何子元素，同样会触发 mouseout 事件) mouseout() 鼠标离开 mouseover() 鼠标指针移到元素上 mousemove() 鼠标指针在元素上移动 3.7.4 键盘事件 keydown() 按键按下 keyup() 按键松开 3.7.5 点击事件 click() 鼠标单击事件 123$(&quot;#btn&quot;).click(function()&#123; alert(666);&#125;); dbclick() 鼠标双击事件 3.7.6 内容改变 change() 输入框或下拉菜单等内容被改变 1234567891011&lt;select id=&quot;city&quot;&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;武汉&quot;&gt;武汉&lt;/option&gt;&lt;/select&gt;&lt;script type=&quot;text/javascript&quot;&gt; //输入框 和 下拉菜单 等内容可被改变的元素 $(&quot;#city&quot;).change(function()&#123; console.log(&quot;内容被改变了&quot;); &#125;);&lt;/script&gt; 3.7.7 关闭&#x2F;打开事件 off(“事件名称”) 关闭元素的事件 on(“事件名称”,fn) 重新打开&#x2F;绑定元素的事件 123456789101112131415161718192021222324252627&lt;button id=&quot;btn2&quot;&gt;关闭事件&lt;/button&gt;&lt;button id=&quot;btn3&quot;&gt;打开事件&lt;/button&gt;&lt;select id=&quot;city&quot;&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;武汉&quot;&gt;武汉&lt;/option&gt;&lt;/select&gt; &lt;script type=&quot;text/javascript&quot;&gt; //输入框 和 下拉菜单 等内容可被改变的元素 $(&quot;#city&quot;).change(function()&#123; console.log(&quot;内容被改变了&quot;); &#125;); //关闭事件 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;#city&quot;).off(&quot;change&quot;); &#125;); //重新打开事件 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;#city&quot;).on(&quot;change&quot;,function()&#123; console.log(&quot;重新被打开的change事件&quot;); &#125;); &#125;);&lt;/script&gt; 3.7.8 获取事件对象 在事件函数的参数fn添加一个参数，可以获取当前事件的event对象 12345$(&quot;#city&quot;).change(function(event)&#123; //event表示事件对象 console.log(event); //$(this)表示发生事件的元素&#125;); 3.8 效果函数 元素的隐藏与显示 动画 3.8.1 隐藏与显示 以下显示与隐藏的函数都可以设置一个时间参数，用于设置显示隐藏的速度 时间参数可以是slow \\normal\\fast 单词 也可以是具体的数值，单位ms 1. show&#x2F;hide&#x2F;toggle 瞬间显示与隐藏 123456789101112131415161718192021222324&lt;img src=&quot;imgs/img01.png&quot; height=&quot;200&quot; /&gt;&lt;img src=&quot;imgs/img02.png&quot; height=&quot;200&quot; /&gt;&lt;img src=&quot;imgs/img03.png&quot; height=&quot;200&quot; /&gt;&lt;hr&gt;&lt;button id=&quot;btn1&quot;&gt;测试hide()&lt;/button&gt;&lt;button id=&quot;btn2&quot;&gt;测试show()&lt;/button&gt;&lt;button id=&quot;btn3&quot;&gt;测试toggle()&lt;/button&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; // hide() 隐藏 $(&quot;#btn1&quot;).click(function()&#123; $(&quot;img&quot;).hide(); &#125;); // show() 显示 $(&quot;#btn2&quot;).click(function()&#123; $(&quot;img&quot;).show(); &#125;); // toggle() 如果原来显示就执行隐藏，如果原来隐藏就执行显示 $(&quot;#btn3&quot;).click(function()&#123; $(&quot;img&quot;).toggle(); &#125;);&lt;/script&gt; 2.slideDown&#x2F;slideUp&#x2F;slideToggle 放大缩小的显示与隐藏 12345678910111213141516171819&lt;button id=&quot;btn4&quot;&gt;测试slideUp()&lt;/button&gt;&lt;button id=&quot;btn5&quot;&gt;测试slideDown()&lt;/button&gt;&lt;button id=&quot;btn6&quot;&gt;测试slideToggle()&lt;/button&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; // slideUp() 缩起来 $(&quot;#btn4&quot;).click(function()&#123; $(&quot;img&quot;).slideUp(); &#125;); // slideDown() 展开 $(&quot;#btn5&quot;).click(function()&#123; $(&quot;img&quot;).slideDown(); &#125;); // slideToggle() 如果原来显示就执行隐藏，如果原来隐藏就执行显示 $(&quot;#btn6&quot;).click(function()&#123; $(&quot;img&quot;).slideToggle(); &#125;);&lt;/script&gt; 3.fadeOut&#x2F;fadeIn&#x2F;fadeToggle&#x2F;fadeTo 淡入淡出的显示与隐藏 1234567891011121314151617181920212223242526&lt;button id=&quot;btn7&quot;&gt;测试fadeOut()&lt;/button&gt;&lt;button id=&quot;btn8&quot;&gt;测试fadeIn()&lt;/button&gt;&lt;button id=&quot;btn9&quot;&gt;测试fadeToggle()&lt;/button&gt;&lt;button id=&quot;btn10&quot;&gt;测试fadeTo()&lt;/button&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; //fadeOut 淡出 $(&quot;#btn7&quot;).click(function()&#123; $(&quot;img&quot;).fadeOut(); &#125;); //fadeIn 淡入 $(&quot;#btn8&quot;).click(function()&#123; $(&quot;img&quot;).fadeIn(); &#125;); //fadeToggle $(&quot;#btn9&quot;).click(function()&#123; $(&quot;img&quot;).fadeToggle(); &#125;); //fadeTo 将元素的透明度改变到指定的值 // 参数1：速度 // 参数2：透明度 $(&quot;#btn10&quot;).click(function()&#123; $(&quot;img&quot;).fadeTo(3000,0.5); &#125;); &lt;/script&gt; 3.8.2 动画播放与停止 animate stop 12345678910111213141516171819&lt;img src=&quot;imgs/img01.png&quot; id=&quot;img4&quot; style=&quot;width: 200px; height: 200px; border-radius: 50%&quot; /&gt;&lt;button id=&quot;btn11&quot;&gt;测试动画&lt;/button&gt;&lt;button id=&quot;btn12&quot;&gt;停止动画&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; //params:一组包含作为动画属性和终值的样式属性和及其值的集合 //speed:三种预定速度之一的字符串(&quot;slow&quot;,&quot;normal&quot;, or &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000) //easing:要使用的擦除效果的名称(需要插件支持).默认jQuery提供&quot;linear&quot; 和 &quot;swing&quot;. //fn:在动画完成时执行的函数，每个元素执行一次。 $(&quot;#btn11&quot;).click(function()&#123; $(&quot;#img4&quot;).animate(&#123;width:&quot;300px&quot;,height:&quot;300px&quot;&#125;,5000); $(&quot;#img4&quot;).animate(&#123;width:&quot;100px&quot;,height:&quot;100px&quot;&#125;,5000); &#125;); $(&quot;#btn12&quot;).click(function()&#123; //在动画完成之前执行stop,，就让动画停止下来，保持当前状态 $(&quot;#img4&quot;).stop(); &#125;);&lt;/script&gt; 3.9 AJAX3.9.1 ajax()函数1234567891011121314151617181920$.ajax(&#123; url:&quot;请求url?param1=v1&quot;, //url ajax请求的目标服务器地址 type:&quot;get|post&quot;, //type 指定请求方式（get|post） headers:&#123; //headers 设置请求头参数 key1:&quot;value1&quot;, key2:&quot;value2&quot; &#125;, data:&#123; //data 传递的参数 userName:&quot;zhangsan&quot;, userPwd:&quot;123456&quot; &#125;, contentType:&quot;application/json&quot;, //contentType 请求信息的转码方式 processData:false, //processData 设置数据是否压缩传输（文件上传设置为false） success:function(res)&#123; //success ajax请求成功之后执行的回调函数，参数res就是服务器返回的数据 &#125;, error:function(e)&#123; //error ajax请求出现错误执行的回调函数，参数e表示异常信息对象 &#125;&#125;); 3.9.2 jQuery的异步交互实例 验证用户是否可用 (将jquery.js文件拷贝到java web工程) 1.regist.jsp1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.6.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;用户注册&lt;/h3&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;p&gt; 帐号：&lt;input type=&quot;text&quot; id=&quot;userName&quot;/&gt;&lt;label id=&quot;tipsLabel&quot;&gt;&lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;检测&quot; id=&quot;checkBtn&quot;/&gt; &lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot;/&gt;&lt;/p&gt; &lt;p&gt;确认密码：&lt;input type=&quot;password&quot;/&gt;&lt;/p&gt; &lt;p&gt;姓名：&lt;input type=&quot;text&quot;/&gt;&lt;/p&gt; &lt;p&gt;电话：&lt;input type=&quot;text&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交注册&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;#checkBtn&quot;).click(function()&#123; //发送ajax请求，验证用户名是否可用 var name = $(&quot;#userName&quot;).val(); $.ajax(&#123; url:&quot;CheckUserNameServlet?userName=&quot;+name, //url传递用户名 type:&quot;get&quot;, success:function(res)&#123; if(res.code == 1000)&#123; $(&quot;#tipsLabel&quot;).replaceWith(&quot;&lt;label id=&#x27;tipsLabel&#x27; style=&#x27;color:green&#x27;&gt;用户名可用！&lt;/label&gt;&quot;); &#125;else&#123;$(&quot;#tipsLabel&quot;).replaceWith(&quot;&lt;label id=&#x27;tipsLabel&#x27; style=&#x27;color:red&#x27;&gt;用户名不可用！&lt;/label&gt;&quot;); &#125; &#125; &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.CheckUserNameServlet1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Description 验证用户名是否可用 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/CheckUserNameServlet&quot;)public class CheckUserNameServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收用户名 String name = request.getParameter(&quot;userName&quot;); //2.判断是否可用 boolean b = !name.startsWith(&quot;admin&quot;); //3.响应ajax请求 response.setContentType(&quot;application/json;charset=utf-8&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); String jsonStr = b ? &quot;&#123;\\&quot;code\\&quot;:1000,\\&quot;msg\\&quot;:\\&quot;success\\&quot;&#125;&quot;:&quot;&#123;\\&quot;code\\&quot;:1001,\\&quot;msg\\&quot;:\\&quot;fail\\&quot;&#125;&quot;; // &#123;&quot;code&quot;:1000,&quot;msg&quot;:&quot;success&quot;&#125; &#123;&quot;code&quot;:1001,&quot;msg&quot;:&quot;fail&quot;&#125; PrintWriter out = response.getWriter(); out.println(jsonStr); out.flush(); out.close(); &#125;&#125; 3.9.2 get(url,params,fn,type)发送get方式的异步请求 1234567891011// 参数1：请求的url// 参数2：传递的参数// 参数3：回调函数// 参数4：服务器返回的数据的格式 （json,html,text,xml）$.get(&quot;CheckUserNameServlet&quot;,&#123;userName:name&#125;,function(res)&#123; if(res.code == 1000)&#123; $(&quot;#tipsLabel&quot;).replaceWith(&quot;&lt;label id=&#x27;tipsLabel&#x27;&gt;用户名可用！&lt;/label&gt;&quot;); &#125;else&#123; $(&quot;#tipsLabel&quot;).replaceWith(&quot;&lt;label id=&#x27;tipsLabel&#x27;&gt;用户名不可用！&lt;/label&gt;&quot;); &#125;&#125;,&quot;json&quot;); 3.9.3 post(url,params,fn,type)发送post方式的异步请求 1234567891011// 参数1：请求的url// 参数2：传递的参数// 参数3：回调函数// 参数4：服务器返回的数据的格式 （json,html,text,xml）$.post(&quot;CheckUserNameServlet&quot;,&#123;userName:name&#125;,function(res)&#123; if(res.code == 1000)&#123; $(&quot;#tipsLabel&quot;).replaceWith(&quot;&lt;label id=&#x27;tipsLabel&#x27;&gt;用户名可用！&lt;/label&gt;&quot;); &#125;else&#123; $(&quot;#tipsLabel&quot;).replaceWith(&quot;&lt;label id=&#x27;tipsLabel&#x27; &gt;用户名不可用！&lt;/label&gt;&quot;); &#125;&#125;,&quot;json&quot;);","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"}]},{"title":"day09-AJAX","slug":"day09-AJAX","date":"2022-09-16T15:30:37.000Z","updated":"2022-09-29T05:48:14.899Z","comments":true,"path":"2022/09/16/day09-AJAX/","link":"","permalink":"http://example.com/2022/09/16/day09-AJAX/","excerpt":"","text":"AJAX异步交互技术 一、AJAX简介1.1 概念 AJAX “Asynchronous JavaScript And XML” 异步JS与XML，指的是在网页使用JavaScript脚本实现前端与服务器的异步交互技术。 在不刷新前端网页的前提下实现和服务器的数据交互 ajax不是一种编程语言，而是使用JavaScript代码实现前端和后端异步数据交互的技术。 1.2 同步与异步 同步请求 异步请求 1.3 异步交互的使用场景 异步交互技术: 适用于网页中显示大量的数据，同时我们只想对一小部分数据进行更新(大部分数据是不更新)的场景 首页登录（系统首页有大量的信息显示，用户需要登录可以使用异步交互完成，避免首页刷新导致重新加载页面中的所有数据） 表单填写中：省市区联动 注册功能中：检测用户名是否可用 二、AJAX实现2.1 ajax异步交互的实现流程 2.2 ajax的代码实现2.2.1 ajax实现案例准备 创建java web工程 创建注册页面 regist.jsp 12345678910111213141516171819&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;用户注册&lt;/h3&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;p&gt;帐号：&lt;input type=&quot;text&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;检测&quot;/&gt; &lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot;/&gt;&lt;/p&gt; &lt;p&gt;确认密码：&lt;input type=&quot;password&quot;/&gt;&lt;/p&gt; &lt;p&gt;姓名：&lt;input type=&quot;text&quot;/&gt;&lt;/p&gt; &lt;p&gt;电话：&lt;input type=&quot;text&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交注册&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 创建检测用户名的Servlet类 123456789101112131415161718192021222324252627282930313233343536package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Description 检测注册页面输入的用户名是否可用 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/CheckUserNameServlet&quot;)public class CheckUserNameServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收用户名 String userName = request.getParameter(&quot;userName&quot;); //2.检查用户名是否存在（查数据库） // 测试规则：只要用户名不是以admin开头就都可以使用 boolean r = !userName.startsWith(&quot;admin&quot;); //3.响应 &#125;&#125; 2.2.2 创建ajax请求对象1. 判断浏览器 window.XMLHttpRequest 2. 创建AJAX对象 IE7+、FF、O、Safari、Chrome 1var ajaxReq = new XMLHttpRuquest(); IE5\\IE6 1var ajaxReq = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 2.2.3 封装ajax请求数据 open(method,url,asyn) method表示异步请求的请求方式 （GET|POST） url 异步请求的目标路径 asyn 是否异步（true异步，false同步） 封装参数： get请求，通过url传递参数 1ajaxReq.open(&quot;GET&quot;,&quot;url?key=value&amp;key2=value2&quot;,true); post请求，可以通过url传参，也可以通过请求正文传参 1ajaxReq.open(&quot;POST&quot;,&quot;url?key=value&amp;key2=value2&quot;,true); 1234//在封装请求数据时不设置参数ajaxReq.open(&quot;POST&quot;,&quot;url&quot;,true);//在发送请求时，使用请求正文传递参数ajaxReq.send(&quot;key1=value1&amp;key2=value2&quot;) 2.2.4 指定ajax回调函数 ajaxReq请求对象是有状态的，可以通过ajaxReq.readyState获取状态值 ajaxReq请求对象的不同状态值表示异步交互的不同阶段 ajaxReq.readyState &#x3D;&#x3D; 0 表示ajax请求对象完成创建但并未初始化 ajaxReq.readyState &#x3D;&#x3D; 1 表示ajax请求对象完成初始化但未发送请求 ajaxReq.readyState &#x3D;&#x3D; 2 表示ajax请求已经发送并到达服务器 ajaxReq.readyState &#x3D;&#x3D; 3 表示服务器正在处理ajax请求（通信….） ajaxReq.readyState &#x3D;&#x3D; 4 表示服务器正处理完成，ajax请求对象已经成功获取响应结果 指定回调函数： 123456789//只要ajax请求状态发送变化，就会触发这个回调函数的执行ajaxReq.onreadystatechange = callback;//回调函数：处理结果function callback()&#123; if(ajaxReq.readyState == 4)&#123; //获取结果 &#125;&#125; 2.2.5 发送ajax请求 通过ajax请求对象调用send(body) 如果请求方式为GET 1ajaxReq.send(null); 如果请求方式为POST 12ajaxReq.send(null);ajaxReq.send(&quot;key1=value1&amp;key2=value2&quot;) 2.2.6 Servlet类响应ajax请求123456//3.通过response的输出流、响应ajax请求response.setCharacterEncoding(&quot;utf-8&quot;);PrintWriter out = response.getWriter();out.println(str);out.flush();out.close(); 2.2.7 在回调函数中获取结果1234567891011121314function callback()&#123; //获取服务器响应结果的两个条件： //1.异步请求完成 ajaxReq.readyState == 4 //2.http状态为200 ajaxReq.status == 200 if(ajaxReq.readyState == 4 &amp;&amp; ajaxReq.status == 200)&#123; //获取结果 // 如果服务器响应的是文本数据（字符串），使用responseText属性接收 var result = ajaxReq.responseText; // 如果服务器响应的是XML文件，使用responseXML属性接收 // var doc = ajaxReq.responseXML; // 将获取的响应结果显示到网页的标签中 document.getElementById(&quot;tipsLabel&quot;).innerHTML = result; &#125;&#125; 2.2.8 验证用户名案例代码1.regist.jsp123456789101112131415161718192021&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/test.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;用户注册&lt;/h3&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;p&gt; 帐号：&lt;input type=&quot;text&quot; id=&quot;userName&quot;/&gt;&lt;label id=&quot;tipsLabel&quot;&gt;&lt;/label&gt; &lt;input type=&quot;button&quot; value=&quot;检测&quot; onclick=&quot;checkUserName()&quot;/&gt; &lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot;/&gt;&lt;/p&gt; &lt;p&gt;确认密码：&lt;input type=&quot;password&quot;/&gt;&lt;/p&gt; &lt;p&gt;姓名：&lt;input type=&quot;text&quot;/&gt;&lt;/p&gt; &lt;p&gt;电话：&lt;input type=&quot;text&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交注册&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 2.test.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var ajaxReq;function checkUserName()&#123; //发送ajax请求到CheckUserNameServlet，并将用户名传递 //1、创建ajax请求对象 if(window.XMLHttpRequest)&#123; ajaxReq = new XMLHttpRequest(); &#125;else&#123; ajaxReq = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; console.log(&quot;---------&quot;+ajaxReq.readyState); //2、封装ajax请求数据（初始化） var userName = document.getElementById(&quot;userName&quot;).value; var method = &quot;GET&quot;; var url = &quot;CheckUserNameServlet?userName=&quot;+userName; var async = true; ajaxReq.open(method,url,async); console.log(&quot;---------&quot;+ajaxReq.readyState); //3、指定ajax请求的回调函数 // ajaxReq请求对象是有状态的，可以通过ajaxReq.readyState获取状态值 // ajaxReq请求对象的不同状态值表示异步交互的不同阶段 // ajaxReq.readyState == 0 表示ajax请求对象完成创建但并未初始化 // ajaxReq.readyState == 1 表示ajax请求对象完成初始化但未发送请求 // ajaxReq.readyState == 2 表示ajax请求已经发送并到达服务器 // ajaxReq.readyState == 3 表示服务器正在处理ajax请求（通信....） // ajaxReq.readyState == 4 表示服务器正处理完成，ajax请求对象已经成功获取响应结果 // 只要ajax请求状态发送变化，就会触发这个回调函数的执行 ajaxReq.onreadystatechange = callback; //4、发送请求 ajaxReq.send(null);&#125;//回调函数：处理结果function callback()&#123; //获取服务器响应结果的两个条件： //1.异步请求完成 ajaxReq.readyState == 4 //2.http状态为200 ajaxReq.status == 200 if(ajaxReq.readyState == 4 &amp;&amp; ajaxReq.status == 200)&#123; //获取结果 // 如果服务器响应的是文本数据（字符串），使用responseText属性接收 var result = ajaxReq.responseText; // 如果服务器响应的是XML文件，使用responseXML属性接收 // var doc = ajaxReq.responseXML; // 将获取的响应结果显示到网页的标签中 document.getElementById(&quot;tipsLabel&quot;).innerHTML = result; &#125;&#125; 3.CheckUserNameServlet12345678910111213141516171819202122232425262728293031323334353637383940414243package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Description 检测注册页面输入的用户名是否可用 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/CheckUserNameServlet&quot;)public class CheckUserNameServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收用户名 String userName = request.getParameter(&quot;userName&quot;); //2.检查用户名是否存在（查数据库） // 测试规则：只要用户名不是以admin开头就都可以使用 boolean r = !userName.startsWith(&quot;admin&quot;); String str = r?&quot;&lt;label style=&#x27;color:green&#x27;&gt;用户名可用！&lt;/label&gt;&quot;:&quot;&lt;label style=&#x27;color:red&#x27;&gt;用户名不可用！&lt;/label&gt;&quot;; //3.通过response的输出流、响应ajax请求 response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); out.println(str); out.flush(); out.close(); &#125;&#125; 三、JSONAJAX 就是一种使用JavaScript在前端页面不刷新的情况下和服务器进行数据交互 3.1 JSON介绍 ajax既然是实现前后端之间异步通信的技术，必然要考虑如何将前端的数据提交到服务器，如何将服务器的数据响应到前端并且能够被前端识别。 JSON就是不同系统之间、前后端之间、不同语言之间进行数据交互所遵守的一种数据的格式。 3.2 JSON格式 对象和Map 转换成 &#123;key:value , key:value,...&#125; 数组和集合转换成[e1,e2,e3,...] JSON格式可以嵌套 3.3 JSON格式转换3.3.1 前端JS对象与JSON格式转换 JS对象转换成JSON格式字符串 12345//创建JS对象var obj = &#123;stuNum:&quot;10001&quot;,stuName:&quot;张三&quot;&#125;;obj.stuGender = &quot;男&quot;;//将JS对象转换成json格式字符串var jsonStr = JSON.stringify(obj); 将JSON格式字符串转换成JS对象 1var obj2 = eval(&quot;(&quot;+jsonStr+&quot;)&quot;); 3.3.2 后端Java对象与JSON格式转换 FASTJson GSon JackSon 将json格式字符串转换成Java对象 123//要求：json格式的字符串中的key 要和目标Java对象属性一致Gson gson = new Gson();Student student = gson.fromJson(str, Student.class); 将Java对象转换成JSON格式 12Student stu2 = new Student(&quot;10006&quot;,&quot;Lucy&quot;,&quot;女&quot;);String jsonStr = gson.toJson(stu2); 3.3.3 随堂案例代码1.前端test-json.jsp1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/test.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;测试前端JSON格式转换&lt;/h3&gt; &lt;input type=&quot;button&quot; value=&quot;测试&quot; onclick=&quot;testJson()&quot;/&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testJson()&#123; //1.将JS对象转换成JSON格式字符串 var obj = &#123;stuNum:&quot;10001&quot;,stuName:&quot;张三&quot;&#125;; obj.stuGender = &quot;男&quot;; var jsonStr = JSON.stringify(obj); //发送异步请求，将JSON格式的字符串提交到TestJsonServlet var ajaxReq; if(window.XMLHttpRequest)&#123; ajaxReq = new XMLHttpRequest(); &#125;else&#123; ajaxReq = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; ajaxReq.open(&quot;POST&quot;,&quot;TestJsonServlet&quot;,true); ajaxReq.onreadystatechange = function()&#123; if(ajaxReq.status==200 &amp;&amp; ajaxReq.readyState==4)&#123; var s = ajaxReq.responseText; //将接收的服务器的响应的JSON字符串转换成js对象 var stu = eval(&quot;(&quot;+s+&quot;)&quot;); console.log(stu.stuName); &#125; &#125;; //ajax采用的是POST请求，将json格式字符串通过请求正文提交 ajaxReq.send(jsonStr); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.后端TestJsonServlet 需要在项目中添加gson-2.8.9.jar依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.qfedu.servlets;import com.google.gson.Gson;import com.qfedu.dto.Student;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;/** * @Description 测试JSON转换 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/TestJsonServlet&quot;)public class TestJsonServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收请求正文 request.setCharacterEncoding(&quot;utf-8&quot;); ServletInputStream inputStream = request.getInputStream(); StringBuilder builder = new StringBuilder(); byte[] bs = new byte[1024]; int len = -1; while((len = inputStream.read(bs))!=-1)&#123; String s = new String(bs,0,len,&quot;utf-8&quot;); builder.append(s); &#125; String str = builder.toString(); System.out.println(str); //2.将接收的json字符串，转换成Java对象(Student) Gson gson = new Gson(); Student student = gson.fromJson(str, Student.class); System.out.println(student); //3.java对象转换成JSON格式 Student stu2 = new Student(&quot;10006&quot;,&quot;Lucy&quot;,&quot;女&quot;); String jsonStr = gson.toJson(stu2); //将json格式字符串响应给ajax请求 response.setContentType(&quot;application/json;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); out.println(jsonStr); out.flush(); out.close(); &#125;&#125;","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"}]},{"title":"day08-JSP","slug":"day08-JSP","date":"2022-09-16T15:30:17.000Z","updated":"2022-10-10T02:15:39.193Z","comments":true,"path":"2022/09/16/day08-JSP/","link":"","permalink":"http://example.com/2022/09/16/day08-JSP/","excerpt":"","text":"一、JSP概述1.1 Servlet使用的不足 Servlet是一个动态网页技术，客户端通过请求Servlet类可以相应给客户端一个动态网页，但是Servlet在使用过程中有什么不足之处呢？ 开发方式麻烦：继承HttpServlet父类、重写doGet&#x2F;doPost、Servlet配置 项目更新麻烦：Servlet类中的代码发生改变，需要重新编译、部署、启动Tomcat 网页呈现复杂：需要进行HTML标签拼接，同时要通过输出流逐行打印 协同开发困难：UI负责页面美化，但是页面是由Servlet类提供，如果UI不懂Java、则不能完成Servlet响应的页面的优化 1.2 JSP简介 JSP (Java Server Page) 基于Servlet技术的、运行在服务器之上、支持Java语言的动态网页技术。 背景：JSP简化了Servlet的设计，采用在HTML标签中嵌套代码的形式进行动态网页的呈现，用于高效开发web应用的动态网页。 作用：替换显示页面部分的Servlet（使用*.jsp网页文件替换*PageServlet.java类） 二、JSP入门案例 JSP入门案例流程： 2.1 案例准备2.1.1 创建数据库数据表 创建数据库 db_jsp 创建图书信息表 123456789create table books( book_id char(6) primary key, book_name varchar(50) not null, book_author varchar(20) not null, book_price DECIMAL(10,2), book_img_path varchar(100) not null, book_desc varchar(200), book_type int not null ); 2.1.2 创建web项目JSP必须依赖于服务器运行，因此只能在web应用中使用JSP技术 web项目名称jsp-demo1 2.1.3 完成JDBC准备 导入jar包：mysql驱动、druid.jar、apache commons dbutils 创建com.qfedu.jsp.utils包，在包中创建druid.properties文件配置连接池参数 123456789101112131415# 数据库连接信息driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/db_jsp?characterEncoding=utf8username=rootpassword=@QFedu123# 连接池属性# 连接池的初始化连接数&lt;创建数据库连接池时默认初始化的连接的个数&gt;initialSize=10# 连接池的最大连接数maxActive=50# 最小空闲连接数（当数据库连接使用率很低时，连接池中的连接会被释放一部分）minIdle=5# 超时等待时间(单位：ms)maxWait=30000 在utils包中连接池工具类DruidUtils 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.qfedu.jsp.utils;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.*;import java.io.InputStream;import java.sql.*;import java.util.Properties;/** * @Description 数据库连接池工具类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class DruidUtils &#123; private static DruidDataSource druidDataSource; static&#123; try &#123; InputStream is = DruidUtils.class.getResourceAsStream(&quot;druid.properties&quot;); Properties properties = new Properties(); properties.load(is); druidDataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取数据库连接池数据源对象 * @return */ public static DataSource getDataSource()&#123; return druidDataSource; &#125; /** * 从数据库连接池中获取数据库连接对象 * @return */ public static Connection getConnection()&#123; Connection connection = null; try &#123; connection = druidDataSource.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125;&#125; 2.2 完成案例的数据库操作2.2.1 创建实体类 创建com.qfedu.jsp.dto包 创建实体类 123456789101112131415161718package com.qfedu.jsp.dto;/** * @Description 图书信息实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Book &#123; private String bookId; private String bookName; private String bookAuthor; private double bookPrice; private String bookImgPath; private String bookDesc; private int bookType;&#125; 2.2.2 创建DAO类完成操作 创建com.qfedu.jsp.dao包 创建BookDAO类，完成查询操作 123456789101112131415161718192021222324252627282930package com.qfedu.jsp.dao;import com.qfedu.jsp.dto.Book;import com.qfedu.jsp.utils.DruidUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.sql.SQLException;import java.util.List;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookDAO &#123; public List&lt;Book&gt; listBooks()&#123; List&lt;Book&gt; bookList = null; try &#123; String sql = &quot;select book_id bookId,book_name bookName,book_author bookAuthor,book_price bookPrice,book_img_path bookImgPath,book_desc bookDesc,book_type bookType from books&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); bookList = queryRunner.query(sql, new BeanListHandler&lt;Book&gt;(Book.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return bookList; &#125; &#125; 2.3 JSP呈现动态网页2.3.1 创建BookListServlet 创建BookListServlet类,接收用户请求 调用BookDAO查询图书信息，并将数据转发到 book-list.jsp 1234567891011121314151617181920212223242526package com.qfedu.jsp.servlets;/** * @Description 接收客户端请求场、查询图书信息，将图书信息转发到一个JSP文件进行显示 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/BookListServlet&quot;)public class BookListServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.调用BookDAO查询图书信息 BookDAO bookDAO = new BookDAO(); List&lt;Book&gt; bookList = bookDAO.listBooks(); //2.将数据转发到book-list.jsp进行动态显示 request.setAttribute(&quot;bookList&quot;,bookList); request.getRequestDispatcher(&quot;book-list.jsp&quot;).forward(request,response); &#125;&#125; 2.3.2 创建JSP页面 在项目的web目录下右键 — 新建 — JSP — 输入名称book-list.jsp — OK 在book-list.jsp进行网页界面设计（HTML+CSS+JS） 12345678910111213141516171819202122232425262728293031&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table width=&quot;80%&quot; align=&quot;center&quot; border=&quot;1&quot; cellspacing=&quot;0&quot;&gt; &lt;caption&gt;图书信息列表&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;图书ID&lt;/th&gt; &lt;th&gt;图书名称&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;封面&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;th&gt;类型&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;10001&lt;/td&gt; &lt;td&gt;Java&lt;/td&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;11.11&lt;/td&gt; &lt;td&gt;files/aaa.jpg&lt;/td&gt; &lt;td&gt;这本书真香&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 2.3.3 在JSP页面中显示动态数据 在JSP页面文件中，通过Java代码接收图书信息，并遍历显示在HTML标签中 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;com.qfedu.jsp.dto.Book&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table width=&quot;80%&quot; align=&quot;center&quot; border=&quot;1&quot; cellspacing=&quot;0&quot;&gt; &lt;caption&gt;图书信息列表&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;图书ID&lt;/th&gt; &lt;th&gt;图书名称&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;封面&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;th&gt;类型&lt;/th&gt; &lt;/tr&gt; &lt;%-- 在JSP中可以写Java代码，但是代码必须写在&lt;%%&gt;符号中 --%&gt; &lt;% //1.通过Java代码，接收BookListServlet转发时传递的 图书信息集合的数据 List&lt;Book&gt; bookList = (List&lt;Book&gt;) request.getAttribute(&quot;bookList&quot;); for(int i=0; i&lt; bookList.size() ; i++)&#123; //book是java代码中的变量 Book book = bookList.get(i); %&gt; &lt;tr&gt; &lt;%-- 如果需要将JSP中java代码的变量显示在HTML标签中，则需要使用&lt;%=attr%&gt; --%&gt; &lt;td&gt;&lt;%=book.getBookId() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getBookName() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getBookAuthor() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getBookPrice() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getBookImgPath() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getBookDesc() %&gt;&lt;/td&gt; &lt;td&gt;&lt;%=book.getBookType() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% &#125; %&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 三、JSP开发详解3.1 JSP和Servlet JSP和Servlet一样可以接受客户端请求，并响应一个动态网页。 JSP是对Servlet的一种高级封装，一个JSP文件底层就是一个Servlet类。 JSP文件需要依赖服务器运行，当客户端请求一个JSP文件时，JSP文件会在服务器中转换成Servlet来执行。 使用JSP的必要性： ​ 我们将动态网页显示使用JSP完成，在HTML标签中嵌入Java代码的形式开发动态网页更为便捷。 3.2 JSP开发的语法规则3.2.1 JSP文档规范 JSP文件和HTML文档一样是一个视图文件，JSP文件创建在项目的web目录 JSP文件以.jsp后缀名结尾 JSP文档内容结构： 在JSP文件的第一行需要通过 &lt;%@ page %&gt;声明使用java语言 JSP文件的主体内容是一个HTML文档，符合HTML的文档规范 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 3.2.2 Java脚本 JSP页面可以嵌入java代码，java代码就是这个页面的脚本 java代码：在jsp中的java代码必须写在&lt;% %&gt;中，代码可以写在JSP文件的任何位置，而且可以包含多段代码 123&lt;% java代码%&gt; 变量输出 1&lt;img src=&quot;&lt;%=attr %&gt;&quot;/&gt; 声明成员变量和方法： 1234567&lt;%! int i = 5;%&gt;&lt;%! public void method()&#123; System.out.println(&quot;hello&quot;); &#125; %&gt; 3.2.3 JSP注释 HTML文档注释 1&lt;!-- HTML文档注释：这种注释会出现在jsp编译之后的Java代码中 --&gt; JSP注释 1&lt;%-- JSP 注释： 这种注释不会出现在编译后的java代码 --%&gt; 3.3 JSP编译指令编译指令：在JSP文件转换成Java代码之后，编译成.class文件的过程中执行的指令 &lt;%@ page %&gt; : 声明当前JSP页面在web容器中的配置、引用； &lt;%@ include %&gt; : 在当前JSP中引用其他的资源（JSP\\HTML）作为当前JSP的一部分； &lt;%@ taglib %&gt; : 引用第三方标签库、扩展JSP文件中的标签； 3.3.1 &lt;%@ page%&gt; 标签属性 说明 示例 contentType 用于声明当前JSP文档的MIME类型和字符集编码 contentType&#x3D;”text&#x2F;html;charset&#x3D;UTF-8” language 定义JSP中所用的脚本语言类型，默认java language&#x3D;”java” import 声明当前JSP中的Java代码依赖的类 import&#x3D;”java.util.List” pageEncoding 声明当前JSP文档的解码格式 pageEncoding&#x3D;”UTF-8” errorPage 如果当前JSP出现异常则跳转到errorPage指向页面 errorPage&#x3D;”error.jsp” isErrorPage 定义当前页面是否可以作为错误页面 isErrorPage&#x3D;”true” 3.3.2 &lt;%@ include %&gt; 在当前JSP中引用其他的资源（JSP\\HTML）作为当前JSP的一部分，被引入的页面不会单独作为一个JSP编译，而是将引入的页面中的代码插入到当前JSP之后作为一个整体进行编译。 被引入的页面只需要是一个HTML片段即可。 静态引入：将被页面引入到当前JSP之后再进行整体的编译，被引入的页面不会单独编译。 header.jsp 1&lt;div style=&quot;height: 100px; background: deepskyblue&quot; &gt;header&lt;/div&gt; footer.jsp 1&lt;div style=&quot;height: 50px; background: lightgray&quot; &gt;footer&lt;/div&gt; index.jsp 12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot;java.util.Date&quot;%&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%@ include file=&quot;header.jsp&quot;%&gt; &lt;div style=&quot;height: 400px; background: orange&quot;&gt;index&lt;/div&gt; &lt;%@ include file=&quot;footer.jsp&quot;%&gt; &lt;/body&gt;&lt;/html&gt; 3.3.3 &lt;%@ taglib %&gt; 引用第三方标签库、扩展JSP文件中的标签 12&lt;!--引入JSTL标签库--&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 3.4 JSP动作指令 在JSP文件中，除了支持标准的HTML标签库和编译指令之外，还支持JSP特有的动作指令（动作标签）。 动作指令：在JSP中以jsp:开头的、在JSP页面运行期间执行的指令。 3.4.1 jsp:include12&lt;%-- 动态引入 --%&gt;&lt;jsp:include page=&quot;test1.jsp&quot;/&gt; 动态引入JSP文件文件：被引入的JSP文件先单独编译执行，将执行的结果引入到当前JSP文件。 因为被引入的JSP页面需要独立的编译执行，因此被引入的页面需要是一个完整的JSP文件。 在动态引入的页面中不能访问主页面中定义的Java变量。 静态引入和动态引入的区别： 静态引入，使用&lt;%@include file=&quot;&quot;%&gt;编译指令将HTML或者JSP页面引入到当前文件，静态引入是先引入再执行，因此被引入的页面可以是一个HTML片段，也可在被引入的页面中访问主页面定义的Java变量； 动态引入，使用&lt;jsp:include page=&quot;&quot;/&gt;动作指令将JSP页面引入到当前文件，动态引入是先独立编译执行被引入的页面，将执行结果引入到当前页面，被引入的页面需要独立执行因此必须是一个完成的JSP，同时在被引入的JSP中不能访问主页面定义的Java变量。 3.4.2 jsp:userBean 在JSP页面中构造Java对象 12&lt;%-- 相当于 Book book = new Book(); --%&gt;&lt;jsp:useBean id=&quot;book&quot; class=&quot;com.qfedu.jsp.dto.Book&quot;&gt;&lt;/jsp:useBean&gt; id属性， 创建的对象的变量名 class属性，类的全限定名 3.4.3 jsp:setProperty 给创建的Java对象属性赋值 123&lt;%-- 相当于 book.setBookId(&quot;100001&quot;) --%&gt;&lt;jsp:setProperty name=&quot;book&quot; property=&quot;bookId&quot; value=&quot;100001&quot;&gt;&lt;/jsp:setProperty&gt;&lt;jsp:setProperty name=&quot;book&quot; property=&quot;bookName&quot; value=&quot;Java&quot;&gt;&lt;/jsp:setProperty&gt; name属性，对象的变量名 property属性，对象的属性名 values属性，属性的值 3.4.4 jsp:getProperty 获取创建的对象的值，并输出到网页 12&lt;%-- 相当于 book.getBookId()，并将获取的值输出到页面 --%&gt;&lt;jsp:getProperty name=&quot;book&quot; property=&quot;bookId&quot;/&gt; name属性，对象的变量名 property属性，对象的属性名 3.4.5 jsp:forward 用于转发客户端请求 1&lt;jsp:forward page=&quot;test2.jsp&quot;&gt;&lt;/jsp:forward&gt; 3.4.6 jsp:param 在JSP页面转发过程中进行参数传递 123456&lt;%-- 从当前JSP转发到另一个JSP --%&gt;&lt;jsp:forward page=&quot;test2.jsp&quot;&gt; &lt;%-- 转发的同时携带参数 --%&gt; &lt;jsp:param name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt; &lt;jsp:param name=&quot;sex&quot; value=&quot;nan&quot;/&gt;&lt;/jsp:forward&gt; 3.5 JSP九大内置对象 一个JSP文件在服务器上是转换成Java文件（Servlet类）编译执行的，我们在JSP文件中嵌入的Java代码都会转换到这个Java文件的方法中（_jspService）,因此这个方法的参数、方法中定义的变量以及当前类继承的父类中定义的变量，我们的代码都可以使用。 在JSP中编写Java代码可以不用创建、直接使用的对象我们称之为JSP内置对象。 对象名 类型 request javax.servlet.http.HttpServletRequest 表示客户端请求对象，用户获取HTTP请求信息 response javax.servlet.http.HttpServletResponse 表示服务器对客户端的响应对象，用于将JSP处理的数据响应给客户端 session javax.servlet.http.HttpSession 表示当前客户端与服务器的会话对象 application javax.servlet.ServletContext 当前web应用在服务器上的全局对象 config javax.servlet.ServletConfig 表示当前Servlet类的配置信息 pageContext javax.servlet.jsp.PageContext 当前JSP的上下文，可以获取当前JSP的任何信息 out javax.servlet.jsp.JspWriter 指向当前JSP文档的输出流 exception java.lang.Throwable 只有在设置了isErrorPage&#x3D;“true”的JSP可使用 page java.lang.Object 当前JSP转换的servlet类的实例，相当于this 3.6 JSP四大域对象 域对象——可以用来存取数据的对象 pageContext request session application 3.6.1 pageContext pageConext对象 只作用于当前JSP文件 3.6.2 request request作用于一次请求 3.6.3 session session对象作用于用户一次连接的多次请求 3.6.4 application application实际上就是servletContext对象，作用于一个web应用的所有用户 3.6.5 使用域对象传值示例 Servlet类 1234567891011121314151617181920212223242526272829package com.qfedu.jsp.servlets;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/TestServlet&quot;)public class TestServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.分别通过 request、session、application传值 request.setAttribute(&quot;key1&quot;,&quot;value1&quot;); HttpSession session = request.getSession(); session.setAttribute(&quot;key2&quot;,&quot;value2&quot;); ServletContext application = getServletContext(); application.setAttribute(&quot;key3&quot;,&quot;value3&quot;); //2.转发到test3.jsp request.getRequestDispatcher(&quot;test3.jsp&quot;).forward(request,response); &#125;&#125; JSP页面 12345678910111213141516171819&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Test3&lt;hr/&gt;&lt;% String s1 = (String) request.getAttribute(&quot;key1&quot;); String s2 = (String) session.getAttribute(&quot;key2&quot;); String s3 = (String) application.getAttribute(&quot;key3&quot;);%&gt;request取出的数据:&lt;%=s1%&gt; &lt;br/&gt;session取出的数据:&lt;%=s2%&gt; &lt;br/&gt;application取出的数据:&lt;%=s3%&gt; &lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 3.7 JSP开发应用 JSP负责项目中的视图呈现 Servlet负责接收、处理用户请求 Servlet类查询的数据转发并传递给JSP页面进行显示 注意：当将进行页面显示的Servlet类转换成jsp文件之后，要修改对应跳转的路径；同时注意修改登录过滤器的放行路径，以及未登录时要跳转到login.jsp（而不是原来的LoginPageServlet） 四、EL表达式 思考问题：JSP相较于Servlet来说，在动态网页的数据渲染方面要便捷很多，但是依然要进行HTML和Java代码的混合编程，代码的可读性和维护性依然有待提高，能不能做HTML和Java代码的完全分离呢？ 4.1 什么是EL? Expression Language 表达式语言，应用于JSP页面，可以更简单、便捷的获取page、request、session、application等作用域的值，进行渲染。 EL表达式就是替代以下代码的作用： pageContext.getAttribute(“key”); request.getAttribute(“key”); session.getAttribute(“key”); application.getAttribute(“key”); EL表达式使用示例： Servlet类: 123456789101112131415161718192021222324/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/TestServlet&quot;)public class TestServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.传递数据 request.setAttribute(&quot;str&quot;,&quot;Hello EL!&quot;); //2.转发到JSP页面 request.getRequestDispatcher(&quot;test.jsp&quot;).forward(request,response); &#125;&#125; JSP文件： 12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%-- 使用Java代码接收数据 --%&gt; &lt;% String s = (String) request.getAttribute(&quot;str&quot;); %&gt; Java脚本获取的数据：&lt;%=s %&gt; &lt;%-- 通过EL获取并显示TestServlet传递的数据 --%&gt; EL表达式获取的数据：$&#123;str&#125; &lt;/body&gt;&lt;/html&gt; 4.2 EL表达式应用4.2.1 实体类1234567891011121314151617181920package com.qfedu.dto;/** * @Description 图书信息实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Book &#123; private String bookId; private String bookName; private String bookAuthor; private double bookPrice; //无参构造器 //全参构造器 //toString //get和set方法&#125; 4.2.2 TestServlet类 在TestServlet类传递各种数据，并转发到test.jsp页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.qfedu.servlets;import com.qfedu.dto.Book;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/TestServlet&quot;)public class TestServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.传递数据 //简单类型 request.setAttribute(&quot;key1&quot;,123); //字符串 request.setAttribute(&quot;key2&quot;,&quot;Hello EL!&quot;); //对象 request.setAttribute(&quot;key3&quot;,new Book(&quot;1001&quot;,&quot;Java&quot;,&quot;亮亮&quot;,20.00)); //数组 String[] arr = &#123;&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;&#125;; request.setAttribute(&quot;key4&quot;,arr); //集合 List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); bookList.add(new Book(&quot;1001&quot;,&quot;Java&quot;,&quot;亮亮&quot;,20.00)); bookList.add(new Book(&quot;1002&quot;,&quot;C++&quot;,&quot;张三&quot;,21.00)); bookList.add(new Book(&quot;1003&quot;,&quot;Python&quot;,&quot;李四&quot;,22.00)); request.setAttribute(&quot;key5&quot;,bookList); //Map Map&lt;String,Book&gt; map = new HashMap&lt;&gt;(); map.put(&quot;a1001&quot;,new Book(&quot;1001&quot;,&quot;Java&quot;,&quot;亮亮&quot;,20.00)); map.put(&quot;a1002&quot;,new Book(&quot;1002&quot;,&quot;C++&quot;,&quot;张三&quot;,21.00)); map.put(&quot;a1003&quot;,new Book(&quot;1003&quot;,&quot;Python&quot;,&quot;李四&quot;,22.00)); request.setAttribute(&quot;key6&quot;,map); //2.转发到JSP页面 request.getRequestDispatcher(&quot;test.jsp&quot;).forward(request,response); &#125;&#125; 4.2.3 test.jsp 在test.jsp页面通过EL表达式获取各种类型数据 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;%-- 1.接收简单类型及字符串 $&#123;key&#125; --%&gt; $&#123;key1&#125;&lt;br/&gt; $&#123;key2&#125;&lt;br/&gt;&lt;%-- 2.接收对象数据 $&#123;key&#125;获取对象的toString方法输出， 我们可以通过 $&#123;key.attrName&#125;获取对象属性值，通过反射调用类中属性的get方法获取属性值 因此传递到JSP页面、使用EL表达式获取属性值的对象必须提供get方法 --%&gt; $&#123;key3&#125;&lt;br/&gt; $&#123;key3.bookId&#125;&lt;br/&gt; $&#123;key3.bookName&#125;&lt;br/&gt; $&#123;key3.bookAuthor&#125;&lt;br/&gt; $&#123;key3.bookPrice&#125;&lt;br/&gt;&lt;%-- 3.接收数组数据 $&#123;key[index]&#125; --%&gt; $&#123;key4[0]&#125;-$&#123;key4[1]&#125;-$&#123;key4[2]&#125;&lt;br/&gt;&lt;%-- 4.接收集合中的数据：$&#123;key[index]&#125; 如何集合中的元素是对象 ，可以进一步使用 $&#123;key[index].attrName&#125; 获取集合中对象的属性--%&gt; $&#123;key5[0].bookName&#125;- $&#123;key5[0].bookAuthor&#125;&lt;br/&gt; $&#123;key5[1].bookName&#125;- $&#123;key5[1].bookAuthor&#125;&lt;br/&gt; $&#123;key5[2].bookName&#125;- $&#123;key5[2].bookAuthor&#125;&lt;br/&gt;&lt;%-- 5.接收Map中的数据: 使用$&#123;key&#125;获取整个map 使用$&#123;key.mapKey&#125; 根据可以获取元素 如果map中的key是以数字开头，可以使用$&#123;key[&#x27;mapKey&#x27;]&#125; 如果map中的value是对象，我们还可以进一步使用 $&#123;key.mapKey.attrName&#125;获取对象属性值--%&gt; $&#123;key6[&#x27;a1001&#x27;]&#125;&lt;br/&gt; $&#123;key6.a1001&#125;&lt;br/&gt; $&#123;key6.a1001.bookName&#125;&lt;br/&gt; &lt;/body&gt;&lt;/html&gt; 4.3 EL访问域对象 如果从Servlet分别使用request、session、application同时向JSP页面传递数据，并且key都相同；那么在JSP页面直接使用${key}获取的是什么数据呢？ 如何能够获取我们想要访问的域对象中的数据呢？ 4.3.1 ${key}获取哪个域对象的数据呢？ 四个域对象的访问从小到大依次是：pageContext–&gt;request–&gt;session–&gt;application 如果没有指定域对象，${key}默认获取最小域对象中的数据 4.3.2 如何使用EL获取指定域对象数据？ 在EL表达式中，分别为四个域对象各自取了一个名字 pageContext对象 —&gt; pageScope request对象—&gt;requestScope session对象—&gt;sessionScope application对象—&gt;applicationScope 在JSP中如果多个域对象都有相同的key，可以通过$&#123;***Scope.key&#125;来获取指定域对象中数据，如果获取不到则返回””，显示到页面为空白 1$&#123;sessionScope.key&#125; 4.4 EL的隐式对象 EL语法中提供的隐藏对象——隐式对象 除了四个域对象pageScope、requestScope、sessionScope、applicationScope之外，EL中还提供了另外七个隐式对象，分别用于获取不同的数据 隐式对象 说明 param 获取Rquest对象的参数，返回String，$&#123;param.key&#125;等价于request.getParameter(&quot;key&quot;) paramValues 获取Rquest对象传递的所有的参数值，返回字符串集合 $&#123;paramValues&#125;等价于request.getParameterValues() header 获取HTTP请求头 $&#123;header.contentPosition&#125; headerValues 获取HTTP请求头中所有的值 initParam 获取上下文初始化参数 pageContext 获取当前页面的pageContext对象： $&#123;pageContext.request.contextPath&#125;当前web项目在服务器的访问路径 cookie 获取cookie中的值，${cookie.username} 4.5 EL的运算符EL表达式不能能够从域对象获取数据，同时可以对取出的数据进行算术运算、关系比较、逻辑运算等运算 4.5.1 算术运算 运算符 描述&#x2F;示例 + $&#123;key1+key2&#125; 表示根据key1获取的值然后加上key2获取的值，显示到网页 - 减法 * 乘法 &#x2F; or div 除法， $&#123;key/4&#125; 等价于 $&#123;key div 4&#125; % or mod 取模 4.5.2 关系比较 运算符 描述&#x2F;示例 == or eq $&#123;key == v&#125; 表示比较根据key获取的值是否等于v，返回结果为true&#x2F;false等价于 $&#123;key eq v&#125; != or ne 不等于 &gt; or gt 大于 &lt; or lt 小于 &gt;= or ge 大于等于 &lt;= or le 小于等于 4.5.3 逻辑运算 运算符 描述&#x2F;示例 &amp;&amp; or and 逻辑与,用于连接两个条件 &#96; ! or not 逻辑非 4.5.4 判空 运算符 描述&#x2F;示例 empty $&#123;empty key&#125; 如果key对应取出的值为空，则返回true 五、JSTL 如果EL表达式在JSP页面中获取的集合中的元素个数不确定，我们该如何将集合中的数据全部显示呢？ 5.1 JSTL简介 JSTL (JSP Standard Tag Library) JSP标准标签库，用于扩展JSP中的标签，能够为JSP页面提供流程控制、类型转换等功能的标签。 作用：在JSP中通常是JSTL+EL的组合来进行数据的提取及渲染。 JSTL标签库提供了多类标签： c ，核心标签库，提供流程控制的标签 fmt，转换标签库，提供了日期、数值类型转换的标签 sql fn x 5.2 JSTL的引入步骤 需要在JSP中引用JSTL标签库之后，才可以使用JSTL提供的标签 下载JSTL标签库的依赖jar https://mvnrepository.com/ 将jar文件引入到当前web项目 在需要使用JSTL标签的JSP文件，通过&lt;%@taglib%&gt;引入JSTL标签库（JSTL包含多种标签，每种标签需要单独引入） 1234&lt;!--引入JSTL的核心标签库--&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;!--引入JSTL的转换标签库--&gt;&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt; 5.3 JSTL核心标签库 c标签，主要用于完成JSP页面中逻辑控制&#x2F;流程控制 分支 循环 5.3.1 c:if &lt;c:if test=&quot;EL表达式条件&quot;&gt; ​ html &lt;/c:if&gt; 1234567&lt;%-- 如果test属性的el表达式返回的为true，则显示c:if标签包含的HTML --%&gt;&lt;c:if test=&quot;$&#123;score &gt;= 60&#125;&quot;&gt; &lt;label style=&quot;color: green&quot;&gt;通过&lt;/label&gt;&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;score &lt; 60&#125;&quot;&gt; &lt;label style=&quot;color: red&quot;&gt;不通过&lt;/label&gt;&lt;/c:if&gt; 5.3.2 c:choose c:choose为多分支语句，可以包含多个c:when和一个c:otherwise ,寻找并执行第一个条件成立的c:when，如果所有c:when的条件都不成立则执行c:otherwise 1234567891011121314151617&lt;c:choose&gt; &lt;c:when test=&quot;$&#123;score&gt;=90&#125;&quot;&gt; &lt;label style=&quot;color: green&quot;&gt;优秀&lt;/label&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;score&gt;=80&#125;&quot;&gt; &lt;label style=&quot;color: green&quot;&gt;良好&lt;/label&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;score&gt;=70&#125;&quot;&gt; &lt;label style=&quot;color: green&quot;&gt;中等&lt;/label&gt; &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;score&gt;=60&#125;&quot;&gt; &lt;label style=&quot;color: green&quot;&gt;及格&lt;/label&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;label style=&quot;color: red&quot;&gt;不及格&lt;/label&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; 5.3.3 c:forEach 迭代标签、循环标签 123456789101112131415161718192021222324 &lt;%-- 遍历传递过来的集合中的图书信息，显示在一个表格中 --%&gt;&lt;table align=&quot;center&quot; border=&quot;1&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;th&gt;图书编号&lt;/th&gt; &lt;th&gt;图书名称&lt;/th&gt; &lt;th&gt;图书作者&lt;/th&gt; &lt;th&gt;图书价格&lt;/th&gt; &lt;/tr&gt; &lt;%-- 获取传递过来的集合，集合中有几个图书信息，table就显示几行 items 指定要遍历的集合 var 指定从集合中每次取出的数据的变量 begin 指定从集合中的哪个元素开始显示，0表示第一个 end 指定取到哪个索引对应的集合元素 step 指定元素的间隔个数（默认为1，依次取出所有元素） --%&gt; &lt;c:forEach items=&quot;$&#123;bookList&#125;&quot; var=&quot;book&quot; begin=&quot;1&quot; end=&quot;4&quot; step=&quot;2&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.bookId&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.bookName&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.bookAuthor&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.bookPrice&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; 5.4 JSTL转换标签 fmt标签，提供了用于日期、数字等类型数据的格式转换的标签 12345678&lt;%-- 格式化数字输出 --%&gt;&lt;fmt:formatNumber value=&quot;$&#123;num&#125;&quot; pattern=&quot;#.0000&quot;&gt;&lt;/fmt:formatNumber&gt;&lt;br/&gt;&lt;fmt:formatNumber value=&quot;$&#123;num&#125;&quot; type=&quot;currency&quot;&gt;&lt;/fmt:formatNumber&gt;&lt;br/&gt;&lt;%-- 格式化日期输出 --%&gt;&lt;fmt:formatDate value=&quot;$&#123;date&#125;&quot; pattern=&quot;yyyy-MM-dd&quot;&gt;&lt;/fmt:formatDate&gt;&lt;br/&gt;&lt;fmt:formatDate value=&quot;$&#123;date&#125;&quot; pattern=&quot;hh:mm:ss&quot;&gt;&lt;/fmt:formatDate&gt;&lt;br/&gt;&lt;fmt:formatDate value=&quot;$&#123;date&#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;&gt;&lt;/fmt:formatDate&gt;&lt;br/&gt; 六、Servlet和JSP的综合案例 图书信息管理系统：管理员登录，对图书信息进行管理 管理员登录 添加图书信息 图书信息列表 修改图书信息 删除图书信息 6.1 书城后台管理系统业务流程 6.2 项目的MVC分层架构将项目中实现不同业务的代码进行分离: 视图View — jsp负责进行客户端的页面呈现 控制器Controller — servlet负责接收用户请求，调用service进行处理，根据处理结果进行流程跳转 模型Model — service对数据的业务处理、DAO对数据的持久化操作 6.3 数据库设计 根据项目业务功能抽象数据实体 管理员 图书 提取实体的数据项 管理员（ID，登录名，登录密码，真实姓名，性别，电话，备注） 图书（编号，名称，作者，价格，封面图片，描述，库存，分类…） 使用三范式约束的实体数据项（???） E-R图 数据库建模 建库建表 12345678910111213141516171819202122create database db_bookmall;create table users( user_id int primary key auto_increment, user_name varchar(40) not null unique, user_pwd varchar(40) not null, real_name varchar(20) not null, user_gender char(2) not null, user_tel char(11) not null unique, user_desc varchar(200));create table books( book_id char(6) primary key, book_name varchar(50) not null, book_author varchar(20) not null, book_price DECIMAL(10,2), book_img_path varchar(100) not null, book_desc varchar(200), book_stcok int not null, book_type int not null ); 6.4 web项目环境搭建 创建web项目 搭建JDBC环境 驱动 连接池 DBUtils 6.5 数据库访问实现6.5.1 管理员登录的数据库操作 根据登录名查询用户信息 （根据用户名查询用户，将查询出来的用户的密码和输入的密码进行对别） 创建实体类 123456789101112131415161718package com.qfedu.bookmall.ms.dto;/** * @Description 管理员实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class User &#123; private int userId; private String userName; private String userPwd; private String realName; private String userGender; private String userTel; private String userDesc; //....&#125; 创建DAO类实现数据库操作 12345678910111213141516171819202122232425262728293031323334package com.qfedu.bookmall.ms.dao;import com.qfedu.bookmall.ms.dto.User;import com.qfedu.bookmall.ms.utils.DruidUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import java.sql.SQLException;/** * @Description 用于实现管理员的数据库操作 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class UserDAO &#123; /** * 根据管理员登录名查询管理员信息 * @param userName * @return */ public User selectUserByUserName(String userName)&#123; User user = null; try &#123; String sql = &quot;select user_id userId,user_name userName,user_pwd userPwd,real_name realName,user_gender userGender,user_tel userTel,user_desc userDesc from users where user_name=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); user = queryRunner.query(sql, new BeanHandler&lt;User&gt;(User.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return user; &#125;&#125; 6.5.2 图书管理的数据库操作 添加图书信息 查询所有图书信息 根据图书ID删除一个图书信息 根据图书ID查询一个图书信息 根据图书ID修改一个图书信息 创建图书实体类 12345678910111213141516171819package com.qfedu.bookmall.ms.dto;/** * @Description 图书信息实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Book &#123; private String bookId; private String bookName; private String bookAuthor; private double bookPrice; private String bookImgPath; private String bookDesc; private int bookStock; private int bookType;&#125; 创建DAO类完成数据库操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.qfedu.bookmall.ms.dao;import com.qfedu.bookmall.ms.dto.Book;import com.qfedu.bookmall.ms.utils.DruidUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.sql.SQLException;import java.util.List;/** * @Description 完成图书信息的数据库操作 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookDAO &#123; /** * 添加图书信息 * @param book * @return */ public int insertBook(Book book)&#123; int i = 0; try &#123; String sql = &quot;insert into books(book_id,book_name,book_author,book_price,book_img_path,book_desc,book_stcok,book_type) values(?,?,?,?,?,?,?,?)&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); //给SQL中的参数赋值 Object[] params = &#123;book.getBookId(),book.getBookName(),book.getBookAuthor(),book.getBookPrice(),book.getBookImgPath(),book.getBookDesc(),book.getBookStock(),book.getBookType()&#125;; i = queryRunner.update(sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i; &#125; /** * 查询所有图书信息 * @return */ public List&lt;Book&gt; selectBooks()&#123; List&lt;Book&gt; bookList = null; try &#123; String sql = &quot;select book_id bookId,book_name bookName,book_author bookAuthor,book_price bookPrice,book_img_path bookImgPath,book_desc bookDesc,book_stcok bookStock,book_type bookType from books&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); bookList = queryRunner.query(sql, new BeanListHandler&lt;Book&gt;(Book.class)); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return bookList; &#125; /** * 根据图书ID删除一个图书信息 * @param bookId * @return */ public int deleteBook(String bookId)&#123; int i = 0; try &#123; String sql = &quot;delete from books where book_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); i = queryRunner.update(sql, bookId); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i; &#125; /** * 根据图书ID查询一个图书信息 */ public Book selectBookByBookId(String bookId)&#123; Book book = null; try &#123; String sql = &quot;select book_id bookId,book_name bookName,book_author bookAuthor,book_price bookPrice,book_img_path bookImgPath,book_desc bookDesc,book_stcok bookStock,book_type bookType from books where book_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); book = queryRunner.query(sql, new BeanHandler&lt;Book&gt;(Book.class),bookId); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return book; &#125; /** * 根据图书ID修改一个图书信息 * @param book * @return */ public int updateBook(Book book)&#123; int i = 0; try &#123; String sql = &quot;update books set book_name=?,book_author=?,book_price=?,book_img_path=?,book_desc=?,book_stcok=?,book_type=? where book_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); Object[] params = &#123;book.getBookName(),book.getBookAuthor(),book.getBookPrice(),book.getBookImgPath(),book.getBookDesc(),book.getBookStock(),book.getBookType(),book.getBookId()&#125;; i = queryRunner.update(sql, params); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return i; &#125;&#125; 6.6 网页设计 login.html index.html prompt.html book-add.html book-list.html book-modify.html 6.7 业务层实现6.7.1 管理员登录业务12345678910111213141516171819202122232425262728293031package com.qfedu.bookmall.ms.service;import com.qfedu.bookmall.ms.dao.UserDAO;import com.qfedu.bookmall.ms.dto.User;/** * @Description 管理员相关业务实现 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class UserService &#123; /** * 管理员登录业务：根据账号密码验证管理登录，验证通过返回user对象，否则返回null * @param userName * @param userPwd * @return */ public User checkLogin(String userName, String userPwd)&#123; //1.根据userName查询管理员信息 UserDAO userDAO = new UserDAO(); User user = userDAO.selectUserByUserName(userName); //2.判断密码 if(user != null &amp;&amp; user.getUserPwd() .equals(userPwd))&#123; return user; &#125;else&#123; return null; &#125; &#125; &#125; 6.7.2 图书管理业务实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.qfedu.bookmall.ms.service;import com.qfedu.bookmall.ms.dao.BookDAO;import com.qfedu.bookmall.ms.dto.Book;import java.util.List;/** * @Description 图书管理的业务实现 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class BookService &#123; private BookDAO bookDAO = new BookDAO(); /** * 添加图书业务实现 * @param book * @return */ public boolean saveBook(Book book)&#123; int i = bookDAO.insertBook(book); return i&gt;0?true:false; &#125; /** * 删除图书业务实现 * @param bookId * @return */ public boolean deleteBook(String bookId)&#123; int i = bookDAO.deleteBook(bookId); return i&gt;0?true:false; &#125; /** * 根据ID查询一个图书的业务实现 * @param bookId * @return */ public Book getBook(String bookId)&#123; Book book = bookDAO.selectBookByBookId(bookId); return book; &#125; /** * 修改图书业务实现 * @param book * @return */ public boolean modifyBook(Book book)&#123; int i = bookDAO.updateBook(book); return i&gt;0?true:false; &#125; /** * 查询所有图书信息 * @return */ public List&lt;Book&gt; listBooks()&#123; List&lt;Book&gt; bookList = bookDAO.selectBooks(); return bookList; &#125;&#125; 6.8 功能流程实现6.8.1 创建JSP及Servlet类 在项目创建所需的JSP文件，将设计好的HTML整合到JSP中 创建servlets包，在servlets中创建业务流程实现所需的Servlet类 6.8.2 管理员登录 login.jsp —&gt; 提交账号和密码到LoginCheckServlet LoginCheckServlet —&gt; 接收账号和密码进行校验，根据校验跳转 login.jsp —&gt; 显示登录失败时传递的提示信息 6.8.3 添加图书 index.jsp —&gt; 点击添加图书菜单，显示book-add.jsp book-add.jsp —&gt; 提交数据到BookSaveServlet（表单中有文件上传） BookSaveServlet —&gt; 在Servlet前添加 @MultipartConfig注解 prompt.jsp —&gt; 显示提示信息 注意：如果添加的中文出现乱码则添加编码过滤器 6.8.4 图书列表 index.jsp —-&gt; 点击图书列表向BookListServlet发送请求 BookListServlet —&gt;查询图书信息，转发传递到book-list.jsp book-list.jsp —&gt; JSTL+EL遍历显示图书信息 （需要在项目中引入jstl的2个jar文件） 6.8.5 删除图书 book-list.jsp—&gt; 显示图书列表时，将图书id和删除按钮绑定，点击删除时将当前图书的id传递到BookDeleteServlet BookDeleteServlet —&gt; 获取图书ID，删除图书信息，进行提示 6.8.6 修改图书 book-list.jsp —&gt; 点击修改，将图书ID传递到BookQueryServlet BookQueryServlet —&gt; 查询要修改的图书的原始信息 book-modify.jsp —&gt; 显示BookQueryServlet传递的图书的原始信息,修改之后提交到BookUpdateServlet红色标注表示显示图书原始信息、紫色标注表示提交修改 BookUpdateServlet—&gt; 接收修改后的数据，执行修改，并提示 七、分页功能实现7.1 分页概念 分页是web应用开发中非常重要的一个业务实现。数据库中的数据可能很多（成千上万、几十万、上百万都又可能），不能将这些数据全部查询出来并显示到列表页面。一般我们需要为用户提供翻页功能，例如一次显示10行&#x2F;20行，然后点击下一页查看接下来的10行&#x2F;20行。 7.2 分页实现思路 7.3 分页代码实现7.3.1 BookDAO 分页查询数据 123456789101112131415161718/*** 分页查询图书信息* @param start 查询数据的起始行索引* @param limit 最多返回的数据记录数（每页显示的条数）* @return 返回的集合中只包含一页的数据*/public List&lt;Book&gt; selectBooks(int start,int limit)&#123; List&lt;Book&gt; bookList = null; try &#123; String sql = &quot;select book_id bookId,book_name bookName,book_author bookAuthor,book_price bookPrice,book_img_path bookImgPath,book_desc bookDesc,book_stcok bookStock,book_type bookType from books limit ?,?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); bookList = queryRunner.query(sql, new BeanListHandler&lt;Book&gt;(Book.class),start,limit); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return bookList;&#125; 查询总记录数 123456789101112131415/*** 查询图书的总记录数* @return*/public long selectBookCount()&#123; long count = 0; try &#123; String sql = &quot;select count(1) from books&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); count = queryRunner.query(sql,new ScalarHandler&lt;Long&gt;()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return count;&#125; 7.3.2 BookService 根据页码、每页条数查询当前页的数据 根据每页条数计算总页数 12345678910111213141516171819202122232425/** * 分页查询图书信息 * @param pageNum 页码 * @param pageSize 每页显示的条数 * @return */public List&lt;Book&gt; listBooksByPage( int pageNum,int pageSize)&#123; int start = (pageNum-1)*pageSize; int limit = pageSize; List&lt;Book&gt; bookList = bookDAO.selectBooks(start,limit); return bookList;&#125;/** * 查询图书总页数 * @param pageSize 每页显示的条数 * @return */public int getPageCount(int pageSize)&#123; //1.查询总记录 long count = bookDAO.selectBookCount(); //2.根据总记录数和每页显示的条数，计算总页数 long pageCount = count%pageSize == 0 ? count/pageSize: count/pageSize+1; return (int)pageCount;&#125; 7.3.3 BookListServlet1.接收页码 pageNum 2.定义每页显示条数 pageSize 3.查询当前页数据 bookList 4.查询总记录数 pageCount 5.转发到列表页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.qfedu.bookmall.ms.servlets;import com.qfedu.bookmall.ms.dto.Book;import com.qfedu.bookmall.ms.service.BookService;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;/** * @Description 分页查询图书信息 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/BookListServlet&quot;)public class BookListServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收客户端传递的页码 // (如果客户端没有传递页码，则默认页码为1，如果传递了则使用客户端传递的页码) String num = request.getParameter(&quot;pageNum&quot;); int pageNum = num==null? 1: Integer.parseInt( num ); //2.定义pageSize int pageSize = 10; //3.调用BookService查询这一页的图书信息 BookService bookService = new BookService(); List&lt;Book&gt; bookList = bookService.listBooksByPage(pageNum,pageSize); //4.调用BookService查询图书的总页数 int pageCount = bookService.getPageCount(pageSize); //5.将查询到的当前页数据的集合、当前页码、总页数 转发到book-list.jsp request.setAttribute(&quot;bookList&quot;,bookList); request.setAttribute(&quot;pageNum&quot;,pageNum); request.setAttribute(&quot;pageCount&quot;,pageCount); request.getRequestDispatcher(&quot;book-list.jsp&quot;).forward(request,response); &#125;&#125; 7.4 book-list.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;图书信息列表&lt;/h3&gt; &lt;table width=&quot;90%&quot; align=&quot;center&quot; border=&quot;1&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;封面&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;作者&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;库存&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;th&gt;类型&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;bookList&#125;&quot; var=&quot;book&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.bookId&#125;&lt;/td&gt; &lt;td&gt;&lt;img src=&quot;$&#123;book.bookImgPath&#125;&quot; height=&quot;50&quot;&gt;&lt;/td&gt; &lt;td&gt;$&#123;book.bookName&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.bookAuthor&#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatNumber value=&quot;$&#123;book.bookPrice&#125;&quot; type=&quot;currency&quot; /&gt;&lt;/td&gt; &lt;td&gt;$&#123;book.bookStock&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.bookDesc&#125;&lt;/td&gt; &lt;td&gt; &lt;c:if test=&quot;$&#123;book.bookType ==1&#125;&quot;&gt;原创&lt;/c:if&gt; &lt;c:if test=&quot;$&#123;book.bookType ==2&#125;&quot;&gt;翻译&lt;/c:if&gt; &lt;/td&gt; &lt;td&gt; &lt;a href=&quot;BookQueryServlet?bookId=$&#123;book.bookId&#125;&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;BookDeleteServlet?bookId=$&#123;book.bookId&#125;&quot; onclick=&quot;javascript:return confirm(&#x27;你确定删除吗？&#x27;)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;!-- 显示分页效果及页码切换 --&gt; &lt;tr height=&quot;50&quot;&gt; &lt;td colspan=&quot;9&quot; align=&quot;center&quot;&gt; &lt;!--显示首页、上一页：如果当前页就是第一页，则不显示超链接--&gt; &lt;c:if test=&quot;$&#123;pageNum ==1 &#125;&quot;&gt; &lt;label style=&quot;color:gray&quot;&gt;首页&lt;/label&gt; &lt;label style=&quot;color:gray&quot;&gt;上一页&lt;/label&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pageNum &gt; 1 &#125;&quot;&gt; &lt;a href=&quot;BookListServlet?pageNum=1&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;BookListServlet?pageNum=$&#123;pageNum-1&#125;&quot;&gt;上一页&lt;/a&gt; &lt;/c:if&gt; &lt;!-- 显示页码 和总页数 --&gt; 当前第$&#123;pageNum&#125;页/共$&#123;pageCount&#125;页 &lt;!-- 显示下一页 和 尾页 --&gt; &lt;c:if test=&quot;$&#123;pageNum &lt; pageCount&#125;&quot;&gt; &lt;a href=&quot;BookListServlet?pageNum=$&#123;pageNum+1&#125;&quot;&gt;下一页&lt;/a&gt; &lt;a href=&quot;BookListServlet?pageNum=$&#123;pageCount&#125;&quot;&gt;尾页&lt;/a&gt; &lt;/c:if&gt; &lt;c:if test=&quot;$&#123;pageNum == pageCount&#125;&quot;&gt; &lt;label style=&quot;color:gray&quot;&gt;下一页&lt;/label&gt; &lt;label style=&quot;color:gray&quot;&gt;尾页&lt;/label&gt; &lt;/c:if&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 7.4 PageHelper封装 思考： 分页操作在Service查询页面数据及总页码都属同一个分页业务，为什么要携程两个方法呢？能不能在一个方法完成呢？ Servlet类主要负责流程控制，在上述代码实现过程中也涉及到了分页业务，不可理。该如何解决呢？ 7.4.1 PageHelper封装思路 7.4.2 创建分页帮助类PageHelper123456789101112131415161718192021222324package com.qfedu.bookmall.ms.utils;import java.util.List;/** * @Description 分页帮助类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class PageHelper&lt;T&gt; &#123; //存放页面数据的List集合 public List&lt;T&gt; list; //存放当前页码 public int pageNum; //存放总页数 public int pageCount; //无参构造器 //全参构造器 //get和set&#125; 7.4.3 BookService1234567891011121314151617181920212223/** * 分页查询图书信息 * @param pageNum 页码 * @param pageSize 每页显示的条数 * @return */public PageHelper&lt;Book&gt; listBooksByPage( int pageNum,int pageSize)&#123; //1.查询当前页码的数据 int start = (pageNum-1)*pageSize; int limit = pageSize; List&lt;Book&gt; bookList = bookDAO.selectBooks(start,limit); //2.查询并计算图书总页数 //a.查询总记录 long count = bookDAO.selectBookCount(); //b.根据总记录数和每页显示的条数，计算总页数 long pageCount = count%pageSize == 0 ? count/pageSize: count/pageSize+1; //3.将分页数据都放到一个PageHelper对象 PageHelper&lt;Book&gt; bookPageHelper = new PageHelper&lt;Book&gt;(bookList, pageNum, (int)pageCount); return bookPageHelper;&#125; 7.4.4 BookListServlet12345678910111213141516171819202122232425262728293031/** * @Description 分页查询图书信息 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/BookListServlet&quot;)public class BookListServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收客户端传递的页码 // (如果客户端没有传递页码，则默认页码为1，如果传递了则使用客户端传递的页码) String num = request.getParameter(&quot;pageNum&quot;); int pageNum = num==null? 1: Integer.parseInt( num ); //2.定义pageSize int pageSize = 10; //3.调用BookService查询这一页的图书信息 BookService bookService = new BookService(); PageHelper&lt;Book&gt; bookPageHelper = bookService.listBooksByPage(pageNum, pageSize); //5.将查询到的bookPageHelper(当前页数据的集合、当前页码、总页数) 转发到book-list.jsp request.setAttribute(&quot;bookPageHelper&quot;,bookPageHelper); request.getRequestDispatcher(&quot;book-list.jsp&quot;).forward(request,response); &#125;&#125; 7.4.5 book-list.jsp book-list.jsp 页面的数据都从bookPageHelper对象获取","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"http://example.com/tags/JSP/"}]},{"title":"day07-Servlet","slug":"day07-Servlet","date":"2022-09-16T15:30:01.000Z","updated":"2022-09-28T11:37:23.405Z","comments":true,"path":"2022/09/16/day07-Servlet/","link":"","permalink":"http://example.com/2022/09/16/day07-Servlet/","excerpt":"","text":"一、web服务器 思考：我们设计好的的网页如何才能够让互联网用户通过浏览器访问呢？ 1.1 什么是web服务器？ web服务器就是web项目的容器，我们将开发好的web项目部署到web容器中，才能使用网络中的用户通过浏览器进行访问。 1.2 静态资源和动态资源 web项目中的资源根据其特性可以分为两类： 静态网页：网页界面中的数据始终保持不变（HTML&#x2F;CSS&#x2F;JS&#x2F;图片） 动态网页：网页中的数据根据用户不同的请求可以会发生变化，也就是说网页中的数据是由程序根据用户的请求意图动态产生的 1.3 常用服务器产品 Tomcat（Apache开源，主流的web服务器之一，多应用于Javaweb项目开发） Jetty（运行效率高于Tomcat） WebLogic (Oracle，收费) WebSpere(IBM) Nginx（web静态资源服务器） 1.4 Tomcat简介Tomcat是Apache开源组织（apache.org）共享的Jakarta项目中的一个核心向，Tomcat开源免费、支持Java中的动态网页技术Servlet和JSP规范，因此Java开发者多使用Tomcat. Tomcat目前最新版本是10.1（alpha），在企业主流使用8.5和9，我们的学习主要基于8.5.72版本；各个版本之间的最大区别就是对于JavaEE版本及Servlet规范的支持、依赖的JDK版本。Tomcat8.x全面支持Servlet3.x规范及JavaEE4规范。 Tomcat基于其先进的技术、稳定的性能深受Java开发者的青睐。 Tomcat官网：https://tomcat.apache.org/ 1.5 Tomcat的安装1.5.1 下载(Tomcat v8.5.72)下载页面地址：https://tomcat.apache.org/download-80.cgi 1.5.2 解压安装 如果下载的是压缩包，则解压即可使用 解压注意事项： 建议解压的目标目录层级不要多 不建议解压到中文目中 1.5.3 Tomcat的目录结构 bin 该目录存放的是可执行的二进制文件(startup.bat用于启动Tomcat、shutdown.bat用于停止Tomcat) conf 存放的是Tomcat的配置文件（server.xml可以配置Tomcat的端口，web.xml） lib 此目录存放了Tomcat服务器运行web项目所需的基础类库 logs 存放Tomcat服务器的运行日志、记录了服务器启动、运行异常及关闭等操作的记录 temp 临时目录，存放Tomcat运行过程中产生的临时文件 webapps 存放Tomcat管理的web项目的目录，此目录中默认部署了Tomcat管理器等几个web项目 work Tomcat可以运行动态网页，动态网页就是在服务器上将数据加载到网页生成的页面，此目录就是存放Tomcat生成的文件 1.6 Tomcat启动和关闭方式1：双击运行...\\apache-tomcat-8.5.72\\bin\\starup.bat 关闭窗口，服务器就关闭了 方式2：双击运行...\\apache-tomcat-8.5.72\\bin\\tomcat8.exe 关闭窗口，服务器就关闭了 方式3：双击运行...\\apache-tomcat-8.5.72\\bin\\tomcat8w.exe (这种方式启动服务器之后，如果关闭了窗口，服务器依然在运行，我们就不能重复启动) Tomcat无法启动： Tomcat是基于Java语言的web服务器，它的运行需要依赖JDK，因此在安装Tomcat之前要确保计算机上安装了JDK并正确配置环境变量（特别是JAVA_HOME这个一定要配置正确） 1.7 web项目部署 web项目部署：将web项目交给Tomcat管理，当用户访问Tomcat时，Tomcat可以将web项目中的资源响应给用户浏览器。 方式1：直接将web项目拷贝到Tomcat的webapps目录 （访问路径就是项目名） 方式2：将web项目的路径配置到Tomcat中 拷贝web项目的路径 E:\\JavaWeb\\workspace\\html\\demo1 在Tomcat的conf目录中Catalina\\localhost创建一个xml文件（xml文件名可以自定义，建议和项目名称一致） 在xml文件中如下配置： path配置web项目的访问路径 docBase配置web项目的目录路径 1&lt;Context path=&quot;/demo1&quot; docBase=&quot;E:\\JavaWeb\\workspace\\html\\demo1&quot;&gt;&lt;/Context&gt; 1.8 浏览器访问web服务器 部署项目完成之后，建议可以重启一次Tomcat 打开浏览器输入网址：http://host-ip:tomcat-port/web-Path/index.html http:// web服务的HTTP传输协议 host-ip 服务器所在计算机的IP tomcat-port Tomcat服务器占用的网络端口（默认8080，可以在conf/server.xml中修改端口），如果tomcat端口为80，则可以省略 web-Path Tomcat中部署的web项目的访问路径 如果是直接将项目拷贝到 tomcat的 webapps中，并且没有进行其他配置，这个路径就是项目文件夹名称 如果是通过在Catalina\\localhost配置xml文件的形式部署项目，则项目的访问路径就是Context标签path属性的值 示例： http://192.168.155.1:8080/wolf/index.html http://192.168.155.1:8080/demo1/hw_login.html 1.9 Tomcat服务器请求响应流程 1.10 Tomcat端口配置 Tomcat默认端口是8080，我们可以通过修改conf/server.xml配置文件，修改服务器端口； 端口可以是1~65535中的数字，但是2000以下的很多端口被系统服务绑定，建议不要使用； 如果将服务器端口修改为80，则浏览器访问的时候无需添加端口号http://192.168.155.1/wolf/index.html 1234&lt;!--conf/server.xml 69行--&gt;&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 二、HTTP协议 web服务器可以接受浏览器的请求，并将服务器中的web项目资源响应给浏览器，浏览器与服务器之间进行网络通信遵循HTTP协议。 2.1 什么是HTTP协议？超文本传输协议（HTTP，HyperText Transfer Protocol） （ 浏览器—-&gt; web服务器） 网络中的通信协议： TCP协议，基于连接的安全传输协议 （客户端和服务器先建立连接，再通过连接发送数据） UDP协议，基于广播&#x2F;分发的非安全传输协议 （不会建立网络连接） HTTP超文本传输协议是运行于TCP协议的基础之上、基于请求与响应模式、无状态的应用层协议，是互联网中应用最为广泛的一种网络协议。 2.2 HTTP协议特点 基于连接通信：当浏览器与服务器进行通信时，会首先建立网络连接，通过网络连接进行通信 短连接：在HTTP1.0中，浏览器向服务器发送请求，建立连接，但是这个连接只作用于浏览器和服务器的一次请求响应，这次请求响应完成之后则断开连接。 长连接：在HTTP1.1中，浏览器请求与服务器建立连接、进行请求和响应之后，会等待几秒钟，在这几秒内如果浏览器有新的请求，则直接使用之前的这个连接进行请求和数据响应，如果过了几秒钟没有新的请求，则将连接断开。 请求与响应模式：首先由浏览器向服务器发送请求，服务器再对请求进行响应，如果没有浏览器的请求服务器是不会主动向浏览器进行响应的。 无状态：服务器不会感知同一个客户端的多次请求（就是当服务器接收到客户端请求之后，不能识别这个客户端是否请求我） 简单灵活：实现简便、可以传输不同类型的数据（客户端—-文件\\文本—-&gt;服务器） 2.3 HTTP协议通信规则 通信协议：客户端与服务器之间共同遵守的规则 HTTP协议是就请求和响应模式，浏览器向服务器发送请求时，需要准守HTTP请求规则，服务器对浏览器进行响应时也遵守HTTP响应规则。 2.3.1 http请求规则 说明：当在浏览器中发送请求时，浏览器已经实现了HTTP请求协议，基于这个协议发送请求的。 通过浏览器查看步骤（这种方式没法查看到所有的HTTP请求内容）： 打开浏览器 F12打开调试窗口、点击 network 在浏览器输入网址进行访问 在network窗口中查看请求头信息（Request Headers） 通过自定义的HTTP服务器，接收浏览器请求，查看HTTP请求规则： 自定义HTTP服务器 12345678910111213141516171819202122232425262728293031323334package com.qfedu.http.request;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.ServerSocket;import java.net.Socket;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */public class MyHttpServer &#123; public static void main(String[] args) throws IOException &#123; //创建一个网络服务器（可以通过浏览器请求这个服务） ServerSocket serverSocket = new ServerSocket(9999); //当浏览器请求我这个服务器之后，就建立网络连接（socket对象） Socket socket = serverSocket.accept(); //通过socket对象的输入流， InputStream inputStream = socket.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); //读取 浏览器发送的 HTTP请求 String content = null; while( (content = reader.readLine())!=null)&#123; System.out.println(content); &#125; //暂时未浏览器请求进行响应 &#125;&#125; HTTP请求内容： 2.3.2 http响应规则 自定义“浏览器”查看HTTP响应规则 自定义“浏览器” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.qfedu.http.response;import jdk.internal.util.xml.impl.Input;import java.io.*;import java.net.Socket;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */public class MyBrowser &#123; public static void main(String[] args) throws IOException &#123; //将上一个案例中浏览器发送给 MyHttpServer的 http请求内容，发送给百度 // 1.向百度服务器发送链接请求 Socket socket = new Socket(&quot;www.baidu.com&quot;, 80); // 2.通过链接中的输出流，将HTTP请求内容发送给百度 OutputStream outputStream = socket.getOutputStream(); PrintWriter out = new PrintWriter(outputStream); out.println(&quot;GET /s HTTP/1.1&quot;); out.println(&quot;Host: www.baidu.com:80&quot;); out.println(&quot;Connection: keep-alive&quot;); out.println(&quot;sec-ch-ua: \\&quot;Google Chrome\\&quot;;v=\\&quot;95\\&quot;, \\&quot;Chromium\\&quot;;v=\\&quot;95\\&quot;, \\&quot;;Not A Brand\\&quot;;v=\\&quot;99\\&quot;&quot;); out.println(&quot;sec-ch-ua-mobile: ?0&quot;); out.println(&quot;sec-ch-ua-platform: \\&quot;Windows\\&quot;&quot;); out.println(&quot;Upgrade-Insecure-Requests: 1&quot;); out.println(&quot;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36&quot;); out.println(&quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;); out.println(&quot;Sec-Fetch-Site: none&quot;); out.println(&quot;Sec-Fetch-Mode: navigate&quot;); out.println(&quot;Sec-Fetch-User: ?1&quot;); out.println(&quot;Sec-Fetch-Dest: document&quot;); out.println(&quot;Accept-Encoding: gzip, deflate, br&quot;); out.println(&quot;Accept-Language: zh-CN,zh;q=0.9&quot;); out.println(&quot;&quot;); out.flush(); //3.通过输入流接受百度的响应数据（HTTP响应规则） BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); String responseContent = null; while( (responseContent = reader.readLine())!=null)&#123; System.out.println(responseContent); &#125; &#125;&#125; HTTP响应内容 使用自定义HTTP服务器响应浏览器请求（遵循HTTP响应规则） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.qfedu.http.request;import java.io.*;import java.net.ServerSocket;import java.net.Socket;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */public class MyHttpServer &#123; public static void main(String[] args) throws IOException &#123; //创建一个网络服务器（可以通过浏览器请求这个服务） ServerSocket serverSocket = new ServerSocket(9999); //当浏览器请求我这个服务器之后，就建立网络连接（socket对象） Socket socket = serverSocket.accept(); //通过socket对象的输入流， InputStream inputStream = socket.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); //读取 浏览器发送的 HTTP请求 String content = null; while( !&quot;&quot; .equals(content = reader.readLine()))&#123; System.out.println(content); &#125; // 自定义HTTP服务器响应浏览器 PrintWriter out = new PrintWriter(socket.getOutputStream()); out.println(&quot;HTTP/1.1 200 OK&quot;); out.println(&quot;Connection: keep-alive&quot;); out.println(&quot;Content-Length: 154&quot;); out.println(&quot;Content-Type: text/html;charset=utf-8&quot;); out.println(&quot;Date: Sun, 07 Nov 2021 17:52:42 GMT&quot;); out.println(&quot;Location: https://www.baidu.com/&quot;); out.println(&quot;P3p: CP=\\&quot; OTI DSP COR IVA OUR IND COM \\&quot;&quot;); out.println(&quot;P3p: CP=\\&quot; OTI DSP COR IVA OUR IND COM \\&quot;&quot;); out.println(&quot;Server: BWS/1.1&quot;); out.println(&quot;X-Frame-Options: sameorigin&quot;); out.println(&quot;X-Ua-Compatible: IE=Edge,chrome=1&quot;); out.println(&quot;&quot;); out.println(&quot;&lt;!DOCTYPE html&gt;&quot;); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;title&gt;这是自定义服务器响应的页面&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;label style=&#x27;color:red&#x27;&gt;这是自定义服务器响应的内容&lt;/label&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); out.close(); &#125;&#125; 2.4 HTTP响应状态码 当浏览器向服务器发送请求、服务器对浏览器进行响应时，会响应给浏览器一个状态码,不同的状态码表示服务器对请求的不同处理。 2.4.1 响应状态码分类 1xx 表示浏览器请求服务器，服务器未做任何操作 2xx 表示服务器正常响应，并且响应成功 3xx 表示服务器只对浏览器的请求进行了部分处理，通知浏览器进行下一步操作 4xx 表示浏览器端（客户端）错误：404、401 5xx 表示服务器端资源错误 2.4.2 常见状态码 200 表示响应成功 302 表示服务器临时重定向 304 表示服务器资源没有变化 404 访问的资源不存在 500 访问的服务器端资源错误 三、Servlet基础使用3.1 Servlet简介 问题：浏览器可以通过http协议请求web服务器，访问web服务器上的web资源，web资源又分为静态资源和动态资源，静态资源可以直接存储在web服务器上供浏览器访问，动态资源该如何访问呢 ？ Servlet是服务器端的Java程序、能够接收HTTP请求、处理HTTP请求、并对HTTP请求进行响应的动态网页技术。 Servlet是JavaEE（JavaWeb）规范的一个重要组成部分。 Servlet的作用： 接收客户端的HTTP请求（浏览器） 根据用户请求进行数据处理 动态生成网页（网页中的数据是根据客户端请求动态改变的） 将生成的包含动态数据的网页响应给客户端 3.2 创建Java web工程 Servlet是JavaEE规范的一部分，Servlet的开发需要依赖JavaEE环境，之前创建的单纯的Java应用已经不能满足Servlet开发所需的环境需求，我们要创建Java web工程。 Java工程 ： 只引入了JDK的标准库（JavaSE） Java web工程：引入了Java企业级开发环境（JavaEE） File—&gt;New—&gt;Project… 选择Java Enterprise 如何配置Tomcat ? 点击New按钮，选择Tomcat Server 配置Tomcat服务器 选择 web application项目框架及版本 输入项目名称 Java web工程目录 3.3 创建Servlet类 Servlet是一个Java程序，是一个能够接收HTTP请求的Java类，因此需要实现HTTP协议。 在JavaEE库中有一个类 javax.servlet.http.HttpServlet实现了HTTP协议，我们创建的类只要继承这个 HttpServlet类，就实现了HTTP协议，就能够接受HTTP请求。 创建一个类继承javax.servlet.http.HttpServlet； 继承HttpServlet的类就能够接收HTTP请求，我们把这样的类称之为Servlet类，类以***Servlet格式命名； 在我们创建的Servlet类中，重写doPost&#x2F;doGet用于处理用户不同的请求 3.4 配置Servlet类的URL Servlet创建完成之后，需要配置url访问路径，然后将web项目运行在Tomcat之上，就能够通过配置的url访问Servlet类。Servlet自3.0规范开始支持两种配置方式： 基于web.xml配置文件进行配置 基于注解配置 3.4.1 基于web.xml配置Servlet 打开Java web工程中web/WEB-INF/web.xml文件 配置如下： 123456789101112131415161718&lt;!-- 配置BookListServlet类的访问路径 --&gt;&lt;!-- servlet标签： 配置类路径 --&gt;&lt;servlet&gt; &lt;!-- 配置与servlet-mapping标签的匹配表示，理论上可以是任意字符串， 只要多个servlet标签的servlet-name不重复就可以，实际开发中建议使用当前Servlet类 --&gt; &lt;servlet-name&gt;BookListServlet&lt;/servlet-name&gt; &lt;!--Servlet类路径--&gt; &lt;servlet-class&gt;com.qfedu.test1.BookListServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- servlet-mapping标签：配置url--&gt;&lt;servlet-mapping&gt; &lt;!--servlet-mapping标签的servlet-name属性与对应的 servlet标签的servlet-name属性一致--&gt; &lt;servlet-name&gt;BookListServlet&lt;/servlet-name&gt; &lt;!-- url-pattern配置Servlet的访问路径，必须以 / 开头 --&gt; &lt;url-pattern&gt;/book-list&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3.4.2 基于注解配置Servlet 在创建的Servlet类上添加@WebServlet注解，在注解后的参数中配置url，url也必须以/开头 1234567891011121314151617181920/** * @Description 根据图书ID查询一个图书信息 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/book-query&quot;)public class BookQueryServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;BookQueryServlet--------doPost&quot;); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;BookQueryServlet--------doGet&quot;); &#125;&#125; 3.5 IDEA部署web项目 通过IDEA，将java web项目部署到Tomcat中并运行Tomcat。 3.5.1 配置服务器 File—Settings 3.5.2 部署web项目 将web项目部署到Tomcat 点击IDEA右上角： 添加Tomcat服务器 部署项目 配置web项目的访问路径 3.5.3 启动Tomcat如果在创建web项目时选择了web服务器，则直接点击IDEA右上角运行即可： 播放按钮：直接运行 甲壳虫：debug运行 3.5.4 Tomcat启动完成工作 构建web项目 将web项目拷贝到Tomcat 启动Tomcat 打开浏览器，访问当前项目首页 3.6 浏览器访问测试 通过浏览器发送HTTP请求，访问tomcat中web项目中的Servlet类 3.7 GET请求与POST请求 Servlet类中的doGet和doPost是用来处理浏览器不同请求方式的HTTP请求，在HTTP协议中，HTTP请求有多种请求方式（get\\post\\delete\\put\\option等），不同请求方式传递的数据是不同的。 Servlet中的doGet方法用于处理客户端的get方式请求 Servlet中的doPost方法用于处理客户端的post方式请求 3.7.1 GET请求 使用Get方式请求服务器，传递的参数会拼接到URL后面，以?分隔url和参数,多个参数以&amp;符号分开； 12345&lt;form action=&quot;https://www.baidu.com&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;id&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;get提交&quot;/&gt;&lt;br/&gt;&lt;/form&gt; get方式是明文提交、提交的数据量小、安全性较差； get方式传输效率较高，浏览器地址栏输入网址默认采用get方式提交 get方式提交数据的场景： 浏览器地址栏 网页中的超链接 1&lt;a href=&quot;http://localhost:80/demo1/book-query&quot;&gt;请求BookQueryServlet&lt;/a&gt; form表单 method&#x3D;”get”提交 3.7.2 POST请求 使用POST方式请求服务器，参数是通过请求正文进行传递的（request body）； 12345&lt;form action=&quot;http://localhost:9999&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;id&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;POST提交&quot;/&gt;&lt;br/&gt;&lt;/form&gt; POST使用密文传递数据，数据量大，安全性高； POST以牺牲传输效率为代价保障了安全性，因此性能较get低。 POST提交数据的场景：form表单 method&#x3D;”post”提交 3.8 Servlet响应动态网页 案例：根据客户端请求的bookId,动态查询图书信息，生成HTML文档，响应给客户端 流程图 实现代码： 1234567891011121314151617package com.qfedu.test1.dto;/** * @Description 图书实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Book &#123; private String bookId; private String bookName; private String bookAuthor; private double bookPrice; private String bookImgPath; //无参构造器 //全参构造器 //get 和 set方法&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.qfedu.test1;import com.qfedu.test1.dto.Book;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.HashMap;import java.util.Map;/** * @Description 根据图书ID查询一个图书信息 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/book-query&quot;)public class BookQueryServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;BookQueryServlet--------doPost&quot;); &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;BookQueryServlet--------doGet&quot;); //动态生成HTML // 1.接收到浏览器请求时传递的图书ID (bookId) String bid = request.getParameter(&quot;bookId&quot;); // 2.根据bid查询数据库图书表(伪代码) Map&lt;String, Book&gt; bookMap = new HashMap&lt;&gt;(); bookMap.put(&quot;1001&quot;,new Book(&quot;1001&quot;,&quot;Java&quot;,&quot;张三&quot;,55.66,&quot;&quot;)); bookMap.put(&quot;1002&quot;,new Book(&quot;1002&quot;,&quot;C++&quot;,&quot;李四&quot;,33.44,&quot;&quot;)); bookMap.put(&quot;1003&quot;,new Book(&quot;1003&quot;,&quot;Python&quot;,&quot;王五&quot;,44.55,&quot;&quot;)); // book就是根据用户请求查询到的动态数据 Book book = bookMap.get(bid); // 3.将查询到图书信息生成网页，将网页响应给浏览器：通过IO流（输出流）向浏览器响应一个网页数据 // 这个out对象，就是用于响应浏览器的输出流，通过这个输出流写出什么数据，浏览器就可以接受到什么数据 // a.设置响应头 response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html&quot;); // b.通过输出流响应网页数据 PrintWriter out = response.getWriter(); out.println(&quot;&lt;!DOCTYPE html&gt;&quot;); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&lt;meta charset=&#x27;utf-8&#x27;&gt;&lt;title&gt;这是Servlet响应的网页&lt;/title&gt;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;table style=&#x27;border:1px deepskublue solid; width:1000px;&#x27; align=&#x27;center&#x27; border=&#x27;1&#x27; cellspacing=&#x27;0&#x27;&gt;&quot;); out.println(&quot;&lt;tr&gt;&lt;th&gt;图书编号&lt;/th&gt;&lt;th&gt;图书名称&lt;/th&gt;&lt;th&gt;图书作者&lt;/th&gt;&lt;th&gt;图书价格&lt;/th&gt;&lt;th&gt;图书封面&lt;/th&gt;&lt;/tr&gt;&quot;); out.println(&quot;&lt;tr&gt;&quot;); out.println(&quot;&lt;td&gt;&quot;+book.getBookId()+&quot;&lt;/td&gt;&quot;); out.println(&quot;&lt;td&gt;&quot;+book.getBookName()+&quot;&lt;/td&gt;&quot;); out.println(&quot;&lt;td&gt;&quot;+book.getBookAuthor()+&quot;&lt;/td&gt;&quot;); out.println(&quot;&lt;td&gt;&quot;+book.getBookPrice()+&quot;&lt;/td&gt;&quot;); out.println(&quot;&lt;td&gt;&quot;+book.getBookImgPath()+&quot;&lt;/td&gt;&quot;); out.println(&quot;&lt;/tr&gt;&quot;); out.println(&quot;&lt;/table&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); out.close(); &#125;&#125; 四、Servlet原理解析4.1 ServletAPI核心类与接口 4.2 Servlet类处理请求的流程准备工作： 新建一个Javaweb工程：servlet-demo2 新建一个Servlet类：TestServlet 12345创建servlet类的步骤：1.创建一个命名为 **Servlet2.继承javax.servlet.http.HttpServlet类3.重写doGet和doPost方法4.配置当前Servlet类的访问路径 12345678&lt;servlet&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.qfedu.servlets.TestServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/test&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 为了测试Servlet处理请求的流程，我们重写了从HttpServlet继承的多个方法： init service(ServletRequest,ServletResponse) service(HttpServletRequest,HttpServletResponse) doGet doPost destroy 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.qfedu.servlets;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 * * 创建servlet类的步骤： * 1.创建一个命名为 **Servlet * 2.继承javax.servlet.http.HttpServlet类 * 3.重写doGet和doPost方法 * 4.配置当前Servlet类的访问路径 */public class TestServlet extends HttpServlet &#123; @Override public void init(ServletConfig config) throws ServletException &#123; System.out.println(&quot;------------init&quot;); super.init(config); &#125; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; System.out.println(&quot;------------Servlet接口定义的service&quot;); super.service(req, res); &#125; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;------------HttpServlet类定义的service&quot;); super.service(req, resp); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;------------doGet&quot;); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;------------doPost&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;------------destroy&quot;); super.destroy(); &#125;&#125; Servlet请求处理流程 4.3 Servlet实例的生命周期[重点] 当客户端的请求到达Tomcat，Tomcat会创建一个线程来接收、处理、响应客户端请求，客户端在请求某个Servlet类时，线程需要通过这个Servlet类的实例来调用service方法、调用doGet&#x2F;doPost..方法来处理响应请求，这个Servlet类的实例是何时创建、何时销毁的呢？ Servlet实例的生命周期指的是一个Servlet类的实例从创建到销毁的过程。 Servlet类是单实例多线程的，一个Servlet类自始至终只会创建一个对象； 如果当前Servlet类没有配置 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;: 当客户端第一次请求Servlet时，创建当前Servlet类的实例，然后使用这个实例调用service(ServletRequest, ServletResponse)方法——service(HttpServletRequest, HttpServletResponse)方法——doGet&#x2F;doPost处理客户端请求;当客户端请求再次到达时将不会重新创建Servlet实例，直接使用第一次创建的实例调用方法进行响应； 如果当前Servlet类配置了 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;: 当服务器启动时就会创建Servlet类的实例，无论客户端第一次请求这个Servlet类，还是再次请求都不会创建Servlet类实例，直接使用服务器启动时创建的Servlet实例来接收、处理、响应客户端请求； 当服务器关闭时，Serlvet类的实例会被销毁。 配置load-on-startup的两种方式： xml配置 12345678910&lt;servlet&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.qfedu.servlets.TestServlet&lt;/servlet-class&gt; &lt;!--如果有多个Servlet都配置了load-on-startup，里面的数字就是在服务器中创建实例的顺序--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/test&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 注解配置： 1@WebServlet(value = &quot;/test&quot;,loadOnStartup = 1) 4.4 线程安全问题 因为Servlet实例是单例模式，当多个客户端并发访问同一个Servlet类时，Tomcat会创建多个线程，多个线程会使用同一个Servlet实例，有可能会导致线程安全问题，如何保证线程安全呢？ 4.4.1 方案1：实现SingleThreadModel接口 我们可以让Servlet类实现SingleThreadModel接口，每个线程都会创建servlet实例，避免了多线程使用通过Servlet实例的请求，但是使用这种方式会导致对客户端的请求响应效率变低，增加了服务器因频繁创建和销毁Servlet实例的开销，因此此种方式不建议使用，已经过时。 4.4.2 方案2：使用synchronized同步锁123456@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) &#123; synchronized (this) &#123; // 业务代码 &#125;&#125; 4.4.3 建议：在Servlet实例中尽量不使用成员变量 如果将变量定义为成员变量，则这个变量在多个线程中是共享的，就有可能因为多个线程同时修改这个变量导致并发问题，因此我们可以将变量定义在处理业务的doXX方法中，定义为局部变量之后，每个线程都有属于自己的局部变量。 五、Servlet开发技术 Servlet动态网页技术，为客户端请求提供动态响应： Servlet如何接收客户端请求 Servlet如何为客户端提供响应 5.1 HttpServletRequest对象 我们在Servlet类中的doGet&#x2F;doPost&#x2F;doXX 方法中通过 request 对象接收客户端请求信息. 客户端向服务器发送的请求信息都会被封装到request对象，request（HttpServletRequest类）提供了多个方法可以用于获取http请求中的数据。 5.1.1 接收请求数据 5.1.2 request对象常用方法接收请求行数据 123456789101112//getMethod:获取客户端请求方式String method = request.getMethod();//getRequestURL: 获取客户端的请求URL（不包含url上的参数）String url = request.getRequestURL().toString();//getParameter : 获取请求行中url参数，根据参数的key获取参数的value// 如果客户端是通过输入框提交数据，则参数要和输入框的name属性值一致String p1 = request.getParameter(&quot;k1&quot;);//getProtocol ：获取客户端提交数据的协议及版本String protocol = request.getProtocol(); 接收请求头数据 12345678//getHeaderNames ：获取请求头中所有的keyEnumeration&lt;String&gt; en = request.getHeaderNames();while(en.hasMoreElements())&#123; String key = en.nextElement(); //getHeader ： 根据请求头中的key获取对应value String value = request.getHeader(key); System.out.println(key+&quot;:&quot;+value);&#125; 接收请求正文数据 1234567// 获取请求正文// getInputStream ：获取客户端请求的输入流ServletInputStream inputStream = request.getInputStream();BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));// 从输入流中读取请求正文String s = reader.readLine();System.out.println(s); 5.1.3 request对象接收表单数据案例 图书添加操作：需要从图书添加页面提交数据到Servlet book-add.html 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;提交图书&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;http://localhost/demo3/BookAddServlet&quot; method=&quot;get&quot;&gt; &lt;p&gt;图书编号：&lt;input type=&quot;text&quot; name=&quot;bookId&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书作者：&lt;input type=&quot;text&quot; name=&quot;bookAuthor&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书价格：&lt;input type=&quot;text&quot; name=&quot;bookPrice&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Get提交&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;hr/&gt; &lt;form action=&quot;http://localhost/demo3/BookAddServlet&quot; method=&quot;post&quot;&gt; &lt;p&gt;图书编号：&lt;input type=&quot;text&quot; name=&quot;bookId&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书作者：&lt;input type=&quot;text&quot; name=&quot;bookAuthor&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书价格：&lt;input type=&quot;text&quot; name=&quot;bookPrice&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Post提交&quot;/&gt;&lt;/p&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; BookAddServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;/** * @Description 添加图书 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/BookAddServlet&quot;)public class BookAddServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //getParameter 方法参数字符串 必须要和 form表单中输入框的name属性一致 // 此方法获取的客户端提交的数据一律为String类型，根据需要可以进行类型转换 int id = Integer.parseInt(request.getParameter(&quot;bookId&quot;));//5 String name = request.getParameter(&quot;bookName&quot;); String author = request.getParameter(&quot;bookAuthor&quot;); double price = Double.parseDouble(request.getParameter(&quot;bookPrice&quot;)); System.out.println(&quot;图书编号:&quot;+id); System.out.println(&quot;图书名称:&quot;+name); System.out.println(&quot;图书作者:&quot;+author); System.out.println(&quot;图书价格:&quot;+price); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 如果页面采用form表单post方式提交数据，数据是通过 请求正文 传递的 // 1.我们可以通过请求正文获取数据 //ServletInputStream inputStream = request.getInputStream(); //BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); //String s = reader.readLine(); //System.out.println(&quot;请求正文数据：&quot;+s); // 2.form表单post方式提交的数据，也可以通过request对象的getParameter方法接收， // 之前是不能打开request输入流 int id = Integer.parseInt(request.getParameter(&quot;bookId&quot;));//5 String name = request.getParameter(&quot;bookName&quot;); String author = request.getParameter(&quot;bookAuthor&quot;); double price = Double.parseDouble(request.getParameter(&quot;bookPrice&quot;)); System.out.println(&quot;图书编号:&quot;+id); System.out.println(&quot;图书名称:&quot;+name); System.out.println(&quot;图书作者:&quot;+author); System.out.println(&quot;图书价格:&quot;+price); &#125;&#125; 5.1.4 request对象处理中文乱码问题 客户端向服务器的Servlet类提交数据中包含中文，可能会出现中文乱码问题 1. 为什么会产生乱码问题？ 客户端提交的数据通过网络发送到服务器，传输的过程数据数据通常会进行编码，服务器会对数据进行解码；如果服务器使用的解码方式与网页的原始编码不一致，将会导致服务器的解码出现乱码 2.get方式提交数据的乱码问题 get方式提交的数据会拼接在请求行的URL后面进行传递，不同的浏览器处理方式是不一样的，有的浏览器会进行编码，有的浏览器则直接提交； 数据到达服务器之后，服务器会根据参数的编码方式对参数进行解码，如果没有编码则服务器直接接受，如果进行了服务器能够解析的编码，服务也会进行转换。 结论：GET方式提交的请求行参数，是通过服务器进行处理的。 解决方案：在Tomcat的conf&#x2F;server.xml中配置URL的编码方式 123&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;utf-8&quot; /&gt; 3.post方式提交数据的乱码问题 post方式提交表单数据是通过请求正文进行传递的，会对数据进行编码；Tomcat会对URL传递的参数进行解码，但是不能对请求正文进行解码，因此需要我们在Servlet类中接收数据之前对客户端提交的请求数据进行编码设置: request.setCharacterEncoding(&quot;utf-8&quot;); 页面表单提交数据-post方式提交： 1234567&lt;form action=&quot;http://localhost/demo3/BookAddServlet&quot; method=&quot;post&quot;&gt; &lt;p&gt;图书编号：&lt;input type=&quot;text&quot; name=&quot;bookId&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书作者：&lt;input type=&quot;text&quot; name=&quot;bookAuthor&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书价格：&lt;input type=&quot;text&quot; name=&quot;bookPrice&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Post提交&quot;/&gt;&lt;/p&gt;&lt;/form&gt; Servlet类对post提交的数据进行编码设置： 123456789101112protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //在servlet中接收数据之间，通过request对象设置http请求数据的编码方式 request.setCharacterEncoding(&quot;utf-8&quot;); int id = Integer.parseInt(request.getParameter(&quot;bookId&quot;)); String name = request.getParameter(&quot;bookName&quot;); String author = request.getParameter(&quot;bookAuthor&quot;); double price = Double.parseDouble(request.getParameter(&quot;bookPrice&quot;));&#125; 5.2 HttpServletResponse对象 Servlet类中doGet&#x2F;doPost&#x2F;doXX等方法都有一个HttpServletResponse对象，用于响应客户端请求 5.2.1 response对象常用方法1234567891011121314151617181920//【设置响应状态行】//setStatus : 设置状态行中的状态码response.setStatus(200);//【设置响应头】//setContentType: 设置响应头中的Content-Type属性，设置响应客户端的数据格式response.setContentType(&quot;text/html&quot;); //等价于： response.setHeader(&quot;Content-Type&quot;,&quot;text/html&quot;);//setContentLength：设置响应客户端的数据长度（一般无需设置）response.setContentLength(1024); //等价于：//setHeader ： 设置其他的响应头属性response.setHeader(&quot;Connection&quot;,&quot;keep-alive&quot;);//【设置响应正文】//setCharacterEncoding：设置响应客户端的数据编码格式response.setCharacterEncoding(&quot;utf-8&quot;);// 通过response对象获取输出流出// 字节流（如果要响应文件数据给客户端，则需要使用字节流）ServletOutputStream outputStream = response.getOutputStream();// 字符流（如果响应文本数据-HTML文档，则使用字符流）PrintWriter out = response.getWriter(); 5.2.2 查询成绩案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.Enumeration;/** * @Description 查询成绩 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/gradeQuery&quot;)public class GradeQueryServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;~~~~~~~~~~~~~~~doGet&quot;); //1.接收学号和课程编号 String stuNum = request.getParameter(&quot;stuNum&quot;); String curseId = request.getParameter(&quot;curseId&quot;); //2.查询数据库 int grade = 95; //3.通过response响应浏览器 response.setStatus(200); response.setContentType(&quot;text/html&quot;); response.setHeader(&quot;Connection&quot;,&quot;keep-alive&quot;); //【设置响应正文】 //setCharacterEncoding：设置响应客户端的数据编码格式 response.setCharacterEncoding(&quot;utf-8&quot;); // 通过response对象获取输出流出 PrintWriter out = response.getWriter(); //通过流写出的数据，就会以响应正文的形式传输给客户端浏览器，如果浏览器可以识别数据，则直接显示 out.println(&quot;&lt;!DOCTYPE html&gt;&quot;); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;meta charset=&#x27;utf-8&#x27;&gt;&quot;); out.println(&quot;&lt;title&gt;学生成绩查询结果&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;div style=&#x27;padding:50px; font-size:50px; text-align:center; border:1px gray solid; margin:auto&#x27;&gt;&quot;); out.println(&quot;&lt;label&gt;您的成绩为：&lt;/label&gt;&quot;); out.println(&quot;&lt;label style=&#x27;color:red&#x27;&gt;&quot;+grade+&quot;&lt;/label&gt;&quot;); out.println(&quot;&lt;/div&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); out.close(); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取请求正文 // getInputStream ：获取客户端请求的输入流 ServletInputStream inputStream = request.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); // 从输入流中读取请求正文 String s = reader.readLine(); System.out.println(s); &#125;&#125; 5.3 Servlet动态网页案例 学生信息管理系统： 学生登录 学生查询成绩 5.3.1 案例流程分析 5.3.2 项目环境搭建 数据库环境准备: 创建一个名为db_sgms，然后创建如下数据表： 12345678910111213141516171819202122-- 学生信息表create table students( stu_num char(5) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, stu_pwd varchar(20) not null);-- 课程信息表create table courses( course_id char(6) primary key, course_name varchar(50) not null);-- 学生成绩表create table grades( gid int primary key auto_increment, snum char(5) not null, cid char(6) not null, score int not null); 创建一个Java web工程: servlet-demo4 搭建JDBC环境 导入JDBC所需的驱动jar、数据库连接池jar、DBUtils.jar 在web&#x2F;WEB-INF创建lib目录 将三个jar包拷贝到lib目录 选择拷贝到lib目录三个jar文件—-右键—-Add as library 配置连接池信息 在项目中创建com.qfedu.sgms.utils包 在包中创建druid.properties配置druid连接池信息 123456789101112131415# 数据库连接信息driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/db_sgms?characterEncoding=utf8username=rootpassword=@QFedu123# 连接池属性# 连接池的初始化连接数&lt;创建数据库连接池时默认初始化的连接的个数&gt;initialSize=10# 连接池的最大连接数maxActive=50# 最小空闲连接数（当数据库连接使用率很低时，连接池中的连接会被释放一部分）minIdle=5# 超时等待时间(单位：ms)maxWait=30000 在utils包中创建连接池工具类：DruidUtils 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.qfedu.sgms.utils;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.*;import java.io.InputStream;import java.sql.*;import java.util.Properties;/** * @Description 数据库连接池工具类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class DruidUtils &#123; private static DruidDataSource druidDataSource; static&#123; try &#123; InputStream is = DruidUtils.class.getResourceAsStream(&quot;druid.properties&quot;); Properties properties = new Properties(); properties.load(is); druidDataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取数据库连接池数据源对象 * @return */ public static DataSource getDataSource()&#123; return druidDataSource; &#125; /** * 从数据库连接池中获取数据库连接对象 * @return */ public static Connection getConnection()&#123; Connection connection = null; try &#123; connection = druidDataSource.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return connection; &#125;&#125; 5.3.3 完成数据库操作 根据项目业务流程图，完成需要数据库操作 学生登录实现： 根据输入的学号和密码查询学生信息，如果查询到了说明学号密码输入正确，登录成功； 根据输入的学号查询学生，如果查询到了说明学号正确，再比较输入的密码和查询出来的密码是否一致，如果一致则登录成功； 查询成绩： 根据学号和课程号从成绩表中查询成绩 根据学号和密码查询学生 创建实体类 Student类 12345678910111213141516package com.qfedu.sgms.dto;/** * @Description 学生信息实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Student &#123; private String stuNum; private String stuName; private String stuGender; private int stuAge; private String stuPwd;&#125; 创建DAO，完成对应数据库操作 123456789101112131415161718192021222324252627282930313233package com.qfedu.sgms.dao;import com.qfedu.sgms.dto.Student;import com.qfedu.sgms.utils.DruidUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */public class StudentDAO &#123; /** * 根据学号和密码查询学生信息 * @param stuNum * @param stuPwd * @return 如果学号密码正确返回Student，否则返回null */ public Student queryStudentByNumAndPwd(String stuNum,String stuPwd)&#123; Student student = null; try&#123; String sql = &quot;select stu_num stuNum,stu_name stuName,stu_gender stuGender,stu_age stuAge,stu_pwd stuPwd from students where stu_num=? and stu_pwd=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); student = queryRunner.query(sql,new BeanHandler&lt;Student&gt;(Student.class),stuNum,stuPwd); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return student; &#125;&#125; 根据学号、课程号查询成绩 创建实体类 Grade类 12345678910111213141516package com.qfedu.sgms.dto;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Grade &#123; private String snum; private String sname; //此属性在成绩表中没有，但是关联学生信息可以查询 private String cid; private String cname; //此属性在成绩表也没有，但是关联课程表可以查询 private int score;&#125; 创建GradeDAO查询成绩 12345678910111213141516171819202122232425262728293031323334package com.qfedu.sgms.dao;import com.qfedu.sgms.dto.Grade;import com.qfedu.sgms.utils.DruidUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */public class GradeDAO &#123; /** * 根据学号和课程号查询这个学生这门课的成绩 * @param snum * @param cid * @return */ public Grade queryGradeBySnumAndCid(String snum,String cid)&#123; Grade grade = null; try&#123; //注意查询出的列名要取别名，和grade对象的属性一致 String sql = &quot;select s.stu_num snum,s.stu_name sname,c.course_id cid,c.course_name cname ,g.score score from students s INNER JOIN grades g INNER JOIN courses c on s.stu_num = g.snum and g.cid = c.course_id where s.stu_num=? and c.course_id=?&quot;; QueryRunner queryRunner = new QueryRunner(DruidUtils.getDataSource()); grade = queryRunner.query(sql,new BeanHandler&lt;Grade&gt;(Grade.class),snum,cid); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return grade; &#125;&#125; 5.3.4 实现LoginPageServlet登录界面 LoginPageServlet就是为用户提供一个登陆页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.qfedu.sgms.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/login&quot;)public class LoginPageServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //响应一个登录界面 response.setStatus(200); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;!DOCTYPE html&gt;&quot;); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;meta charset=&#x27;utf-8&#x27;&gt;&quot;); out.println(&quot;&lt;title&gt;学生成绩查询系统-登录&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;form action=&#x27;&#x27; method=&#x27;post&#x27;&gt;&quot;); out.println(&quot;&lt;h3&gt;学生成绩查询系统—学生登录&lt;/h3&gt;&quot;); out.println(&quot;&lt;p&gt;学号：&lt;input type=&#x27;text&#x27; name=&#x27;stuNum&#x27; placeholder=&#x27;学生学号&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;p&gt;密码：&lt;input type=&#x27;password&#x27; name=&#x27;stuPwd&#x27; placeholder=&#x27;登录密码&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;p&gt;&lt;input type=&#x27;submit&#x27; value=&#x27;登录&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;/form&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); out.close(); &#125;&#125; 5.3.5 实现CheckServlet验证登录 CheckServlet接收用户在页面中输入学号和密码、调用StudentDAO查询验证 创建CheckServlet类 修改LoginPageServlet中的 form表单action属性为CheckServlet的访问路径 12// 点击登录之后跳转到另一个CheckServlet，在一个项目中action的值可以只写 CheckServlet的urlout.println(&quot;&lt;form action=&#x27;CheckServlet&#x27; method=&#x27;post&#x27;&gt;&quot;); 在CheckServlet类验证客户端提交的学号和密码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.qfedu.sgms.servlets;import com.qfedu.sgms.dao.StudentDAO;import com.qfedu.sgms.dto.Student;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Description 验证学生登录 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/CheckServlet&quot;)public class CheckServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1. 接收学号和密码 request.setCharacterEncoding(&quot;utf-8&quot;); String num = request.getParameter(&quot;stuNum&quot;); String pwd = request.getParameter(&quot;stuPwd&quot;); //2.调用StudentDAO中的方法，根据学号和密码查询学生 StudentDAO studentDAO = new StudentDAO(); Student student = studentDAO.queryStudentByNumAndPwd(num, pwd); //3.判断查询结果，响应客户端 response.setStatus(200); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;!DOCTYPE html&gt;&quot;); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;meta charset=&#x27;utf-8&#x27;&gt;&quot;); //根据登录验证的不同结果响应给客户端不同的页面 if(student == null)&#123; //登录失败：响应客户端登录页面 out.println(&quot;&lt;title&gt;学生成绩查询系统-登录&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); //点击登录之后跳转到另一个CheckServlet，在一个项目中action的值可以只写CheckServlet的url out.println(&quot;&lt;form action=&#x27;CheckServlet&#x27; method=&#x27;post&#x27;&gt;&quot;); out.println(&quot;&lt;h3&gt;学生成绩查询系统—学生登录&lt;/h3&gt;&quot;); out.println(&quot;&lt;p&gt;学号：&lt;input type=&#x27;text&#x27; name=&#x27;stuNum&#x27; placeholder=&#x27;学生学号&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;p&gt;密码：&lt;input type=&#x27;password&#x27; name=&#x27;stuPwd&#x27; placeholder=&#x27;登录密码&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;p&gt;&lt;input type=&#x27;submit&#x27; value=&#x27;登录&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;/form&gt;&quot;); &#125;else&#123; //登录成功：响应客户端系统的主页 out.println(&quot;&lt;title&gt;学生成绩查询系统-主页面&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;登录成功！&quot;); &#125; out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); out.close(); &#125;&#125; 5.3.6 业务与视图分离 通过上个步骤CheckServlet的实现，我们发现一些问题： 如果登录验证失败，需要响应登录页面，登录界面已经在LoginPageServlet中写过，在CheckServlet又写了一遍，不满足我们代码复用性原则，不便于代码维护； 在CheckServlet中，业务代码与视图代码混在一起，不满足单一原则的编程规范 业务与视图分离： CheckServlet只负责学生登录校验的业务处理； 如果登录成功需要呈现主界面，可以创建单独的IndexPageServlet来响应主页面； 如果登录失败需要呈现登录界面，可以重复使用LoginPageServlet来响应登录页面； 5.3.7 实现IndexPageServlet主页面 IndexPageServlet显示成绩查询的主页面，并且能够输入学号和课程号查询成绩 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.qfedu.sgms.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Description 提供登录成功之后的主页面 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/IndexPageServlet&quot;)public class IndexPageServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //响应一个登录界面 response.setStatus(200); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;!DOCTYPE html&gt;&quot;); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;meta charset=&#x27;utf-8&#x27;&gt;&quot;); out.println(&quot;&lt;title&gt;学生成绩查询系统-主页面&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;table border=&#x27;1&#x27; width=&#x27;100%&#x27; height=&#x27;700&#x27;&gt;&quot;); out.println(&quot;&lt;tr height=&#x27;100&#x27;&gt;&lt;td colspan=&#x27;2&#x27;&gt;&lt;label&gt;学生成绩查询系统欢迎您！&lt;/label&gt;&lt;/td&gt;&lt;/tr&gt;&quot;); out.println(&quot;&lt;tr&gt;&quot;); out.println(&quot;&lt;td width=&#x27;200&#x27;&gt;2-1&lt;/td&gt;&quot;); out.println(&quot;&lt;td align=&#x27;center&#x27; valign=&#x27;top&#x27;&gt;&quot;); //查询成绩的表单 out.println(&quot;&lt;form action=&#x27;GradeQueryServlet&#x27; method=&#x27;post&#x27;&gt;&quot;); out.println(&quot;&lt;h3&gt;查询成绩&lt;/h3&gt;&quot;); out.println(&quot;&lt;p&gt;学号：&lt;input type=&#x27;text&#x27; name=&#x27;stuNum&#x27; placeholder=&#x27;学生学号&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;p&gt;课程：&lt;input type=&#x27;text&#x27; name=&#x27;courseId&#x27; placeholder=&#x27;课程编号&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;p&gt;&lt;input type=&#x27;submit&#x27; value=&#x27;查询&#x27;/&gt;&lt;/p&gt;&quot;); out.println(&quot;&lt;/form&gt;&quot;); out.println(&quot;&lt;/td&gt;&quot;); out.println(&quot;&lt;/tr&gt;&quot;); out.println(&quot;&lt;/table&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); out.close(); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; 5.3.8 登录失败转发到LoginPageServlet CheckServlet转发到LoginPageServlet，并传递参数 123456789101112//3.判断查询结果，响应客户端//根据登录验证的不同结果响应给客户端不同的页面if(student == null)&#123; //登录失败：响应客户端登录页面,提示“登录失败，学号或密码错误！” //转发到下一个Servlet是可以通过request传递数据过去的 request.setAttribute(&quot;tips&quot;,&quot;登录失败，学号或密码错误！&quot;); //转发到LoginPageServlet：在当前Servlet类的doPost方法转到，也会转发到下一个Servelt的doPost request.getRequestDispatcher(&quot;login&quot;).forward(request,response);&#125;else&#123; //登录成功：响应客户端系统的主页&#125; LoginPageServlet接收参数响应登录页面 12345678910111213141516171819202122 @Overrideprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;-----doPost&quot;); //1. doPost调用doGet doGet(request,response);&#125;@Overrideprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;-----doGet&quot;); //2.接收从CheckServlet传递的提示信息 String tips = (String) request.getAttribute(&quot;tips&quot;); //响应一个登录界面 //...代码省略 //显示提示信息 if(tips != null)&#123; out.println(&quot;&lt;label style=&#x27;color:red&#x27;&gt;&quot;+tips+&quot;&lt;/label&gt;&quot;); &#125; //...代码省略&#125; 5.3.9 登录成功重定向IndexPageServlet CheckServlet重定向IndexPageServlet 1234567891011121314//3.判断查询结果，响应客户端//根据登录验证的不同结果响应给客户端不同的页面if(student == null)&#123; //登录失败：响应客户端登录页面,提示“登录失败，学号或密码错误！” //转发到下一个Servlet是可以通过request传递数据过去的 request.setAttribute(&quot;tips&quot;,&quot;登录失败，学号或密码错误！&quot;); //转发到LoginPageServlet：在当前Servlet类的doPost方法转到，也会转发到下一个Servelt的doPost request.getRequestDispatcher(&quot;login&quot;).forward(request,response);&#125;else&#123; //登录成功：响应客户端系统的主页 //重定向到IndexPageServlet：无需传递参数到IndexPageServlet，所以我们可以使用重定向 response.sendRedirect(&quot;IndexPageServlet&quot;);&#125; 5.3.10 实现GradeQueryServlet查询成绩 GradeQueryServlet接收客户端输入的学号、课程ID，查询成绩 创建GradeQueryServlet 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.qfedu.sgms.servlets;import com.qfedu.sgms.dao.GradeDAO;import com.qfedu.sgms.dto.Grade;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Description 根据客户端传递的学号、课程号查询成绩 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/GradeQueryServlet&quot;)public class GradeQueryServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //如果允许客户端get和post方式提交，我们可以在doGet中调用doPost,业务代码写在doPost doPost(request,response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收客户端输入的学号、课程ID String snum = request.getParameter(&quot;stuNum&quot;); String cid = request.getParameter(&quot;courseId&quot;); //2.调用GradeDAO中的方法根据学号、课程号查询成绩 GradeDAO gradeDAO = new GradeDAO(); Grade grade = gradeDAO.queryGradeBySnumAndCid(snum, cid); //3.查询到成绩之后，将成绩传递到GradePageServlet // 由GradePageServlet响应给浏览器一个页面，并把成绩显示出来 request.setAttribute(&quot;grage&quot;,grade); request.getRequestDispatcher(&quot;GradePageServlet&quot;).forward(request,response); &#125; &#125; 修改IndexPageServlet响应的主页面，form标签的action属性为GradeQueryServlet 直接修改到 5.3.7 的代码 5.3.11 实现GradePageServlet显示成绩 GradePageServle响应给客户端一个成绩结果页面，并显示成绩 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.qfedu.sgms.servlets;import com.qfedu.sgms.dto.Grade;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Description 成绩查询结果页面 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/GradePageServlet&quot;)public class GradePageServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收转发时传递的成绩 Grade grade = (Grade) request.getAttribute(&quot;grade&quot;); //2.设置响应头 response.setStatus(200); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); //3.响应成绩结果页面 PrintWriter out = response.getWriter(); out.println(&quot;&lt;!DOCTYPE html&gt;&quot;); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;meta charset=&#x27;utf-8&#x27;&gt;&quot;); out.println(&quot;&lt;title&gt;学生成绩查询系统&lt;/title&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;table border=&#x27;1&#x27; width=&#x27;100%&#x27; height=&#x27;700&#x27;&gt;&quot;); out.println(&quot;&lt;tr height=&#x27;100&#x27;&gt;&lt;td colspan=&#x27;2&#x27;&gt;&lt;label&gt;学生成绩查询系统欢迎您！&lt;/label&gt;&lt;/td&gt;&lt;/tr&gt;&quot;); out.println(&quot;&lt;tr&gt;&quot;); out.println(&quot;&lt;td width=&#x27;200&#x27;&gt;2-1&lt;/td&gt;&quot;); out.println(&quot;&lt;td align=&#x27;center&#x27; valign=&#x27;top&#x27;&gt;&quot;); //查询成绩的表单 ： 修改action属性为 GradeQueryServlet out.println(&quot;&lt;h3&gt;查询结果&lt;/h3&gt;&quot;); if(grade != null)&#123; out.println(&quot;&lt;table width=&#x27;200&#x27; border=&#x27;1&#x27; cellspacing=&#x27;0&#x27;&gt;&quot;); out.println(&quot;&lt;tr&gt;&lt;td&gt;学号&lt;/td&gt;&lt;td&gt;&quot;+grade.getSnum()+&quot;&lt;/td&gt;&lt;/tr&gt;&quot;); out.println(&quot;&lt;tr&gt;&lt;td&gt;姓名&lt;/td&gt;&lt;td&gt;&quot;+grade.getSname()+&quot;&lt;/td&gt;&lt;/tr&gt;&quot;); out.println(&quot;&lt;tr&gt;&lt;td&gt;课程ID&lt;/td&gt;&lt;td&gt;&quot;+grade.getCid()+&quot;&lt;/td&gt;&lt;/tr&gt;&quot;); out.println(&quot;&lt;tr&gt;&lt;td&gt;课程名&lt;/td&gt;&lt;td&gt;&quot;+grade.getCname()+&quot;&lt;/td&gt;&lt;/tr&gt;&quot;); out.println(&quot;&lt;tr&gt;&lt;td&gt;成绩&lt;/td&gt;&lt;td&gt;&lt;label style=&#x27;color:red;font-weight:bold&#x27;&gt;&quot;+grade.getScore()+&quot;&lt;/label&gt;&lt;/td&gt;&lt;/tr&gt;&quot;); out.println(&quot;&lt;/table&gt;&quot;); &#125;else&#123; out.println(&quot;&lt;label style=&#x27;color:red;font-weight:bold;font-size:20px&#x27;&gt;学号或课程号有误!&lt;/label&gt;&quot;); &#125; out.println(&quot;&lt;a href=&#x27;IndexPageServlet&#x27;&gt;继续查询&lt;/a&gt;&quot;); out.println(&quot;&lt;/td&gt;&quot;); out.println(&quot;&lt;/tr&gt;&quot;); out.println(&quot;&lt;/table&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); out.close(); &#125;&#125; 5.4 转发和重定向 当客户端请求到了某个Servlet类之后，Servlet类进行处理，但是并不使用这个Servlet来响应客户端，而是要使用另一个Servlet来响应。 5.4.1 转发1. 转发跳转流程 2. 转发的特点 转发是在服务器端，两个Servlet之间的请求行为； 浏览器只对服务器进行了一次请求； 浏览器的地址不会改变，浏览器请求ServletA，ServletA转到ServletB由ServletB响应浏览器，浏览器显示的是ServletA的访问地址； 转发过程中，可以通过request对象传递数据； 3. 转发的代码实现 ServletA 转发到 ServletB 在ServletA中： request.getRequestDispatcher(“ServletB的URL“).forward(request,response); 4. 数据传递 ServletA 转发到 ServletB，并传递参数 传数据 1234567//ServletA：在转发操作之前，将需要传递给ServletB的参数设置到request对象中，可以传递不同类型数据//设置转发传递的数据request.setAttribute(&quot;stuNum&quot;,&quot;10001&quot;);request.setAttribute(&quot;stuAge&quot;,21); //如果直接给简单类型数据，则会自动装箱为对应的封装类对象request.setAttribute(&quot;stu&quot;,new Student(...));//转发request.getRequestDispatcher(&quot;ServletB的URL&quot;).forward(request,response); 取数据 12345//ServletB：在ServletB的doGet/doPost方法中，通过request对象获取ServletA传递的参数//Object obj = request.getAttribute(String key);String snum = (String)request.getAttribute(&quot;stuNum&quot;);int sage = (Integer)request.getAttribute(&quot;stuAge&quot;);Student stu = (Studennt)request.getAttribute(&quot;stu&quot;); 5.4.2 重定向1. 重定向跳转流程 客户端请求ServletA，ServletA响应给客户端一个新的请求地址ServletB，让客户端重新向ServeltB发送请求。 2. 重定向特点 重定向是客户端的行为 浏览器对服务器发送了两次请求； 重定向是由浏览器再次发送请求，浏览器地址会改变为转发的地址； 不能通过request对象将ServletA中的数据传递给ServletB 如果ServletA重定向到ServletB的时候有数据要传递到ServletB该如何实现？——url传值 3. 重定向代码实现 在ServletA中 response.sendRedirect(“ServletB访问URL“); 4. 数据传递12//ServletA：在响应浏览器重定向地址的时候，在URL声明参数response.sendRedirect(&quot;ServletB?key=value&quot;); 12//ServletB: 获取浏览器请求的参数String value = request.getParameter(&quot;key&quot;); 5.5 状态管理5.5.1 现有问题 http请求是无状态的，不能保存客户每次提交的信息； 客户端发送一个新的请求达到服务器，服务器无法知道此客户端是否曾经请求过服务器，两次请求之间是没有联系的； 如果用户在访问系统的主页面（主页面需要登录之后才可以访问），需要访问之前请求提交的数据该如何实现？ 5.5.2 状态管理实现 将浏览器与服务器之间的多次交互作为一个整体处理，通过服务器数据存储和浏览器数据存储集合的形式实现状态管理： 客户端状态管理：cookie技术 （在浏览器缓存数据） 服务器状态管理：session技术（在服务器存储用户信息，基于cookie） 5.6 Cookie的使用5.6.1 什么是Cookie？ Cookie是在浏览器访问web服务器上的某个资源时，由web服务器在响应浏览器时通过响应头附带的传送给浏览器并存储在浏览器端的一小段数据； 一旦web浏览器保存了来自于某个服务器的Cookie，那么当浏览器再次访问这个服务器的时候，会通过请求头将cookie传递给web服务器； 浏览器访问服务器的时候，只会携带由当前服务器存储在客户端的cookie； Cookie中缓存的数据数据是以键值对形式存储的（name-value）。 5.6.2 Cookie的使用案例流程图： 创建一个Java web工程：servlet-demo5 修改web项目在服务器上的访问路径为/demo5： 创建两个Servlet类，分别为FirstServlet和SecondServlet 1. 写Cookie到浏览器 创建cookie Cookie cookie = new Cookie(&quot;key1&quot;, &quot;value1&quot;); 设置cookie cookie.setMaxAge(24*60*60); 写cookie response.addCookie(cookie); 服务器可以同时写多个Cookie存储到客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @Description 写Cookie * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/FirstServlet&quot;)public class FirstServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //向浏览器存储一个Cookie // 1. 创建Cookie对象 （javax.servlet.http.Cookie） Cookie cookie = new Cookie(&quot;key1&quot;, &quot;value1&quot;); // 设置cookie生命周期 // 情况1：如果设置&gt;0的值，表示设置cookie有效时间（单位s） // 情况2：如果参数=0，表示浏览器关闭销毁cookie // 情况3：如果参数=-1，表示内存存储 cookie.setMaxAge(24*60*60); // 2. 将cookie对象添加到HTTP响应头，写Cookie到客户端 response.addCookie(cookie); //响应浏览器一个界面 //a.设置响应头 response.setStatus(200); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); //b.响应正文 PrintWriter out = response.getWriter(); out.println(&quot;&lt;!DOCTYPE html&gt;&quot;); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&quot;); out.println(&quot;&lt;meta charset=&#x27;utf-8&#x27;&gt;&quot;); out.println(&quot;&lt;title&gt;&lt;/title&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); out.println(&quot;&lt;a href=&#x27;SecondServlet&#x27;&gt;请求SecondServlet&lt;/a&gt;&quot;); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/head&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); out.flush(); out.close(); &#125;&#125; 2. 服务器读取Cookie 通过request对象获取所有cookie： Cookie[] cookies = request.getCookies(); 获取Cookie对象的key： String key = cookie.getName(); 获取Cookie对象的value：String value = cookie.getValue(); 123456789101112131415161718192021222324252627282930313233343536package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Description 读Cookie * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/SecondServlet&quot;)public class SecondServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 读取cookie: 当客户端再次请求服务器时，通过request将cookie传递到服务器 // 通过request对象获取浏览器传递的cookie Cookie[] cookies = request.getCookies(); for (Cookie cookie: cookies) &#123; String key = cookie.getName(); String value = cookie.getValue(); System.out.println(key+&quot;对应的值：&quot;+value); &#125; // SecondServlet暂时不响应浏览器 &#125;&#125; 5.6.3 Cookie的优点和限制优点： 可以灵活的配置过期规则 简洁，cookie中存储的是最简单的键值对格式的文本数据 数据的持久性，保存到浏览器中的cookie在过期之前是持久存储的 限制： 存储数据的大小，大多浏览器支持4k、8k的数据存储 用户可以通过浏览器设置禁用Cookie，因此限制了cookie的使用场景（如果一定要使用cookie，可以检查浏览器cookie是否可用，如果不可用提醒用户设置开启cookie） cookie是存储在客户端浏览器中的，有被纂改的风险，有潜在的安全隐患 5.7 HttpSession对象5.7.1 Session概述 Session对象，就是当浏览器向服务器发送请求建立连接后，由服务器创建的存储在服务器端的用于记录用户状态对象。 5.7.2 Session特性 服务器会为每个客户端连接分配一个Session对象，存储在服务器上； 同一个浏览器发送多次请求，同属于一次会话，共享同一个Session对象； 5.7.3 Session原理问题：HTTP请求时无状态的，那么同一个浏览器的多次请求为什么能够使用同一个Session对象，如何实现的？ 结论：借助于Cookie让浏览器多次请求共享同一个Session Session原理： 当客户端浏览器(第一次)请求服务器时，服务器会为当前客户端连接创建一个Session对象，同时将sessionID通过Cookie响应给客户端，并存储在客户端； 当客户端端再次请求服务器的时候，会通过请求头携带存储sessionID的cookie，服务器接收请求之后获取cookie中的sessionID，通过这个sessionID获取第一次连接时创建Session对象。 5.7.4 获取Session对象 当用户连接到服务器时，服务器会为这个用户连接创建一个session对象，在Servlet类中可以通过request对象调用getSession()方法获取当前用户连接的Session对象。 1234567// session对象是 javax.servlet.http.HttpSession接口的对象//1.获取session对象// getSession() : 获取当前用户连接HttpSession session = request.getSession();// getId() : 获取sessionIDString sessionId = session.getId(); 5.7.5 Session对象数据操作1.向session对象存储数据123//2.将数据保存到session对象，session对象的数据结构底层维护的就是一个Map，可以存放多个键值对session.setAttribute(&quot;key1&quot;,&quot;Hello QF!&quot;);session.setAttribute(&quot;key2&quot;,&quot;Java&quot;); 2.从session对象获取数据123//3.从session对象中取数据，根据key获取valueString s1 = (String) session.getAttribute(&quot;key1&quot;);System.out.println(&quot;SecondServlet:&quot;+s1); 3.修改session对象数据12//4.修改session数据，如果key存在，则表示修改session中这个key的值session.setAttribute(&quot;key1&quot;,&quot;千锋武汉！&quot;); 4.删除session对象数据12//5.删除session中 key1的键值对session.removeAttribute(&quot;key1&quot;); 5.7.6 session对象失效 一个客户端的多次请求正常情况下获取到的是同一个session对象，也是正式因为多次请求获取的是同一个session对象才实现了session中存储的用户状态可以作用于请求。 如果session失效，将会导致session失效的后的请求无法获取之前的session对象，也就是说多次请求获取的不是同一个session。 导致session失效的原因有2种： 客户端禁用Cookie，或者客户端在两次请求之间清除了cookie，将导致下一次请求无法获取上一次请求创建的Cookie； session是有生命周期的，当客户端请求服务器建立连接之后，服务器会为此会话创建session对象，如果客户端的两次请求时间间隔&gt;session过期时间（默认30min），服务器会将之前创建的session对象销毁； session失效解决方案： 如果客户端禁用了Cookie：不能通过cookie来记录、传递sessionId， 我们可以通过重写URL，使用url传递sessionID（在url上追加sessionId） 如果session过期：我们可以根据系统的需求灵活设置session的生命周期或者手动销毁session对象 123456//设置session对象的过期时间（单位:s）//设置session过期时间10s：当客户端的两次请求时间&gt;10s,session将会被销毁session.setMaxInactiveInterval(10);//手动销毁session对象session.invalidate(); 5.7.7 使用session实现用户登录验证 在一个软件系统中，有很多资源是需要用户登录之后才可以请求访问的（受限资源） 步骤： 当用户登录成功之后，将用户信息保存到当前用户连接的session对象中； 12345678//CheckServlet//当学生登录成功，将学生信息存储到sessionHttpSession session = request.getSession();session.setAttribute(&quot;stu&quot;,student);//重定向到IndexPageServletresponse.sendRedirect(&quot;IndexPageServlet&quot;); 当用户访问受限资源时，先检查session中是否有用户信息： 如果有用户信息则表示当前用户已经登录，可以继续访问 如果session中没有用户信息，表示用户未登录或session过期，则跳转到登录页面，提示用户登录。 123456789HttpSession session = request.getSession();Student stu = (Student) session.getAttribute(&quot;stu&quot;);if(stu == null)&#123; //从session没有获取stu,则提示重新登录 request.setAttribute(&quot;tips&quot;,&quot;请先登录！&quot;); request.getRequestDispatcher(&quot;login&quot;).forward(request,response);&#125;else&#123; //响应&#125; 5.7.8 request与session的区别 request对象用于获取用户的请求数据，作用于浏览器和服务器的一次请求； session对象用于记录当前用户的状态，作用于一个客户端的多次请求； 场景1：浏览器请求ServletA，ServletA转发到ServletC ServletC与ServletA同属于一次请求，共享同一个request对象，都可以通过request获取浏览器提交的数据 场景2：浏览器请求ServletB，ServletB重定向到ServletD 重定向到ServletD，ServletB与ServletD是浏览器的两次请求，ServletD中的request与ServletB是不同的对象 5.8 ServletContext对象5.8.1 ServletContext对象介绍 HttpServletRequest对象作用于一次用户请求，获取用户数据 HttpSession对象作用于一个用户的多次请求，实现数据共享 ServletContext对象作用域整个web项目，实现多个用户之间的数据共享 ServletContext是Javaweb项目的全局对象，包含当前web项目在web服务器中的信息，同时它也是一个域对象，可以实现访问当前web项目的所有用户之间的数据共享。 5.8.2 通过ServletContext对象获取web应用信息12345678910//ServletContext对象 —— Servlet上下文对象//1.获取ServletContext对象ServletContext servletContext = getServletContext();//2.通过ServletContext对象获取当前web应用的上下文路径// 就是当前web应用在web服务器上的访问路径String contextPath = servletContext.getContextPath();//3.通过ServletContext对象获取web项目中的目录在 服务器上的绝对路径String realPath = servletContext.getRealPath(&quot;/files&quot;); 5.8.3 通过ServletContext对象实现全局数据共享12345678//1.将数据存储到全局对象servletContext.setAttribute(&quot;ckey&quot;,value);//2.根据key从全局对象取数据Object v = servletContext.getAttribute(&quot;ckey&quot;);//3.从全局对象移出数据servletContext.removeAttribute(&quot;ckey&quot;); 5.8.4 ServletContext对象特性 ServletContext是当前web项目的全局上下文对象，可以被多个用户请求共享； ServletContext在服务器启动的时候创建，当服务器关闭或者将项目从服务器移出时销毁ServletContext对象； ServletContext可以实现 在线人数统计等需要全局存储的场景。 5.8.5 通过ServletContext对象获取全局参数 在web.xml可以配置当前web应用的全局参数，在服务器启动的时候会加载web.xml 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 配置上下文参数 ： 键值对 --&gt; &lt;context-param&gt; &lt;param-name&gt;key1&lt;/param-name&gt; &lt;param-value&gt;HelloWorld&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;key2&lt;/param-name&gt; &lt;param-value&gt;wahaha&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; 在Servlet类中，可以通过ServletContext对象读取初始化参数： 123456//通过ServletContext对象获取web.xml中配置的全局参数// getInitParameterNames()：获取web.xml中全局参数所有的key[key1,key2]Enumeration&lt;String&gt; keys = servletContext.getInitParameterNames();// getInitParameter(key): 根据key获取valueString v1 = servletContext.getInitParameter(&quot;key1&quot;); 5.9 ServletConfig对象 ServletConfig对象表示的一个Servlet在web服务器的配置信息 Servlet类通过web.xml配置方式可以配置Servlet类的初始化参数： 123456789101112131415161718&lt;!-- xml方式配置Servlet，可以配置当前Servlet的初始化参数 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.qfedu.servlets.TestServlet&lt;/servlet-class&gt; &lt;!-- Servlet类的初始化参数 --&gt; &lt;init-param&gt; &lt;param-name&gt;key3&lt;/param-name&gt; &lt;param-value&gt;hahaha&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;key4&lt;/param-name&gt; &lt;param-value&gt;hehehe&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/TestServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在TestServlet类中获取当前类的ServletConfig对象，并通过对象获取类路径、加载初始化参数 123456789101112131415//1.获取ServletConfig对象//getServletConfig() : 获取当前Servlet类的ServletConfig对象ServletConfig servletConfig = getServletConfig();//2.通过ServletConfig获取当前Servlet类路径String servletName = servletConfig.getServletName();//3.通过ServletConfig对象加载当前Servlet类的初始化参数//getInitParameterNames 获取当前Servlet所有初始化参数的keyEnumeration&lt;String&gt; names = servletConfig.getInitParameterNames();//getInitParameter 根据key获取valueString v3 = servletConfig.getInitParameter(&quot;key3&quot;);System.out.println(&quot;TestServlet:&quot;+v3); 六、过滤器6.1 过滤器介绍 过滤器(Filter)是位于客户端与服务器资源之间的一道过滤技术，可以在客户端请求到达目标资源之前进行预处理业务。 过滤器作用 执行多个Servlet公共的代码，解决了代码的冗余性问题，提高代码复用性（例如首先资源的登录验证）； 6.2 过滤器使用6.2.1 创建过滤器 在doFilter编写过滤业务规则，如果允许继续访问，则通过filterChain.doFilter(servletRequest,servletResponse);让客户端请求继续访问；如果不允许通行则可以通过servletResponse直接响应客户端（转发、重定向）。 1234567891011121314151617181920212223242526272829303132333435package com.qfedu.filters;import javax.servlet.*;import java.io.IOException;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 * 1.创建一个类实现javax.servlet.Filter接口 * 2.实现Filter接口中的init、doFilter、destroy抽象方法 * init 是过滤器初始化方法，用于获取过滤器的初始化参数等 * destory 是过滤器的销毁方法，用以释放资源 * doFilter 方法 用于定义过滤器的业务 * 3.在doFilter实现过滤器业务 */public class MyFilter01 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;~~~~~~MyFilter01&quot;); //放行:运行继续执行浏览器请求的目标资源 filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 6.2.2 配置过滤器 配置过滤器拦截哪些服务器资源 xml配置 123456789&lt;filter&gt; &lt;filter-name&gt;MyFilter01&lt;/filter-name&gt; &lt;filter-class&gt;com.qfedu.filters.MyFilter01&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;MyFilter01&lt;/filter-name&gt; &lt;!--过滤器的拦截规则--&gt; &lt;url-pattern&gt;/FirstServlet&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 注解配置：在过滤器类添加@WebFilter注解 1234@WebFilter(&quot;/*&quot;)public class MyFilter01 implements Filter &#123; //...&#125; 6.2.3 过滤器路径配置规则精确过滤： 配置过滤器拦截指定的请求url 例如：&#x2F;FirstServlet，&#x2F;index.html 后缀过滤： 配置过滤器拦截指定的后缀的请求url 例如：*.jpg 、 *.html 通配符过滤： &#x2F;* 拦截所有请求 &#x2F;aaa&#x2F;bbb&#x2F;* 拦截项目名后 demo8/aaa/bbb/FirstServlet 或者 demo8/aaa/bbb/a.html 6.3 前置过滤器与后置过滤器 根据过滤器在目标资源执行的时机，我们可以将过滤器分为三类： 前置过滤器：过滤器在目标资源之前执行 后置过滤器：过滤器在目标资源之后执行 环绕过滤器：执行目标资源之前会执行过滤器，目标资源执行之后还会执行过滤器 如何设置前置、后置、环绕过滤器？ 在过滤器的doFilter方法中，写在放行代码（filterChain.doFilter(...)）业务会在目标资源执行之前执行，写在放行代码后面的业务，则会在目标资源执行之后执行 1234567891011121314151617181920@WebFilter(&quot;/FirstServlet&quot;)public class MyFilter01 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;~~~~~~before&quot;); //放行:运行继续执行浏览器请求的目标资源 filterChain.doFilter(servletRequest,servletResponse); System.out.println(&quot;~~~~~~after&quot;); &#125; @Override public void destroy() &#123; &#125;&#125; 6.4 过滤器链6.4.1 过滤器链介绍 在同一个服务器资源（Servlet类）上可以添加多个过滤器，当用户请求资源时，会依次执行每一个过滤器，然后再执行目标资源，再依次通过过滤器响应客户端请求。 6.4.2 过滤器的优先级 过滤器优先级：在一个web项目中如果配置多个过滤器，多个过滤器的先后执行顺序 如果多个过滤器都是使用注解配置的，则按照过滤器类的名称字符串的字典顺序执行； 如果多个过滤器都是在web.xml中配置的，则按照web.xml配置的先后顺序执行； web.xml中配置的过滤器优先级高于注解配置； 如果同一个过滤器通过注解及web.xml两种方式都进行了配置，过滤器会执行多次。 6.5 过滤器应用案例6.5.1 编码过滤器123456789101112131415161718192021222324252627282930package com.qfedu.utils;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;/** * @Description 编码过滤器 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebFilter(&quot;/*&quot;)public class EncodingFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; //对request请求数据进行编码设置 servletRequest.setCharacterEncoding(&quot;utf-8&quot;); //请求放行 filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 6.5.2 登录验证过滤器1.实现流程 2.登录过滤器代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.qfedu.sgms.utils;import com.qfedu.sgms.dto.Student;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;/** * @Description 登录验证过滤器 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebFilter(&quot;/*&quot;)public class LoginFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; //1.因为此过滤器会拦截所有用户请求（包括受限资源和非受限资源） // 所以当一个用户请求被拦截之后，我们需要知道这个请求的路径 // a.将ServletRequest转换成 HttpServletRequest HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; // b.通过request对象获取用户的请求路径 String uri = request.getRequestURI(); // ---- /demo4/IndexPageServlet // c.截取uri最后一个/后的路径，即为请求路径 String requestPath = uri.substring( uri.lastIndexOf(&quot;/&quot;)+1 ); System.out.println(&quot;requestPath:&quot;+requestPath); //2.判断：如果请求路径是非受限资源则直接放行，如果是受限资源则需要验证用户是否登录 if(&quot;CheckServlet&quot;.equals(requestPath) || &quot;login&quot;.equals(requestPath))&#123; //放行 filterChain.doFilter(servletRequest, servletResponse); &#125;else&#123; //进入else代码，表示此请求是受限资源，需要验证用户是否登录 //3.判断session中是否有用户信息，如果有则表示用户已经登录——放行 // 如果没有则表示用户未登录，转发到登录页面，提示请先登录 HttpSession session = request.getSession(); Student stu = (Student) session.getAttribute(&quot;stu&quot;); if(stu != null)&#123; filterChain.doFilter(servletRequest, servletResponse); &#125;else&#123; //转到到登录页面 request.setAttribute(&quot;tips&quot;,&quot;请先登录！&quot;); request.getRequestDispatcher(&quot;login&quot;).forward(request,response); &#125; &#125; &#125; @Override public void destroy() &#123; &#125;&#125; 七、Servlet应用7.1 文件上传 客户端提交文件（图片&#x2F;ppt&#x2F;doc&#x2F;md…）到Servlet类，Servlet类该如何接收并保存文件呢 ？ 7.1.1 文件上传案例流程 7.1.2 准备工作 创建一个Java web工程：serlvet-demo9 在web工程的 web 目录创建一个 book-add.html的网页文档，提供图书添加界面 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图书添加页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;添加图书信息&lt;/h3&gt; &lt;form action=&quot;&quot; method=&quot;&quot;&gt; &lt;p&gt;图书编号：&lt;input type=&quot;text&quot; name=&quot;bookId&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书封面：&lt;input type=&quot;file&quot; name=&quot;bookImg&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 创建BookSaveServlet类： 1234567891011121314151617181920212223242526272829package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Description 接收图书信息并保存 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/BookSaveServlet&quot;)public class BookSaveServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; 创建图书实体类：Book 123456789101112/** * @Description 图书信息实体类 * @Author 千锋涛哥 * 公众号： Java架构栈 */public class Book &#123; private String bookId; private String bookName; private String bookImgPath; &#125; 创建保存图书信息操作的DAO类：BookDAO 7.1.3 文件上传实现1.前端提交文件 表单post方式提交数据 设置表单的enctype&#x3D;”multipart&#x2F;form-data”，不对表单数据进行编码 1234567891011121314&lt;!--当form表单数据提交时，浏览器会对表单数据进行编码，然后提交；当表单中存在文件的时候，要设置不编码传输通过form表单的enctype属性设置表单数据的压缩方式：- application/x-www-form-urlencoded 在发送前编码所有字符（默认）- text/plain 将表单数据空格转换成+，不对特殊字符进行编码- multipart/form-data 不对表单数据进行编码--&gt;&lt;form action=&quot;BookSaveServlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt;图书编号：&lt;input type=&quot;text&quot; name=&quot;bookId&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;/&gt;&lt;/p&gt; &lt;p&gt;图书封面：&lt;input type=&quot;file&quot; name=&quot;bookImg&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/p&gt;&lt;/form&gt; 2.Servlet类接收文件 在Servlet类前添加@MultipartConfig注解，赋予当前Servlet类处理未编码提交的数据的能力； 通过request对象调用getPart(key)或者getParts()方法接收文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.MultipartConfig;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.Part;import java.io.IOException;import java.util.Collection;/** * @Description 接收图书信息并保存 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/BookSaveServlet&quot;)@MultipartConfigpublic class BookSaveServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.设置utf-8编码 request.setCharacterEncoding(&quot;utf-8&quot;); //2.接收普通文本//当网页提交数据的表单设置了enctype=&quot;multipart/form-data&quot;之后不能直接使用getParameter接收文本数据 //需要在当前serlvet类添加 @MultipartConfig 用于处理非压缩提交的数据 String id = request.getParameter(&quot;bookId&quot;); String name = request.getParameter(&quot;bookName&quot;); System.out.println(&quot;id:&quot;+id ); System.out.println(&quot;name:&quot;+name ); //3. 接收表单提交的图片 // getPart(&quot;输入框name属性&quot;): 接收表单中的文件 Part bookImg = request.getPart(&quot;bookImg&quot;); System.out.println(bookImg); // getParts(): 接收表单中所有文件 //Collection&lt;Part&gt; parts = request.getParts(); //4.保存图片 &#125;&#125; 3.保存图片 在web工程的web目录下新建一个files目录（保存文件的目录如果不在web服务器上，用户将无法访问） 在files目录先放一个任意的文件（空的目录在进行项目部署的时候不会在web服务器中创建） 123456789101112131415161718192021//4.保存图片// a.获取files目录在web服务器上的路径（不是工作空间的路径）ServletContext servletContext = getServletContext();String dir = servletContext.getRealPath(&quot;/files&quot;);// b.给上传的文件重命名 （不同用户有可能上传相同名称的图片，如果不重命名将导致文件覆盖）// 文件重命名后缀名不能改变String header = bookImg.getHeader(&quot;Content-Disposition&quot;); //form-data; name=&quot;bookImg&quot;; filename=&quot;千锋武汉（横版）.jpg&quot;// 截取上传的文件的后缀名int begin = header.lastIndexOf(&quot;.&quot;);int end = header.lastIndexOf(&quot;\\&quot;&quot;);String ext = header.substring(begin, end);// 取名（时间毫秒数、UUID、雪花算法）String fileName = UUID.randomUUID().toString()+ext;//c.存储文件到目录bookImg.write(dir+&quot;\\\\&quot;+fileName);//5.将图书信息保存到数据库: 保存到数据库的是图片的访问路径（不是绝对路径）Book book = new Book(id, name, &quot;files/&quot; + fileName);//调用BookDAO 将book对象保存到数据库 7.2 文件下载 客户端向服务器发送请求，服务器将客户端请求的文件响应给客户端。 7.2.1 文件下载案例流程 7.2.2 案例准备工作 在项目的files目录添加几个待下载的图片 创建文件下载的Servlet类FileDownloadServlet 创建文件列表的静态网页：在web目录下创建file-list.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;files/img01.png&quot; height=&quot;100&quot;/&gt;&lt;br/&gt; &lt;a href=&quot;FileDownloadServlet?fileName=img01.png&quot;&gt;下载&lt;/a&gt;&lt;br/&gt; &lt;img src=&quot;files/img02.png&quot; height=&quot;100&quot;/&gt;&lt;br/&gt; &lt;a href=&quot;FileDownloadServlet?fileName=img02.png&quot;&gt;下载&lt;/a&gt;&lt;br/&gt; &lt;img src=&quot;files/img03.png&quot; height=&quot;100&quot;/&gt;&lt;br/&gt; &lt;a href=&quot;FileDownloadServlet?fileName=img03.png&quot;&gt;下载&lt;/a&gt;&lt;br/&gt; &lt;/body&gt;&lt;/html&gt; 7.2.3 文件下载实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.qfedu.servlets;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;/** * @Description * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/FileDownloadServlet&quot;)public class FileDownloadServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收客户端传递过来的文件名（即为要下载的文件） String fileName = request.getParameter(&quot;fileName&quot;); //img01.png //2.获取存储文件的files目录路径 ServletContext servletContext = getServletContext(); String dir = servletContext.getRealPath(&quot;/files&quot;); // 拼接要下载的文件路径 String filePath = dir+&quot;\\\\&quot;+fileName; //3.设置响应头 //设置响应的类型如果浏览器无法识别则会提示另存为 response.setContentType(&quot;application/image&quot;); response.addHeader(&quot;Content-Disposition&quot;,&quot;attachment; fileName=&quot;+fileName); //4. 通过IO流将文件数据响应给浏览器（文件是二进制数据，所以获取字节流） ServletOutputStream outputStream = response.getOutputStream(); // 读取服务文件，写给客户端 FileInputStream fis = new FileInputStream(filePath); byte[] bs = new byte[1024]; int len = -1; while( (len = fis.read(bs))!=-1)&#123; outputStream.write(bs,0,len); &#125; outputStream.close(); fis.close(); &#125;&#125; 7.3 验证码7.3.1 什么是验证码？ 在应用系统用户登录、用户注册的功能中，使用验证码用于避免客户端通过暴力破解的形式获取用户信息，提高用户信息的安全性。 7.3.2 验证码生成流程 7.3.3 验证码生成实现 创建新的Javaweb工程：servlet-demo10 项目的web目录创建login.html,提供登录界面视图： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;用户登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;p&gt;账号：&lt;input type=&quot;text&quot; name=&quot;userName&quot;/&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;userPwd&quot;/&gt;&lt;/p&gt; &lt;p&gt; 验证码： &lt;input type=&quot;text&quot; name=&quot;userCode&quot; maxlength=&quot;4&quot;/&gt; &lt;img src=&quot;&quot; height=&quot;30&quot; width=&quot;100&quot; /&gt; &lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 创建生成验证码的Servlet类：ValidateCodeServlet 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.qfedu.servlets;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;/** * @Description 生成验证码图片 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/ValidateCodeServlet&quot;)public class ValidateCodeServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //接收客户端请求，生成一个验证码图片，响应给客户端 // 使用Java中提供的 awt 工具包动态生成一个验证码图片 //1.创建一张图片 int width = 300; //验证码宽度 int height = 90; //验证码高度 BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //2.绘制图片 , 从图片对象中获取绘制图片的 “笔” Graphics2D pen = image.createGraphics(); //a.绘制背景 pen.setColor(getRandomColor()); //fillRect: 绘制实心矩形 pen.fillRect(0,0,width,height); //b.绘制验证码字符串 int letterNum = 4; //验证码图片上的字符的个数 int space = 20; // 验证码图片上两个字母之间的空隙 int letterWidth = ( width-(letterNum+1)*space )/letterNum; //计算每个字母占据的宽度 //for循环每循环一次，绘制一个字母 （小写字母的ascii码 97-122） Random random = new Random(); for(int i=0; i&lt;letterNum ; i++)&#123; //随机生成一个小写字母： int ascii = random.nextInt(26) + 97; //97-122 byte[] bs = &#123;(byte)ascii&#125;; String letter = new String(bs); //drawString: 绘制字母 pen.setColor(getRandomColor()); pen.setFont( new Font(&quot;Gulim&quot;,Font.BOLD,70) ); pen.drawString(letter, space+(letterWidth+space)*i,height-space); &#125; // 为了让图片不是那么容易被程序识别，可以绘制干扰线、干扰图形 //图片绘制完成之后，将图片通过 response的输出流响应到客户端 ImageIO.write(image,&quot;png&quot;,response.getOutputStream()); &#125; /** * 产生一种随机颜色 */ private Color getRandomColor()&#123; Random random = new Random(); int r = random.nextInt(256); int g = random.nextInt(256); int b = random.nextInt(256); Color color = new Color(r, g, b); return color; &#125;&#125; 修改登录页面验证码图片的src属性，请求验证码Servlet类 1&lt;img src=&quot;ValidateCodeServlet&quot; height=&quot;30&quot; width=&quot;100&quot; /&gt; 7.3.4 点击验证码图片切换验证码 点击验证码图片，触发JS代码，重新请求验证码Servlet类 7.3.5 验证码验证流程 7.3.6 验证流程实现 在ValidateCodeServlet中生成验证码时，将验证码存入到session ValidateCodeServlet 创建验证用户登录的Servlet类LoginCheckServlet 修改登录页面提交数据到LoginCheckServlet login.html 在 LoginCheckServlet中接收用户输入的帐号、密码、验证码，对验证码进行校验 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.qfedu.servlets;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;/** * @Description 校验验证码 * @Author 千锋涛哥 * 公众号： Java架构栈 */@WebServlet(&quot;/LoginCheckServlet&quot;)public class LoginCheckServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接收帐号、密码、验证码 String userName = request.getParameter(&quot;userName&quot;); String userPwd = request.getParameter(&quot;userPwd&quot;); String userCode = request.getParameter(&quot;userCode&quot;); //2.从session取出生成验证码时存储的正确的验证码 HttpSession session = request.getSession(); String vCode = (String) session.getAttribute(&quot;vCode&quot;); //3.将用户输入的验证码和从session取出的正确的验证码进行对比 if(userCode.equals(vCode))&#123; //验证码正确,继续校验帐号和密码 //... System.out.println(&quot;---验证码正确&quot;); &#125;else&#123; //验证码错误,转发到登录页面，并提示验证码错误 //（在此案例中登录页面是用html实现的，不能显示提示信息） System.out.println(&quot;---验证码错误&quot;); &#125; &#125;&#125;","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://example.com/tags/Servlet/"}]},{"title":"day06-JavaScript","slug":"day06-JavaScript","date":"2022-09-16T15:29:39.000Z","updated":"2022-10-06T03:16:18.355Z","comments":true,"path":"2022/09/16/day06-JavaScript/","link":"","permalink":"http://example.com/2022/09/16/day06-JavaScript/","excerpt":"","text":"HTML 决定了网页中的内容 CSS 决定网页内容的显示效果 JavaScript 决定了网页中标签的功能及动态效果 一、JavaScript介绍1.1 JavaScript简介 JavaScript是一种基于对象的、事件驱动型的、解释型的脚本语言 基于对象：（区别于面向对象），JavaScript和Java语言一样可以通过对象调用方法 obj.fn() 事件驱动：网页文档中的HTML标签事件触发JavaScript代码执行 解释型：边解释边执行（不会先对网页进行编译生成中间文件） 脚本语言：JavaScript不会独立运行，依赖于网页文件（HTML文档）存在 （通俗的理解为js要写在网页中） 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .btnStyle&#123; width: 200px; height: 35px; background: lightcoral; border: none; border-radius: 5px; color: white; font-weight: bold; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test()&#123; alert(&quot;Hello World!&quot;); //弹窗提示 var m = 10/0; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;测试按钮&quot; class=&quot;btnStyle&quot; onclick=&quot;test()&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 1.2 JavaScript的发展史 JS是一种嵌入在网页中的脚本语言，网页是通过浏览器加载并显示的，因此JS的执行是在浏览器中完成的；对于浏览器而言，它能够执行JS代码，在浏览器中内置了JavaScript解释器（JavaScript引擎） JavaScript是在1995年由一个知名的浏览器厂商Netscape（网景）公司的Brench Eich，基于网景导航者浏览器设计开发而来的，这个脚本语言最开始命名为LiveScript，后来基于Netscape与sun公司的合作以及LiveScript知名度比较低，后来就改名为JavaScript。 JavaScript的设计是为了完成网页文件的交互功能。 JavaScript是基于ECMAScript标准设计的，截止到2012，ECMAScript5.1标准已经普及；2015年，ECMAScript6的标准发布，目前大部分浏览器兼容ES6，但是为了保证浏览器对JavaScript普适性的支持，在JavaScript学习和使用中，更多的使用ES5标准规定的语法。 1.3 JavaScript作用 JS设计的目的是实现网页的交互能力 1.3.1 JS可以干什么？ 可以动态改变网页中HTML标签的属性 可以动态改变网页中HTML标签的样式 可以对用户输入的数据进行合法性校验（格式检查） 可以动态操作（新增HTML标签、删除HTML标签、修改HTML标签）网页中的HTML标签 可以实现页面数据的异步通信 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test()&#123; //操作HTML标签的属性 document.getElementById(&quot;img1&quot;).width = 200; document.getElementById(&quot;img1&quot;).height = 200; //操作HTML标签的样式 document.getElementById(&quot;img1&quot;).style.borderRadius = &quot;50%&quot;; //移出HTML标签（DOM操作） document.getElementById(&quot;img1&quot;).remove(); //数据的异步交互 &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=&quot;img1&quot; src=&quot;imgs/img01.png&quot; width=&quot;&quot;/&gt; &lt;br/&gt; &lt;input type=&quot;button&quot; value=&quot;测试按钮&quot; onclick=&quot;test()&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 1.3.2 JS不能干什么？ JS虽然是在用户的浏览器中执行，但是JS不能访问用户的本地文件； JS不能操作来自于不同服务的网页文档 二、第一个JavaScript程序2.1 JavaScript写在哪里？ JS代码写在HTML文档的script标签中，script可以写在HTML文档的任何位置，通常写在body标签后，或者body标签中的最后面，并且一个HTML文档中支持多个script标签 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; //JS代码 &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; // JS代码 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JS代码也可以单独写在一个后缀名为.js的文件中，在HTML文档中通过script标签引用此JS文件 JavaScript代码写在JS文件中 引用JS文件的script标签不能自定义JS代码 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- script标签可以引用一个JS文件，也可以自定义JS代码实现： 1.如果script用来引用一个JS文件，script必须为双标签 2.script标签用来引用JS文件之后，则当前script标签中就不能再自定义JS代码 3.如果引用JS文件，还要进行自定JS代码实现，需要重新写一个script标签 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/test.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; //自定义JS代码 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.2 JavaScript函数（方法）定义 我们将实现某个功能的JavaScript代码定义在一个函数中 函数的定义语法： 123function &lt;fnName&gt;([参数])&#123; //Javascript代码&#125; 示例：（js&#x2F;test.js） 1234function test()&#123; //相当于Java程序中 System.out.println(&quot;Hello World!&quot;); 浏览器控制台输出 console.log(&quot;Hello World!&quot;);&#125; 2.3 JavaScript函数如何运行 通过HTML文档中的事件触发 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/test.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;test()&quot;&gt;测试按钮&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 2.4 查看浏览器的控制台输出 主流的浏览器点击F12按键 三、JavaScript基础语法 变量、数据类型 表达式、流程控制 3.1 变量与数据类型3.1.1 数据类型 Java是强类型语言：存储不同类型的值的变量声明时，需要声明为不同的类型 12int i = 5;String s = &quot;abc&quot; ; JavaScript是弱类型语言： 变量无论存储什么类型的值，我们一律使用var进行变量类型声明 一个变量可以设置不同类型的值 变量声明使用统一var类型，但是变量中存储的值是有类型的 1234567var i = 5; i = &quot;hello&quot;;var s = &quot;abc&quot;;var i = 5;var j = &quot;5&quot;;console.log(i+1); //输出 6console.log(j+1); //输出 51 3.1.2 变量 在JS代码如果要使用一个变量，需要先声明 声明一个变量需要指定其类型，所有变量都可以使用 var 如果一个变量只完成声明而没有初始化（赋初始值），则会输出undefined 3.1.3 不同类型变量值的初始化 字符串 1234var s = &quot;hello&quot;;var s = &#x27;hello&#x27;;var s = &quot;My name is &#x27;ergou&#x27;&quot;;var s = &#x27;My name is &quot;ergou&quot;&#x27;; 数字 123var i = 12; //整数var j = 3.14; //小数var k = 10e5; //科学计数法 布尔 12var b1 = true;var b2 = false; 数组 1234567var arr1 = new Array(); // JS中创建数组是不需要指定长度的arr1[0] = &quot;aaa&quot;;arr1[1] = &quot;bbb&quot;;var arr2 = new Array(&quot;aaa&quot;,&quot;bbb&quot;);var arr3 = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;]; 对象 123// JS中&#123;&#125;就表示对象类型，JS对象的属性名可以直接定义，并且对象的属性支持扩展//1.定义stu对象有两个属性var stu = &#123;stuNum:&quot;10001&quot;,stuName:&quot;王二狗&quot;&#125;;//2.对象号之后扩展一个属性stu.stuGender = &quot;男&quot;; undefined和null 如果一个变量只声明，没有初始化，输出undefined（undefined表示变量没有值） 通过将一个变量值设置为null来清空一个变量的值 12var i; //如果直接输出，输出为 undefinedi = &quot;aaa&quot;;i = null; //将i的值设置null，来清空i变量 3.2 表达式(运算符) 表达式就是由变量和运算符组合而成的代码 3.2.1 算术运算符 进行算术运算 +、-、*、&#x2F;除法、%取模 ++ 、– 3.2.2 赋值运算符 将值赋值给变量 &#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D; 1int i = 5;i+=3; //===&gt; i = i+3; 3.2.3 字符串拼接+12//1.如果+的两端都是数值，+就表示算术运算符//2.如果+有一端是字符串类型值，+就表示字符串拼接var = i+j; 3.2.4 关系运算符 用于比较两个值的大小关系 &gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、&#x3D;&#x3D; 、!&#x3D;、&#x3D;&#x3D;&#x3D;(绝对等于：值和类型都相同) 3.2.5 逻辑运算符 与或非，用于连接两个逻辑条件 &amp;&amp; 与 ||或 ! 非 3.2.6 三目运算符1// 当条件成立时，将v1的值赋值给变量i，如果条件不成立，则将v2赋值给变量ivar i = 条件?v1:v2; 3.3 流程控制3.3.1 分支语句 当满足不同的条件时，执行不同的代码块 if语句 单分支 123if(条件)&#123; //代码：当条件成立时执行代码&#125; 双分支 1234567//如果条件成立则执行代码1，不成立则执行代码2 //程序员的浪漫：世界上最遥远的距离不仅是生与死的距离，还有我的if你在else，永远相伴但不相见if(条件)&#123; //代码1 &#125;else&#123; //代码2&#125; 多分支 12345678910111213141516//当条件1成立，则执行代码1，不在判断后续条件//当条件1不成立，则判断条件2，条件2成立，则执行代码2，条件2不成立则继续判断条件3....直到找到第一个成立的条件//如果所有的条件都不成立，则执行else代码块 if(条件1)&#123; //代码1&#125;else if(条件2)&#123; //代码2&#125;else if(条件3)&#123; //代码3&#125;...&#123; //...&#125;else if(条件n)&#123; //代码n&#125;else&#123; //代码m&#125; switch语句 如果case代码后面没有break：当变量n的值与某个case的值相等时，从当前case的代码开始执行，直到遇到break关键字，如果没有break则会从当前case的位置一直执行到switch代码块结束 12345678910111213141516171819//判断 变量n 的值是否等于v1，如果相等则执行代码1；如果不相等则判断 变量n 的值是否等于v2//哪个case后面的值与 变量n相等，就执行哪个case的代码，如果所有case的值与n都不相等，则执行default的值switch(n)&#123; case v1: 代码1; break; case v2: 代码2; break; case v3: 代码3; break; ... case vN: 代码N; break; default: 代码M;&#125; 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;test1()&quot;&gt;测试按钮&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test1()&#123; var n = 5; switch(n)&#123; case 1: console.log(&quot;春天&quot;); break; case 2: console.log(&quot;夏天&quot;); break; case 3: console.log(&quot;秋天&quot;); break; case 4: console.log(&quot;冬天&quot;); break; default: console.log(&quot;未知季节&quot;); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.3.2 循环语句 当满足特定条件时，重复执行同一个代码块 for循环 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testFor()&quot;&gt;测试FOR&lt;/button&gt; &lt;button onclick=&quot;testForIn()&quot;&gt;测试ForIn&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testFor()&#123; for(var i=0 ; i&lt;10 ; i++) &#123; console.log(&quot;★&quot;); &#125; &#125; //遍历JS对象和数组 function testForIn()&#123; var stu = &#123;stuNum:&quot;10001&quot;,stuName:&quot;张三&quot;,stuGender:&quot;男&quot;&#125;; //1.遍历对象的属性名 for(v in stu)&#123; //根据对象属性名，从对象中获取属性值 console.log(v+&quot;：&quot;+stu[v]); &#125; //2. 遍历数组的索引 var arr = [&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;]; for(i in arr)&#123; //根据索引从数组中获取值 console.log(arr[i]); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; while循环 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testWhile()&quot;&gt;测试while&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testWhile()&#123; //注意：while循环，需要根据业务在循环体中修改循环条件变量 var i = 0; while(i&lt;10)&#123; console.log(i+&quot;★&quot;); i++; &#125; //do while ： 无论条件是否成立，都先执行一次循环体代码 // 然后判断条件是否成立，如果成立则继续执行下一次 var j = 10; do&#123; console.log(&quot;☆&quot;); j++; &#125;while(j&lt;10); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.3.3 break 和 continue break 和 continue都可以用来中断&#x2F;终端循环: break终止循环：跳出循环 continue中止循环：停止本次循环体的执行，进入到下一次循环 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testBreakAndContinue()&quot;&gt;测试break和continue的区别&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testBreakAndContinue()&#123; // break终止循环：跳出循环 for (var i = 1; i &lt;= 10; i++) &#123; if(i == 5)&#123; break; &#125; console.log(&quot;~~~~&quot;+i); &#125; // continue中止循环：停止本次循环体的执行，进入到下一次循环 for (var i = 1; i &lt;= 10; i++) &#123; if(i == 5)&#123; continue; &#125; console.log(&quot;----&quot;+i); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3.4 JavaScript错误处理 当JS引擎执行JS代码的过程中，因为代码错误、数据错误、系统资源等问题都可能导致JS执行过程中的异常 JS中的异常处理机制： try：检查其包含的JS代码是否出现错误 catch：处理JS中的错误（异常） finally：无论是否有异常，finally里面的代码总会执行 throw：用于创建自定义错误 JS异常处理语法： 123456789101112try&#123; if(n &gt;= 0)&#123; var age = n; &#125;else&#123; throw &quot;年龄不合法，不能为负数&quot;; &#125; //JS代码 try会检查JS代码是否出现错误，一旦出现错误就停止JS代码的执行，将错误提交给JS引擎&#125;catch(e)&#123; //异常处理代码 JS引擎一旦检测到错误，就停止try中代码的执行，进入到catch代码的执行，进行异常处理&#125;finally&#123; //代码， 无论try中的JS代码是否出现异常，finally里面的代码总会执行 （通常在finally做一些释放资源的工作）&#125; JS错误处理示例： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testError()&quot;&gt;测试错误处理&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testError()&#123; try&#123; console.log(&quot;--------------try&quot;); var m = 10; var n = 2; if(n!=0)&#123; var k = m/n; //JS中变量提升：将变量的声明提升至最全面 &#125;else&#123; throw &quot;n的值不能为0&quot;; //创建自定义错误 （这个地方有错误） &#125; console.log(&quot;K的值为：&quot;+k); &#125;catch(e)&#123; console.log(e); &#125;finally&#123; console.log(&quot;--------------finally&quot;); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 四、JavaScript对象 基于对象——通过对象完成属性、方法的调用 4.1 JavaScript对象创建 在Java中，先定义类，通过类的构造器创建对象，创建的这个类的对象具有类中定义的属性，并且能够调用这个类中定义的方法。 在JS中对象如何创建？ 直接通过{}创建对象 通过构造器创建对象 4.1.1 直接创建JS对象1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS对象&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testObj()&quot;&gt;创建JS对象&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testObj()&#123; //创建对象:通过&#123;&#125;创建对象 //1.定义对象属性：可以直接在&#123;&#125;中指定对象的属性 //2.定义对象方法:也可以直接在&#123;&#125;中定义当前对象的方法 var obj = &#123; id:&quot;101&quot;, name:&quot;zhangsan&quot;, test1:function()&#123; console.log(&quot;----test1&quot;); &#125; &#125;; //通过【对象.属性名】可以调用对象属性 //通过【对象.方法名(参数)】可以调用对象方法 console.log(obj.id); obj.test1(); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.1.2 使用JS构造函数创建对象 在JS中没有类的概念，但是可以定义构造器 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS对象&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testObj2()&quot;&gt;使用构造函数创建JS对象&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; //1.自定义JS构造函数 function Student(num,name)&#123; //1-1.定义属性 this.stuNum = num; this.stuName = name; //1-2.定义方法 this.method1 = function(a)&#123; console.log(&quot;Student---method1:&quot;+a); &#125; this.method2 = myMethod2; &#125; function myMethod2()&#123; console.log(&quot;Student---method2&quot;); &#125; function testObj2()&#123; //2.使用构造函数创建JS对象:通过构造函数创建的对象可以调用构造器中的属性和方法 var s1 = new Student(&quot;1001&quot;,&quot;张三&quot;); console.log(s1); s1.method1(&quot;wahaha&quot;); s1.method2(); var s2 = new Student(&quot;1002&quot;,&quot;李四&quot;); console.log(s2) s2.method1(&quot;hehehe&quot;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.2 JavaScript扩展属性 扩展属性——对象本没有某个属性，但是我们可以对其进行新增 4.2.1 对象扩展属性当对象创建好之后，我们可以通过对象.新属性=属性值;语法给当前对象新增属性，这个新增的属性只有当前对象才可以调用，即使通过同一个构造器创建的其他对象也没有这个属性。 1234567891011121314//定义构造函数，有两个属性function Student(num,name)&#123; this.stuNum = num; this.stuName = name;&#125;function testObj2()&#123; //通过Student构造函数，创建了第一个对象 var s1 = new Student(&quot;1001&quot;,&quot;张三&quot;); //给s1对象扩展 stuGender 属性 s1.stuGender = &quot;男&quot;; console.log(s1); //通过Student构造函数，创建了第二个对象，s1扩展的属性s2是没有 var s2 = new Student(&quot;1002&quot;,&quot;李四&quot;); console.log(s2)&#125; 4.2.2 构造函数扩展属性针对构造器方式创建JS对象，我们还可以扩展构造器的属性，当扩展构造器属性之后，此构造器创建的所有对象都有这个属性。 123456789101112131415161718//定义构造函数，有两个属性function Student(num,name)&#123; this.stuNum = num; this.stuName = name;&#125;function testObj2()&#123; //【构造器扩展属性: 构造器名.prototype.新属性名 = 属性值;】 Student.prototype.stuGender = &quot;男&quot;; //通过Student构造器创建的对象，都有扩展的stuGender属性 var s1 = new Student(&quot;1001&quot;,&quot;张三&quot;); console.log(s1); //输出对象看不到 stuGender属性 console.log(s1.stuGender); // 但是可以通过对象调用stuGender属性 var s2 = new Student(&quot;1002&quot;,&quot;李四&quot;); console.log(s2); console.log(s2.stuGender);&#125; 五、JavaScript内置对象5.1 内置对象介绍5.1.1 什么是JS内置对象？ JS中我们可以自定义构造器，通过自定义构造器创建JS对象。 JavaScript引擎预定义了一些构造器，并且在构造器中定义了能够完成特定功能的函数，通过这些构造器我们可以直接创建对象，创建的对象就可以可以调用函数完成功能。 JS内置对象：就是通过JavaScript预定义构造器创建的对象。 5.1.2 JavaScript中提供了哪些构造器？ 构造器 说明 Array JavaScript中的数组(集合)，在此构造器中定义了可以对数据进行操作的函数 String 字符串，其中定义了对字符串进行截取、分隔、正则校验等操作的函数、 Date 日期，包含对日期进行操作函数 Math 数学，其中定义了数学运算绝对值、三角函数、四舍五入等操作的函数 Number 数值，包含对数值进行操作的函数 RegExp 正则表达式，用于对字符串进行正则校验 Boolean 布尔 Object 通用对象 Error 用于异常处理的错误对象 Functions 顶层对象，Functions属性–全局属性，Functions函数–全局函数 Events 事件对象 例如按钮发生了点击事件 5.2 String对象 String 构造器创建的对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;内置对象&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testString()&quot;&gt;测试String&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testString()&#123; //1.创建String对象 var str1 = &quot;www.qfedu.com&quot;; var str2 = new String(&quot;www.TAOBAO.com&quot;); //2.属性 // length属性获取当前字符串的长度 var len = str1.length; //3.常用函数 // charAt : 获取str1中索引为3的字符（索引从0开始） var c = str1.charAt(3); // indexOf: 获取str1中第一次出现&quot;edu&quot;的索引 var i = str1.indexOf(&quot;edu&quot;); // lastIndexOf: 获取str2中最后一个“o”的索引 var j = str2.lastIndexOf(&quot;o&quot;); // split :分隔字符串，将str1用&quot;.&quot;分隔成多个字符串，存放到arr中 var arr = str1.split(&quot;.&quot;); // substring : 从str1字符串索引为4的位置开始截取，直到str1结束 var s1 = str1.substring(4); // 从str1字符串索引为4的位置开始截取(包含)，直到索引为9的位置(不包含) var s2 = str1.substring(4,9); //substr:从str1字符串索引为4的位置开始截取(包含),一共截取5个字符 var s3 = str1.substr(4,5); // toUpperCase : 将str2所有字母都转大写 var s4 = str2.toUpperCase(); //toLowerCase : 将str2所有字母都转小写 var s5 = str2.toLowerCase(); //match : 判断str3字符串的格式是否匹配reg的规则，如果不匹配则返回值为null var str3 = &quot;1303030330&quot;; //假设str3是用户在页面输入的手机号 var reg = &quot;^1[3,5,7,8]\\\\d&#123;9&#125;$&quot;; //手机号码的规则（正则表达式） var b = str3.match(reg); console.log(b); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5.3 RegExp对象（正则） 专门用于对字符串的格式进行规则的检查（规则：通过正则表达式体现） 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testRegExp()&quot;&gt;测试RegExp&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testRegExp()&#123; //String对象的match函数进行正则校验 var str1 = &quot;1303030330&quot;; var reg1 = &quot;^1[3,5,7,8]\\\\d&#123;9&#125;$&quot;; //match函数：如果校验匹配返回字符串，不匹配返回null var r = str1.match(reg1); console.log(r); //------------------------------------------------------------------ //RegExp对象的test函数进行正则校验 var str = &quot;1303030330&quot;; // 一个RegExp对象就是一个正则规则 var reg = new RegExp(&quot;^1[3578]\\\\d&#123;9&#125;$&quot;); //test 函数：如果匹配返回true，不匹配返回false var b = reg.test(str); console.log(b); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 正则表达式： 特殊符号： 符号 作用 \\d 任意数字 ，相当于[0-9] \\s 空白字符 \\b 单词便捷 \\u???? 匹配unicode字符 区间 表达式 说明 [0-9] 从0到9的任意数字 [0123456789] [13579] 表示1、3、5、7、9中任意一个数字 [a-z] 从a到z的任意一个小写字母 [A-Z] 从A到Z的任意一个大写字母 [a-zA-Z] 任意一个字母 [0-9a-zA-Z] 任意字母和数字 量词 量词 作用 a+ 至少一个a a* 0~n个a a? 0~1个a a{m} m个a a{m,n} m~n个 5.4 Math Math中提供的函数（静态函数），可以通过Math.直接调用 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;内置对象-Math&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testMath()&quot;&gt;测试Math&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testMath()&#123; //1.常量属性 var e = Math.E; var pi = Math.PI; //2.“静态”数学函数 //random : 随机产生一个[0,1)小数 var num = Math.random()*10; //round : 对参数进行四舍五入得到一个整数 var i = Math.round(num); //0-10 //floor：只舍不入，获取比参数小的最大整数 var j = Math.floor(num); //0-9 //ceil: 只入不舍，获取大于等于参数的最小整数 var k = Math.ceil(num); // abs : 获取参数的绝对值 var m = Math.abs(-5); //sqrt : 获取参数的平方根 var n = Math.sqrt(9); console.log(n); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5.5 Array对象 数组，存放一组相同类型数据的数据结构 在JS中，同一个数组中可以存放多种不同类型的数据，相当于Java等强类型语言中的集合（长度可变，可以存储多种类型数据） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testArray()&quot;&gt;测试Array&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testArray()&#123; //1.创建数组 // a.通过构造器创建数组 var arr1 = new Array(); var arr2 = new Array(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;); // b.静态初始化数组 var arr3 = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,1,2,3]; //2.数组的操作 // a.添加元素(索引可以不连续，数组长度=最大索引+1) arr1[0] = &quot;wanglaoji&quot;; arr1[1] = &quot;jiaduobao&quot;; arr1[5] = &quot;kangshifu&quot;; // b.通过索引获取数组中的元素 var v1 = arr1[0]; var v2 = arr1[1]; var v3 = arr1[9]; //数组索引越界（返回undefined） // c.遍历 // ①for循环遍历 for (var i = 0; i &lt;arr1.length; i++) &#123; var v = arr1[i]; console.log(i+&quot;:&quot;+v); &#125; // ②for ... in 遍历获取的数组元素的索引 for(var i in arr2)&#123; var v = arr2[i]; console.log(i+&quot;:&quot;+v) &#125; //3.Array中定义的函数 // join :将数组中所有的元素使用&quot;-&quot;拼接成一个字符串 var s1 = arr3.join(&quot;-&quot;); //slice : 从当前数组中截取元素，生成一个新数组 var arr = arr3.slice(2,4); // reverse: 将当前数组中的元素反转 arr3.reverse(); console.log(arr3); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5.6 Date对象1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;内置对象Date&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testDate()&quot;&gt;测试Date&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testDate()&#123; //1.创建Date对象:一个Date对象就表示一个时间，new Date()表示系统当前时间 var date = new Date(); //2. 函数 // set*: 设置当前日期的日期成分 date.setFullYear(2029); date.setMonth(11); date.setDate(28); // get* : 从当前日期对象中获取 时间成分 （年月日时分秒毫秒星期） var year = date.getYear()+1900; //获取年份，相对于1900年的偏移年份 var year2 = date.getFullYear(); //获取公元纪年你年份 var month = date.getMonth()+1; //获取月份0-11 var d = date.getDate(); //获取日期 var hour = date.getHours(); //获取小时 var min = date.getMinutes(); //获取分钟 var sec = date.getSeconds(); //获取秒 var ms = date.getMilliseconds();//获取毫秒 var day = date.getDay(); //获取星期 var timeStr = year+&quot;年&quot;+month+&quot;月&quot;+d+&quot;日 &quot;+hour+&quot;:&quot;+min+&quot;:&quot;+sec+&quot; &quot;+ms+&quot; 星期&quot;+day; console.log(timeStr); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 5.7 Functions对象全局函数 全局对象是一个预定义的对象，作为JavaScript中全局函数的占位符。通过全局对象，可以访问所有JS中的全局函数、全局属性。 全局对象不是任何对象的属性，所以它没有名称。 obj.method(); 全局函数(); PS：我们将全局函数归纳到Functions对象，但是在JS中window对象作为顶层容器，在语法上可以通过window对象调用全局函数。 例如：window.eval() 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testFunctions()&quot;&gt;测试全局函数&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testFunctions()&#123; //全局函数：通过全局对象Functions调用全局函数，Functions没有名称，因此全局函数可以直接调用 //parseInt：将字符串转换成整数数值 var s1 = &quot;123&quot;; var m = parseInt(s1); //parseFloat：将字符串转换成小数数值 var s2 = &quot;3.14&quot;; var n = parseFloat(s2); var url = &quot;http://www.qfedu.com/?param=中华有我&quot;; //encodeURI ： 对网址的参数部分进行编码（特殊符号和中文） var newUrl = encodeURI(url); //decodeURI：对编码后的网址进行解码 var url2 = decodeURI(newUrl); //escape：对字符串中的特殊和中文进行编码 var str1 = &quot;My name is 韩梅梅&quot;; var s = escape(str1); //unescape：对编码后的字符串进行解码 var str2 = unescape(s); //当一个字符串满足JS中对象的格式（JSON格式），我们可以通过eval转换成对象格式 var jsonStr = &quot;&#123;stuNum:&#x27;1001&#x27;,stuName:&#x27;张三&#x27;&#125;&quot;; //eval:将满足JSON格式的字符串转换成JS对象 var stu = eval(&quot;(&quot;+jsonStr+&quot;)&quot;); console.log(stu.stuName); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 六、BOM 浏览器对象模型6.1 BOM介绍Browser Object Model 浏览器对象模型。 JS编写在网页文档(document)中，网页文档运行在浏览器窗口(window)中，像document、window这样的对象也成为JS的宿主对象 6.2 window对象window对象是BOM模型中的顶层容器，表示打开的浏览器窗口 6.2.1 获取window对象window对象是所有浏览器都支持，是浏览器内置的对象，在JS代码中可以直接使用。 6.2.2 window对象属性 BOM对象属性 123456//获取BOM对象属性var v = window.navigator;var s = window.screen;var l = window.location;var h = window.history;var d = window.document; 浏览器窗口属性 12345678910111213141516171819//获取/设置当前浏览器窗口的名字window.name = &quot;w1&quot;;var name = window.name;//获取/设置当前浏览器窗口的状态栏window.status = &quot;☆&quot;;//获取当前窗口是否关闭var s = window.closed;//innerWidth: 获取浏览器的内部宽度 (IE8及以下版本不支持当前属性)//innerHeight：获取浏览器的内部高度 (IE8及以下版本不支持当前属性)var w = window.innerWidth;var h = window.innerHeight;//outerWidth: 获取浏览器的外部宽度 (IE8及以下版本不支持当前属性)//outerHeight：获取浏览器的外部高度 (IE8及以下版本不支持当前属性)var ow = window.outerWidth;var oh = window.outerHeight; 窗口对象属性 123456//self 就是当前窗口本身，等价于windows对象var w = window.self;//parent : 如果当前网页是现在另一个网页的iframe中，parent属性就表示获取当前窗口的上一级窗口 var p = window.parent;//top ： 获取当前窗口的顶层窗口var t = window.top; 6.2.3 window对象函数1.弹窗函数12345678910// alert ： 警告提示框,当用户在网页中进行错误操作时用于提示window.alert(&quot;请注意，倒车！&quot;);//confirm：消息确认框，当用户进行不可逆、且影响数据的操作，进行用户确认// 此弹窗有返回值，当用户点击“确定”时，返回truevar v = window.confirm(&quot;请问你确定删除这个信息吗？&quot;);//prompt：用户交互输入框，参数1(弹框问题提示信息)，参数2(输入框默认值)// 此弹窗有返回值，如果点击确定返回值为输入框中的值，点击取消返回值为nullvar v= window.prompt(&quot;请输入你的出生年份:&quot;,&quot;2021&quot;); 2.打开&#x2F;关闭窗口123456789101112131415//close：关闭当前窗口对象（IE有确认提示，谷歌就直接关了）window.close();//open(URL,name,features,replace) ： 打开一个新窗口// 参数1：新打开的窗口显示的网址// 参数2：新打开窗口的名字// 参数3：新打开的窗口的属性// 参数4：是否替换当前窗口 默认值为false，设置为true表示打开的新窗口会替代当前窗口// 返回值：打开的窗口对象var URL = &quot;https://www.baidu.com&quot;;var features = &quot;&quot;;// var w = window.open(URL); //var w = window.open(URL,&quot;百度&quot;);// var w = window.open(URL,&quot;百度&quot;,features);var w = window.open(URL,name,true); 打开新窗口特征（Window Features） channelmode&#x3D;yes|no|1|0 是否使用剧院模式显示窗口。默认为 no。 directories&#x3D;yes|no|1|0 是否添加目录按钮。默认为 yes。 fullscreen&#x3D;yes|no|1|0 是否使用全屏模式显示浏览器。默认是 no。处于全屏模式的窗口必须同时处于剧院模式。 height&#x3D;pixels 窗口文档显示区的高度。以像素计。 left&#x3D;pixels 窗口的 x 坐标。以像素计。 location&#x3D;yes|no|1|0 是否显示地址字段。默认是 yes。 menubar&#x3D;yes|no|1|0 是否显示菜单栏。默认是 yes。 resizable&#x3D;yes|no|1|0 窗口是否可调节尺寸。默认是 yes。 scrollbars&#x3D;yes|no|1|0 是否显示滚动条。默认是 yes。 status&#x3D;yes|no|1|0 是否添加状态栏。默认是 yes。 titlebar&#x3D;yes|no|1|0 是否显示标题栏。默认是 yes。 toolbar&#x3D;yes|no|1|0 是否显示浏览器的工具栏。默认是 yes。 top&#x3D;pixels 窗口的 y 坐标。 width&#x3D;pixels 窗口的文档显示区的宽度。以像素计。 3.窗口操作函数对浏览器窗口进行尺寸设置、位置设置、滚动条操作等的函数 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testWindow()&quot;&gt;测试window&lt;/button&gt; &lt;div style=&quot;height: 1500px; width: 2500px; background: lemonchiffon;&quot;&gt; 1&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 2&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 3&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 4&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 5&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testWindow()&#123; //打开新窗口，返回值w就表示新打开的浏览器窗口，w本身就是一个window对象 //var w = window.open(&quot;http://www.qfedu.com&quot;,&quot;千锋官网&quot;,&quot;width=400,height=300&quot;); //1.修改窗口尺寸 // resizeTo：将w窗口尺寸修改为 *,* w.resizeTo(800,600); // resizeBy：在窗口之前的尺寸宽度和高度各增加多少 w.resizeBy(800,600) //2.改变窗口位置 //moveTo：将窗口移动到指定的位置 // 参数1:窗口与屏幕左边的距离 // 参数2:窗口与屏幕顶端的距离 w.moveTo(200,100); //moveBy：基于窗口当前的位置，横向偏移和纵向偏移 w.moveBy(200,100); //3.滚动滚动条(针对当前窗口的滚动条操作) //scrollTo：将当前窗口的横向和纵向滚动条滚动指定的偏移量(x,y) window.scrollTo(100,300); //scrollBy：将当前窗口的横向和纵向滚动条滚动指定相对偏移量 window.scrollBy(-100,-200); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 4.延时&#x2F;循环任务延时任务：延迟指定的时间之后再去调用对应的函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;test1()&quot;&gt;打开延时任务&lt;/button&gt; &lt;button onclick=&quot;test2()&quot;&gt;关闭延时任务&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; var task1; function test1()&#123; console.log(&quot;~~~~~~~~test1&quot;); //setTimeout，延时调用指定方法 // 参数1：调用的方法， 参数2：延迟的时间（单位：ms） task1 = window.setTimeout( &quot;showDate()&quot;,3000); &#125; function showDate()&#123; var date = new Date(); date.setFullYear(2029); date.setMonth(11); date.setDate(28); date.setHours(14); var year = date.getYear()+1900; //获取年份，相对于1900年的偏移年份 var month = date.getMonth()+1; //获取月份0-11 var d = date.getDate(); //获取日期 var hour = date.getHours(); //获取小时 var min = date.getMinutes(); //获取分钟 var sec = date.getSeconds(); //获取秒 var str = year+&quot;-&quot;+month+&quot;-&quot;+d+&quot; &quot;+hour+&quot;:&quot;+min+&quot;:&quot;+sec; console.log(str); &#125; function test2()&#123; console.log(&quot;~~~~~~~~test2&quot;); //关闭未执行的延时任务 window.clearTimeout(task1); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 循环任务：间隔指定的时间循环调用函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;test1()&quot;&gt;打开循环任务&lt;/button&gt; &lt;button onclick=&quot;test2()&quot;&gt;关闭循环任务&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; var task2; function test1()&#123; console.log(&quot;~~~~~~~~test1&quot;); //setInterval，启动循环任务 // 参数1：调用的方法， 参数2：间隔的时间（单位：ms） task2 = window.setInterval( &quot;showDate()&quot;,1000); &#125; function showDate()&#123; var date = new Date(); date.setFullYear(2029); date.setMonth(11); date.setDate(28); date.setHours(14); var year = date.getYear()+1900; //获取年份，相对于1900年的偏移年份 var month = date.getMonth()+1; //获取月份0-11 var d = date.getDate(); //获取日期 var hour = date.getHours(); //获取小时 var min = date.getMinutes(); //获取分钟 var sec = date.getSeconds(); //获取秒 var str = year+&quot;-&quot;+month+&quot;-&quot;+d+&quot; &quot;+hour+&quot;:&quot;+min+&quot;:&quot;+sec; console.log(str); &#125; function test2()&#123; console.log(&quot;~~~~~~~~test2&quot;); //clearInterval：关闭正在进行的循环任务 window.clearInterval(task2); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 6.2.4 window对象总结 window对象调用属性、函数都可以省略 6.3 screen对象 screen对象，表示网页显示的硬件设备的屏幕 screen是一个只读对象，它收集硬件屏幕的相关参数，我们可以通过此对像获取当前终端屏幕的相关参数。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testScreen()&quot;&gt;测试Screen&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testScreen()&#123; //1.获取屏幕的宽度和高度(分辨率) var w = screen.width; var h = screen.height; //2.获取屏幕可用的宽度和高度（除掉状态栏） var aw = screen.availWidth; var ah = screen.availHeight; //3.屏幕硬件一英寸的物理像素点 var xdpi = screen.deviceXDPI; var ydpi = screen.deviceYDPI; alert(xdpi+&quot;*&quot;+ydpi); //练习：通过获屏幕的宽度和高度，打开一个新窗口，使其位于屏幕的正中间 &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 6.4 navigator对象 navigator对象包含了浏览器相关的信息 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testnavigator()&quot;&gt;测试navigator&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testnavigator()&#123; //返回浏览器的名称（在老版本的IE中可以测试） var name = navigator.appName; //返回浏览器的代码名 var code = navigator.appCodeName; //返回浏览的平台及版本信息 var version = navigator.appVersion; //返回浏览器的语言环境（并不是所有浏览器都支持） var lang = navigator.browserLanguage; //检查当前浏览器是否启用cookie var b = navigator.cookieEnabled; console.log(b); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 6.5 location对象 表示当前浏览器窗口的地址信息，通过此对象可以获取地址栏信息、设置地址栏信息 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testLocation()&quot;&gt;测试Location&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testLocation()&#123; //获取地址栏完整的网址 http://127.0.0.1:8848/demo3/page20-BOM-location.html?key=value // 协议 主机 端口 路径 参数 var s1 = location.href; //获取地址栏网址的协议 var s2 = location.protocol; //获取地址栏网址的端口 var s3 = location.port; // 获取地址栏网址的主机和端口 var s4 = location.host; // 获取地址栏网址的主机 var s5 = location.hostname; // 获取地址栏网址的资源路径 var s6 = location.pathname; //★ 修改地址栏完整的网址（可以实现网页跳转） location.href = &quot;http://www.qfedu.com/&quot;; //location对象的函数 //reload ： 重新载入当前网页（刷新网页） location.reload(); //replace：使用参数指定的网址替换当前地址栏的网址（实现网页跳转） location.replace(&quot;http://www.qfedu.com/&quot;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 6.6 history对象 history对象包含了用户在当前浏览器窗口中访问过的URL 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;C&lt;/title&gt; &lt;/head&gt; &lt;body&gt; C页面 &lt;hr/&gt; &lt;a href=&quot;d.html&quot;&gt;跳转到D页面&lt;/a&gt; &lt;hr/&gt; &lt;button onclick=&quot;test1()&quot;&gt;🔙&lt;/button&gt; &lt;button onclick=&quot;test2()&quot;&gt;➡&lt;/button&gt; &lt;button onclick=&quot;test3()&quot;&gt;历史记录的数量&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test1()&#123; //back ： 返回上一个页面 //history.back(); history.go(-1); &#125; function test2()&#123; //forward：切换到下一个页面 //history.forward(); history.go(1); &#125; function test3()&#123; //length属性，获取历史记录中网址的个数 var len = history.length; console.log(len); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 七、DOM 文档对象模型7.1 文档对象模型介绍 DOM树——对于一个网页文件，我们可以类比做一颗树，根标签HTML看做树根，文档中所有的标签都可以理解为这棵树上的树枝或叶子。 通过DOM树结构，我们可以从根标签有序的获取、操作文档中任何一个子标签。 7.1.1 DOM树 DOM树模型 7.1.2 相关术语元素：标签以及标签所包含的内容 元素属性：标签的属性 节点：元素、属性、文本统称为节点（元素—标签节点、属性—属性节点、文本—文本节点） 节点名称：标签节点的节点名就是标签名，属性节点的节点名就是属性名，文本节点的节点名是text 7.2 document对象document对象指代的就是一个网页文档，document对象提供属性、函数大多都是获取网页文档中的元素 7.2.1 集合属性1234567891011// all : 获取当前网页文档中的所有元素var arr1 = document.all;// imgs : 获取当前网页文档中所有图片var arr2 = document.images;// links: 获取当前网页文档中所有的链接(a,area)var arr3 = document.links;// forms：获取当前网页文档中的form元素var arr4 = docuemnt.forms; 7.2.2 其他属性12345678910111213141516// body:获取当前网页文档中的body元素var body = document.body;// title：获取当前网页文档的标题内容var title = document.title;// 设置当前文档的标题document.title = &quot;千锋Java&quot;;// URL : 获取当前网页文档的URLvar url = document.URL;// cookie : 向cookie中添加新的数据document.cookie = &quot;key=value&quot;;document.cookie = &quot;key2=value2&quot;;// cookie : 获取cookie中缓存的内容var cs = document.cookie; 7.2.4 函数 流操作 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;document对象&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;testDocument()&quot;&gt;测试document对象&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testDocument()&#123; //write : 通过网页输出流将数据输出并显示到网页中 // 如果执行多次write函数使用的是同一个流，则输出的数据会追加 // 如果多次write使用的是不同的流，后面write的内容会覆盖之前的内容 document.write(&quot;从前有座山&quot;); document.write(&quot;山里有座庙&quot;); //close: 关闭当前网页输出流，关闭之后如果执行write，则会打开新的流 document.close(); //open ：打开并使用一个新的流 document.open(); document.write(&quot;庙里有...&quot;); //writeln &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 获取网页元素的函数 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;document对象&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img class=&quot;cc&quot; name=&quot;m1&quot; src=&quot;imgs/img01.png&quot; height=&quot;100&quot;/&gt;&lt;br/&gt; &lt;img id=&quot;img2&quot; src=&quot;imgs/img02.png&quot; height=&quot;100&quot;/&gt;&lt;br/&gt; &lt;img name=&quot;m1&quot; src=&quot;imgs/img03.png&quot; height=&quot;100&quot;/&gt;&lt;br/&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p class=&quot;cc&quot;&gt;p2&lt;/p&gt; &lt;p&gt;p3&lt;/p&gt; &lt;button onclick=&quot;test1()&quot;&gt;测试getElement...函数&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test1()&#123; //getElementById：根据标签的id属性获取一个元素 var e = document.getElementById(&quot;img2&quot;); //getElementsByName：根据标签的name属性获取一组元素 var es = document.getElementsByName(&quot;m1&quot;); //getElementsByClassName：根据标签的class属性获取一组元素 var es2 = document.getElementsByClassName(&quot;cc&quot;); //getElementsByTagName：根据标签名获取一组元素 var es3 = document.getElementsByTagName(&quot;p&quot;); console.log(es3); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 7.3 对HTML标签的操作 对HTML标签的操作，主要是标签属性操作和标签样式操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .imgStyle&#123; width: 200px; height: 200px; border-radius: 50%; transform: rotate(45deg); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;imgs/img01.png&quot; height=&quot;200&quot;/&gt;&lt;br/&gt; &lt;img id=&quot;img2&quot; src=&quot;imgs/img02.png&quot; height=&quot;200&quot;/&gt;&lt;br/&gt; &lt;img id=&quot;img3&quot; src=&quot;imgs/img03.png&quot; height=&quot;200&quot;/&gt;&lt;br/&gt; &lt;button onclick=&quot;testAttrOper()&quot;&gt;操作标签属性&lt;/button&gt; &lt;button onclick=&quot;testStyleOper()&quot;&gt;操作标签样式&lt;/button&gt; &lt;button onclick=&quot;testClassOper()&quot;&gt;操作标签class属性&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testAttrOper()&#123; var img = document.getElementById(&quot;img2&quot;); //操作标签属性（标签对象.标签属性名） // a.获取属性值 var s = img.src; // b.设置属性值 img.src = &quot;imgs/img03.png&quot;; &#125; function testStyleOper()&#123; var img = document.getElementById(&quot;img2&quot;); //操作标签样式 (标签对象.style.样式属性名) //样式属性名在css中是以&quot;-&quot;分割多个单词，在JS中操作要使用驼峰命名 // a.设置标签的样式属性 img.style.border = &quot;2px rgba(255,0,0,0.5) solid&quot;; img.style.borderRadius=&quot;10px&quot;; // b.获取标签的样式属性 var m = img.style.border; console.log(m); &#125; function testClassOper()&#123; var img3 = document.getElementById(&quot;img3&quot;); //标签对象的 class属性 使用className进行操作 img3.className = &quot;imgStyle&quot;; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 7.4 案例：表单数据校验7.4.1 案例说明 在网页中的数据提交时（登录、注册、提交订单等），如果必须填写的数据没有填写完成，或者填写的数据格式不符合要求，表单是不允许提交的。在网页中就是通过JS完成数据的完成行及合法性校验。 检验规则： 帐号： 不能为空，长度8~20之间，只能包含数字和字母 密码：不能为空，长度8~16 确认密码：要与密码一致 手机号：不能为空，满足手机号码规则 邮箱：不能为空，满足邮箱格式规则 7.4.2 案例实现 form_validate.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function doValidate()&#123; console.log(&quot;-----doValidate&quot;) //对输入的数据进行校验，如果输入的数据OK，return true //1.校验用户名 var userName = document.getElementById(&quot;userNameInput&quot;).value; var label1 = document.getElementById(&quot;userNameTipsLabel&quot;); if(userName== null || userName == &quot;&quot;)&#123; // 通过innerHTML属性修改 标签对象的里面的值 label1.innerHTML = &quot;请输入用户名！&quot;; label1.style.color = &quot;red&quot;; return false; &#125;else if( userName.length&lt;8 || userName.length&gt;20 )&#123; label1.innerHTML = &quot;用户名长度必须为8-20个字符！&quot;; label1.style.color = &quot;red&quot;; return false; &#125;else if( ! new RegExp(&quot;^[0-9a-zA-Z]*$&quot;).test(userName) )&#123; label1.innerHTML = &quot;用户名只允许包含数字和字母&quot;; label1.style.color = &quot;red&quot;; return false; &#125;else&#123; //进入else 表示用户名已经合法 label1.innerHTML = &quot;用户名输入正确！&quot;; label1.style.color = &quot;green&quot;; &#125; //2.检验密码 var userPwd = document.getElementById(&quot;userPwdInput&quot;).value; var label2 = document.getElementById(&quot;userPwdTipsLabel&quot;); if(userPwd == null || userPwd == &quot;&quot;)&#123; label2.innerHTML = &quot;请输入密码！&quot;; label2.style.color=&quot;red&quot;; return false; &#125;else if(userPwd.length&lt;8 ||userPwd.length&gt;16 )&#123; label2.innerHTML = &quot;密码长度必须为8-16个字符！&quot;; label2.style.color = &quot;red&quot;; return false; &#125;else&#123; //密码正确 label2.innerHTML = &quot;密码输入正确！&quot;; label2.style.color = &quot;green&quot;; &#125; //3.确认密码 var rePwd = document.getElementById(&quot;rePwdInput&quot;).value; var label3 = document.getElementById(&quot;rePwdTipsLabel&quot;); if(rePwd == null || rePwd == &quot;&quot;)&#123; label3.innerHTML = &quot;请再次输入密码！&quot;; label3.style.color=&quot;red&quot;; return false; &#125;else if(userPwd != rePwd)&#123; label3.innerHTML = &quot;两次密码输入不一致！&quot;; label3.style.color=&quot;red&quot;; return false; &#125;else&#123; label3.innerHTML = &quot;重复密码输入正确！&quot;; label3.style.color=&quot;green&quot;; &#125; //4.验证手机 //5.验证邮箱 return true;&#125; regist.html 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/form_validate.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- onsubmit 表单提交时间 ，如果函数返回false则不提交表单，如果返回ture则提交表单--&gt; &lt;form action=&quot;http://www.qfedu.com&quot; onsubmit=&quot;return doValidate()&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;用户注册-数据校验&lt;/legend&gt; &lt;p&gt; 账号：&lt;!-- 对于输入框对象而言，value属性就是输入框的值 --&gt; &lt;input id=&quot;userNameInput&quot; type=&quot;text&quot; placeholder=&quot;请输入用户名&quot;/&gt; &lt;label id=&quot;userNameTipsLabel&quot;&gt;&lt;/label&gt; &lt;/p&gt; &lt;p&gt; 密码： &lt;input id=&quot;userPwdInput&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot;/&gt; &lt;label id=&quot;userPwdTipsLabel&quot;&gt;&lt;/label&gt; &lt;/p&gt; &lt;p&gt; 确认密码： &lt;input id=&quot;rePwdInput&quot; type=&quot;password&quot; placeholder=&quot;请再次输入密码&quot;/&gt; &lt;label id=&quot;rePwdTipsLabel&quot;&gt;&lt;/label&gt; &lt;/p&gt; &lt;p&gt; 手机号： &lt;input type=&quot;text&quot; placeholder=&quot;请输入手机&quot;/&gt;&lt;label&gt;&lt;/label&gt; &lt;/p&gt; &lt;p&gt; 邮箱： &lt;input type=&quot;text&quot; placeholder=&quot;请输入邮箱&quot;/&gt;&lt;label&gt;&lt;/label&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/p&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 7.5 节点操作 元素、元素属性以及文本都称之为节点 节点操作——使用JS完成节点创建、插入节点、修改节点、删除节点 7.5.1 节点属性 节点类型 nodeType nodeName nodeValue 标签节点 1 标签名 null 属性节点 2 属性名 属性值 文本节点 3 #text 文本内容 对于HTML元素对象： 12345//1.获取标签属性var arr1 = tag.attributes;//2.获取标签的子标签var arr2 = tag.childNodes; 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body style=&quot;color: #F08080;&quot; bgcolor=&quot;azure&quot;&gt; &lt;div id=&quot;div1&quot;&gt;hello&lt;h3&gt;枫桥夜泊&lt;/h3&gt; &lt;p&gt;月落乌啼霜满天，&lt;/p&gt; &lt;p&gt;江枫渔火对愁眠；&lt;/p&gt; &lt;p&gt;姑苏城外寒山寺，&lt;/p&gt; &lt;p&gt;夜半钟声到客船。&lt;/p&gt; &lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;测试&quot; onclick=&quot;test()&quot;/&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test()&#123; var body = document.body; console.log(body); //attributes：所有的标签对象都可以调用attributes属性，获取当前标签的属性列表 var attrsArr = body.attributes; //此数组中存放的就是style 和 bgcolor两个属性 //属性节点： var attrNode = attrsArr[0]; console.log(attrNode.nodeType); console.log(attrNode.nodeName); console.log(attrNode.nodeValue); //childNodes所有的标签对象都可以通过childNodes属性获取当前标签的子节点(包括标签节点、文本节点) var div = document.getElementById(&quot;div1&quot;); var nodesArr = div.childNodes; //文本节点 var textNode = nodesArr[0]; console.log(textNode.nodeType); console.log(textNode.nodeName); console.log(textNode.nodeValue); //标签节点 var tagNode = nodesArr[1]; console.log(tagNode.nodeType); console.log(tagNode.nodeName); console.log(tagNode.nodeValue); &#125; &lt;/script&gt;&lt;/html&gt; 7.5.2 创建新节点 网页中原来没有这个节点，通过JS代码新建一个节点 12345678//创建标签节点（元素）var tagNode = document.createElement(&quot;img&quot;);//创建文本节点var textNode = document.createTextNode(&quot;hello world&quot;);//创建属性节点var attrNode = document.createAttribute(&quot;name&quot;); 7.5.3 插入节点 将创建的新节点载入到网页文档中 标签节点的属性操作 123456789101112131415161718//1.创建标签节点var imgTag = document.createElement(&quot;img&quot;); //&lt;img&gt;//-------------------------------------------------------------begin//2.创建属性节点var srcAttr = document.createAttribute(&quot;src&quot;); // src=&quot;&quot;srcAttr.nodeValue = &quot;imgs/img01.png&quot;; // src=&quot;imgs/img01.png&quot;//3.将属性节点添加到标签节点中 imgTag.setAttributeNode(srcAttr); // &lt;img src=&quot;imgs/img01.png&quot;&gt;//---------------------------------------------------------------end//4.给标签节点添加/修改属性imgTag.setAttribute(&quot;src&quot;,&quot;imgs/img02.png&quot;);imgTag.setAttribute(&quot;width&quot;,&quot;200&quot;);imgTag.alt = &quot;图片无法显示&quot;;//5.从标签节点上移出一个属性imgTag.removeAttribute(&quot;alt&quot;); 拼接子节点 1234//6.appendChild : 拼接子节点 //tagNode.appendChild(cNode); 将cNode这个标签节点拼接到 body标签里面（最后面）var body = document.body;body.appendChild(imgTag); 插入子节点 123//7.insertBefore: 插入子节点 parentTag.insertBefore(imgTag,btnTag); 将imgTag插入到parentTag里面btnTag之前var btnTag = document.getElementById(&quot;btn_test&quot;);body.insertBefore(imgTag,btnTag); 7.5.4 替换子节点 可以使用新建的标签节点去替换某个节点，也可以获取网页中已经存在的标签去替换： 如果使用新创建的节点 去替换 某个父节点的子节点则直接替换； 如果使用网页中已经存在的标签A 去替换标签B ，A会发生移动（并不是拷贝A去替换B） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #container&#123; border: #F08080 2px solid; width: 400px; height: 300px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body &gt; &lt;div id=&quot;container&quot;&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p id=&quot;p&quot;&gt;我是一个图片&lt;/p&gt; &lt;p&gt;world&lt;/p&gt; &lt;/div&gt; &lt;img id=&quot;img3&quot; src=&quot;imgs/img03.png&quot; height=&quot;100&quot; /&gt; &lt;input id=&quot;btn_test&quot; type=&quot;button&quot; value=&quot;测试&quot; onclick=&quot;test()&quot;/&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test()&#123; //使用一个图片标签，替换div中的p标签 //0. 创建新节点 //var imgTag = document.createElement(&quot;img&quot;); //imgTag.src = &quot;imgs/img01.png&quot;; //imgTag.height=100; // 获取网页中已经存在的图片标签: // 如果使用网页中已经存在的标签A 去替换标签B ，A会发生移动（并不是拷贝A去替换B） var imgTag = document.getElementById(&quot;img3&quot;); // 1.替换子节点 // parentTag.replaceChild(newChild,oldChild) // 使用newChild替换parentTag中的oldChild var parentTag = document.getElementById(&quot;container&quot;); var oldChild = document.getElementById(&quot;p&quot;); parentTag.replaceChild(imgTag,oldChild); // 2.替换节点 // currentTag.replace( newTag):使用newTag来替换currentTag (受浏览器支持的限制) // oldChild.replaceNode(imgTag); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 7.5.5 删除子节点123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #container&#123; border: #F08080 2px solid; width: 400px; height: 300px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body &gt; &lt;div id=&quot;container&quot;&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p id=&quot;p&quot;&gt;我是一个图片&lt;/p&gt; &lt;p&gt;world&lt;/p&gt; &lt;/div&gt; &lt;input id=&quot;btn_test&quot; type=&quot;button&quot; value=&quot;测试&quot; onclick=&quot;test()&quot;/&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test()&#123; var div = document.getElementById(&quot;container&quot;); var p = document.getElementById(&quot;p&quot;); //删除节点 //removeNode ：删除当前节点 （IE支持，其他浏览器兼容性不强） //p.removeNode(true); //删除子节点 //parentTag.removeChild(oldChild) :从parentTag中删除oldChild div.removeChild(p); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 八、JavaScript事件 事件：在网页文档中发生行为（可以是网页文档加载过程产生、也可以用户人为操作的） 8.1 JS事件绑定 JS函数是通过网页事件驱动的，驱动的方式有两种：内联方式 和 外联方式 8.1.1 HTML内联绑定在HTML标签上添加事件属性，绑定对应的JS函数： 1234567&lt;button onclick=&quot;test1()&quot;&gt;测试按钮1&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; function test1()&#123; console.log(&quot;------------test1&quot;); &#125;&lt;/script&gt; 8.1.2 JS脚本外联绑定不在HTML标签上写事件属性，通过JS获取HTML元素，调用事件属性绑定JS函数： 12345678&lt;button id=&quot;btn2&quot;&gt;测试按钮2&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; var btn2 = document.getElementById(&quot;btn2&quot;); btn2.onclick = function()&#123; console.log(&quot;------------test2&quot;); &#125;&lt;/script&gt; 8.2 HTML常用事件 鼠标事件 键盘事件 （表单标签） window事件 表单事件 8.2.1 鼠标事件 用户的鼠标在HTML标签上产生点击、双击、移动、放上、离开等动作 onclick 单击 ondblclick 双击 onmouseover 鼠标移动到HTML元素上 onmouseout 鼠标从HTML元素上移走 onmousemove 鼠标在HTML元素上移动 onmousedown 鼠标在HTML元素上左键按下 onmouseup 鼠标在HTML元素上左键松开 123456789101112131415161718192021222324252627&lt;img src=&quot;imgs/img01.png&quot; width=&quot;200&quot; onclick=&quot;test1()&quot; ondblclick=&quot;test2()&quot; onmouseover=&quot;test3()&quot; onmouseout=&quot;test4()&quot; onmousemove=&quot;test5()&quot; onmousedown=&quot;test6()&quot; onmouseup=&quot;test7()&quot;/&gt;&lt;script type=&quot;text/javascript&quot;&gt; function test1()&#123; console.log(&quot;----test1&quot;); &#125; function test2()&#123; console.log(&quot;----test2&quot;); &#125; function test3()&#123; console.log(&quot;----test3&quot;); &#125; function test4()&#123; console.log(&quot;----test4&quot;); &#125; function test5()&#123; console.log(&quot;----test5&quot;); &#125; function test6()&#123; console.log(&quot;----test6&quot;); &#125; function test7()&#123; console.log(&quot;----test7&quot;); &#125;&lt;/script&gt; 8.2.2 键盘事件 键盘事件主要是针对于表单中的输入标签 onkeydown 键盘按键按下（如果按下去不松开则一直触发） onkeyup 键盘按键抬起 onkeypress 键盘按键按下(只支持字符键) 12345678910111213&lt;input type=&quot;text&quot; onkeydown=&quot;test8()&quot; onkeyup=&quot;test9()&quot; onkeypress=&quot;test10()&quot;/&gt; &lt;script type=&quot;text/javascript&quot;&gt; function test8()&#123; console.log(&quot;----test8&quot;); &#125; function test9()&#123; console.log(&quot;----test9&quot;); &#125; function test10()&#123; console.log(&quot;----test10&quot;); &#125;&lt;/script&gt; 8.2.3 window事件 window对象触发的时间，window对象并不是一个HTML标签，window对象的事件通常使用JS脚本绑定 1234567891011121314151617181920//onload ： 当网页中body标签内容加载完毕触发window.onload = function()&#123; console.log(&quot;------onload&quot;);&#125;//onunload ： 当前网页关闭或刷新时执行，用于回收资源window.onunload = function()&#123; console.log(&quot;------onunload&quot;);&#125;//onscroll ：当网页发生滚动时触发执行window.onscroll = function()&#123; console.log(&quot;------onscroll&quot;);&#125;//onresize ：窗口的尺寸发生变化时触发window.onresize = function()&#123; console.log(&quot;------onscroll&quot;);&#125; 案例：如果在HTML的head标签中通过js绑定事件，必须写在 window.onload= function()&#123;&#125;中 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var btn = document.getElementById(&quot;btn&quot;); btn.onclick = function()&#123; console.log(&quot;-----hello&quot;); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;btn&quot;&gt;测试按钮&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 8.2.4 表单事件 上面讲到的键盘事件通常是绑定在表单输入标签，但是表单输入标签支持的事件不止键盘事件 onfocus 获取焦点 onblur 失去焦点 onchange 内容发生改变 onselect 内容被选中 onsubmit 表单提交（必须绑定在form元素上） onreset 重置表单（必须绑定在form元素上） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;userName&quot;/&gt; &lt;select id=&quot;num&quot;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &lt;form action=&quot;http://www.qfedu.com&quot;&gt; &lt;input type=&quot;text&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt; &lt;input type=&quot;reset&quot; /&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; var userNameInputTag = document.getElementById(&quot;userName&quot;); //onfocus：当表单标签获得焦点时触发 userNameInputTag.onfocus = function()&#123; console.log(&quot;~~~~~~~test1&quot;); &#125; //onblur ：当表单标签失去焦点时触发 userNameInputTag.onblur = function()&#123; console.log(&quot;~~~~~~~test2&quot;); &#125; //onchange ：当表单标签中的值发生变化触发（输入框输入完成失去焦点后判断） userNameInputTag.onchange = function()&#123; console.log(&quot;~~~~~~~test3&quot;); &#125; //select标签页支持onchange事件 document.getElementById(&quot;num&quot;).onchange = function()&#123; console.log(&quot;~~~~~~~test4&quot;); &#125; //onselect：当输入框中输入的内容被选中时触发 userNameInputTag.onselect = function()&#123; console.log(&quot;~~~~~~~test5&quot;); &#125; //onsubmit ：绑定在form元素上，当此表单被提交时触发 document.forms[0].onsubmit = function()&#123; console.log(&quot;~~~~~~~test6&quot;); return false; //阻止表单提交 &#125; //onsubmit ：绑定在form元素上，当此表单被重置时触发 document.forms[0].onreset = function()&#123; console.log(&quot;~~~~~~~test7&quot;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 8.3 Event事件对象 JS将标签发生的动作抽象为事件对象 Event对象用来描述HTML标签与发生的动作的组合 一个按钮发生了点击事件 — Event对象 一个图片发生了点击事件 — Event对象 一个图片发生了鼠标移动时间 —Event对象 8.3.1 获取event对象方式一：在JS函数中，使用window对象调用event属性获取触发当前JS函数的event对象 12345678&lt;button onmouseover=&quot;test1()&quot;&gt;按钮&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; function test1()&#123; //window.event 获取当前事件对象 var ev = window.event; &#125;&lt;/script&gt; 方式二：如果使用JS脚本绑定函数，也可以使用函数的参数直接获取 123456789&lt;img src=&quot;imgs/img01.png&quot; height=&quot;100&quot; id=&quot;img&quot;/&gt;&lt;script type=&quot;text/javascript&quot;&gt; var img = document.getElementById(&quot;img&quot;); img.onclick = function(ev)&#123; //参数 ev 即为 event对象 console.log(ev); &#125;&lt;/script&gt; 8.3.2 event对象属性1234567//event对象调用srcElement属性，可以获取触发此事件的标签var tag = event.srcElement; console.log(tag);//event对象调用type属性，可以获取事件的类型var type = event.type;console.log(type); 8.4 阻止事件冒泡 事件冒泡：在子标签发生的事件触发了当前标签上层父标签绑定的函数 通过event对象阻止事件冒泡： event.cancelBubble &#x3D; true; event.stopPropagation(); 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div&quot; style=&quot;padding:50px; width: 100px; height: 100px; background: rgba(255,0,0,0.5);&quot;&gt; &lt;button id=&quot;btn&quot;&gt;测试按钮&lt;/button&gt; &lt;img src=&quot;imgs/img01.png&quot; height=&quot;50&quot;/&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var div = document.getElementById(&quot;div&quot;); div.onclick = function()&#123; console.log(&quot;------------test1&quot;); &#125; //阻止事件冒泡 var arr = div.childNodes; for(var i=0; i&lt;arr.length ; i++)&#123; var node = arr[i]; if(node.nodeType == 1)&#123; node.onclick=function(ev)&#123; var event = ev || window.event; //浏览器兼容 event.cancelBubble = true; &#125; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 九、综合案例-锅打灰太狼9.1 准备工作 图片素材 创建web项目 创建游戏主界面网页 index.html 9.2 游戏界面设计index.html1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;锅打灰太狼&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 游戏主界面 --&gt; &lt;div id=&quot;container&quot;&gt; &lt;!-- 记录分数的DIV --&gt; &lt;div id=&quot;fraction&quot;&gt;0&lt;/div&gt; &lt;!-- 时间进度条 --&gt; &lt;div id=&quot;time&quot;&gt;&lt;/div&gt; &lt;!-- 开始按钮 --&gt; &lt;div id=&quot;startMenu&quot;&gt; &lt;input id=&quot;start&quot; type=&quot;button&quot; value=&quot;开始游戏&quot;&gt; &lt;/div&gt; &lt;!-- 结束按钮 --&gt; &lt;div id=&quot;overMenu&quot;&gt; &lt;input id=&quot;over&quot; type=&quot;button&quot; value=&quot;结束游戏&quot;&gt; &lt;/div&gt; &lt;!-- 重新开始 --&gt; &lt;div id=&quot;reloadMenu&quot;&gt; &lt;input id=&quot;reload&quot; type=&quot;button&quot; value=&quot;重新开始&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 引用JS文件 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/wolf.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; style.css1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* 游戏主界面样式 */#container&#123; width: 320px; height: 480px; /* border:1px solid #ff0000; */ margin: auto; background: url(../imgs/game_bg.jpg); border-radius: 5px; position: relative; /* 让父容器中的HTML布局都参考父容器 */&#125;/* 设置记分牌的样式：位置、外观 */#fraction&#123; position: absolute; left: 60px; top: 10px; color: yellow; font-weight: bold; font-size: 18px;&#125;/* 设置时间进度条的样式 */#time&#123; position: absolute; left: 63px; top: 66px; width: 180px; height: 15.5px; background: orangered; border-radius: 8px;&#125;/* 设置按钮div的样式 */#startMenu,#overMenu,#reloadMenu&#123; width: 320px; height: 35px; text-align: center; position: absolute; left: 0px; top: 200px;&#125;#reloadMenu&#123; top: 240px;&#125;/* 设置 结束按钮 和 重新开始 按钮 默认隐藏 */#overMenu,#reloadMenu&#123; display: none;&#125;/* 设置三个按钮的样式 */#start,#over,#reload&#123; width: 100px; height: 35px; border: none; border-radius: 5px; background: orangered; color: white; font-size: 16px;&#125;#start:hover,#over:hover,#reload:hover&#123; background: orange;&#125; 9.3 游戏功能实现wolf.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// 获取页面中需要操作的HTML元素var containerDiv = document.getElementById(&quot;container&quot;);var fractionDiv = document.getElementById(&quot;fraction&quot;);var timeDiv = document.getElementById(&quot;time&quot;);var startMenuDiv = document.getElementById(&quot;startMenu&quot;);var overMenuDiv = document.getElementById(&quot;overMenu&quot;);var reloadMenuDiv = document.getElementById(&quot;reloadMenu&quot;);var startBtn = document.getElementById(&quot;start&quot;);var overBtn = document.getElementById(&quot;over&quot;);var reloadBtn = document.getElementById(&quot;reload&quot;);//1.点击开始按钮，隐藏按钮，并开始计时startBtn.onclick = function()&#123; //a.隐藏开始按钮（就是隐藏开始按钮所在的div） startMenuDiv.style.display = &quot;none&quot;; //b.开始记时（时间进度条逐渐变短 默认宽度 180px,假设游戏时间1min,每秒减少3像素） var timeDivWidth = 180; var px = timeDivWidth/(60); //使用进度条宽度除于游戏时间 （每 0.1s 减少 0.3像素） //每0.1s将时间进度条的宽度减少0.3像素 var timeTask = setInterval(function()&#123; //计算 timeDivWidth = timeDivWidth - px; //将计算后的宽度设置给时间进度条DIV timeDiv.style.width = timeDivWidth+&quot;px&quot;; if(timeDivWidth&lt;=0)&#123; //表示游戏时间结束: 停止计时 clearInterval(timeTask); //停止显示狼的循环任务 clearInterval(showWolfsTask); //显示 游戏结束 和 重新开始 按钮 overMenuDiv.style.display = &quot;block&quot;; reloadMenuDiv.style.display = &quot;block&quot;; &#125; &#125;,100); //c.显示狼群(使用循环任务) wolfsGoGoGo();&#125;//显示图片的洞口的坐标var arrPos = [[&quot;98px&quot;,&quot;115px&quot;],[&quot;17px&quot;,&quot;160px&quot;],[&quot;15px&quot;,&quot;221px&quot;],[&quot;30px&quot;,&quot;294px&quot;],[&quot;122px&quot;,&quot;274px&quot;],[&quot;207px&quot;,&quot;296px&quot;],[&quot;200px&quot;,&quot;212px&quot;],[&quot;187px&quot;,&quot;142px&quot;],[&quot;100px&quot;,&quot;192px&quot;]];//记录游戏分数var score = 0; var showWolfsTask;function wolfsGoGoGo()&#123; showOneWolf(); showWolfsTask = setInterval(&quot;showOneWolf()&quot;,1000);&#125;function showOneWolf()&#123; //1. 创建一个img标签 var img = document.createElement(&quot;img&quot;); //将img标签添加为containerDiv的子标签 containerDiv.appendChild(img); //2. 将img显示到洞口位置(随机显示到某个洞口：列出9个洞口的坐标，随机选择一个) var index = Math.floor( Math.random()*arrPos.length ); // 0-8 img.style.position = &quot;absolute&quot;; img.style.left = arrPos[index][0]; img.style.top = arrPos[index][1]; //3.随机产生一只狼，设置到img标签的src属性 // 算法：产生一个0、1、2随机数,如果能被2整除则显示大灰狼，否则显示小灰灰 var wolfIndex = Math.floor( Math.random()*3 ); var wolfName = wolfIndex%2==0?&quot;h&quot;:&quot;x&quot;; //4.让狼有一个上升的过程 （h0---h5, x0--x5） //显示图片 var i = -1; var task = null; // task表示狼完全显示以后的等待任务 var hideImgTask = null; //hideImgTask表示狼下降的循环任务 var showImgTask = setInterval(function()&#123; i++; img.src = &quot;imgs/&quot;+wolfName+i+&quot;.png&quot;; if(i == 5)&#123; //狼已经完全显示 clearInterval(showImgTask); //隐藏图片 ： 等待一定的时间（500ms），如果没有对狼进行点击，则狼要消失 var task = setTimeout(function()&#123; //狼要消失（就是将图片移出,但是在移出之前需要有狼躲进洞的效果） var hideImgTask = setInterval(function()&#123; i--; img.src = &quot;imgs/&quot;+wolfName+i+&quot;.png&quot;; if(i&lt;=0)&#123; clearInterval(hideImgTask); img.remove(); &#125; &#125;,50); &#125;,500); &#125; &#125;,50); //5.游戏计分：当img被点击，则进行计分 img.onclick = function()&#123; //a.清除任务：点击事件可能发生在狼上升、等待、下降任何一个过程 clearInterval(showImgTask); clearTimeout(task); clearInterval(hideImgTask); //b.显示狼被打击的动画 var j = 5; var hitTask = setInterval(function()&#123; j++; img.src = &quot;imgs/&quot;+wolfName+j+&quot;.png&quot;; if(j&gt;9)&#123; clearInterval(hitTask); img.remove(); &#125; &#125;,50); //c.计分 if(wolfName == &quot;h&quot;)&#123; score = score+10; &#125;else&#123; score = score-10; &#125; fractionDiv.innerHTML = score; &#125; &#125;","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"day05-CSS","slug":"day05-CSS","date":"2022-09-16T15:29:15.000Z","updated":"2022-10-01T03:09:57.911Z","comments":true,"path":"2022/09/16/day05-CSS/","link":"","permalink":"http://example.com/2022/09/16/day05-CSS/","excerpt":"","text":"一、CSS基础 HTML标签决定了网页的内容，CSS能够对HTML标签的显示效果进行设置 1.1 style属性 几乎所有的HTML标签都可以添加一个style属性，在style属性值中设置样式属性，来修改当前HTML标签的显示效果。 标签属性：在HTML标签中添加的键值对 样式属性：HTML标签的style属性值中的键值对 style属性值（样式属性）的语法： 在style属性值中，可以添加多个样式属性，样式属性名与样式属性值之间以:隔开，两个样式属性之间用;隔开 12&lt;input type=&quot;text&quot; style=&quot;width:300px ; height: 35px&quot;/&gt;&lt;img src=&quot;imgs/img01.png&quot; style=&quot;width: 200px; height: 200px; border-radius: 50%&quot;/&gt; 1.2 style标签 问题：style属性可以用来设置HTML的样式，但是如果在一个网页中有多个HTML标签要使用相同的样式，使用style属性设置样式会在每个HTML标签写重复的样式属性，同时如果要修改其效果，则需要修改所有HTML标签的style属性值——代码冗余度高、不便于维护 解决方案：我们可以将多个HTML标签共用的样式属性列表单独定义在style标签中 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* CSS选择器：规定&#123;&#125;中的样式列表对哪些HTML标签有效 */ input&#123;width:270px ; height: 30px&#125; img&#123;width: 200px; height: 200px; border-radius: 50%;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入账号&quot;/&gt; &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot;/&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入真实姓名&quot;/&gt; &lt;img src=&quot;imgs/img01.png&quot; /&gt; &lt;img src=&quot;imgs/img02.png&quot; /&gt; &lt;img src=&quot;imgs/img03.png&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 1.3 CSS层叠样式表 CSS （Cascading Style Sheets） 层叠样式表 样式表：style标签中定义的、可以供网页中HTML标签复用的样式列表 层叠样式表：在style标签中定义的多个样式表可以叠加作用在同一个HTML标签上 CSS基础语法： CSS样式表定义在一对&#123;&#125;中 在&#123;&#125;中可以定义多个样式属性，样式属性名与样式属性值之间使用:分隔，多个样式属性之间使用;分隔 定义样式属性列表的&#123;&#125;前需要定义选择器 123&lt;style type=&quot;text/css&quot;&gt; 选择器&#123;样式属性名1:样式属性值1 ; 样式属性名2:样式属性值2...&#125;&lt;/style&gt; 1.4 CSS选择器 CSS选择器：声明此样式列表对网页中哪些HTML标签有效 ID选择器 1.4.1 ID选择器 语法：#idAttrValue&#123;样式列表&#125; 作用范围：对当前网页中id属性值为idAttrValue的标签有效（通常用于对某一个标签定义样式时使用） 示例： 12345678&lt;style type=&quot;text/css&quot;&gt; /* 1、ID选择器 (样式表对id=img1的标签有效)*/ #img1&#123;width: 200px; height: 200px;&#125;&lt;/style&gt;&lt;img id=&quot;img1&quot; src=&quot;imgs/img01.png&quot; /&gt; &lt;br/&gt;&lt;img id=&quot;img2&quot; src=&quot;imgs/img02.png&quot; /&gt; &lt;br/&gt;&lt;img id=&quot;img3&quot; src=&quot;imgs/img03.png&quot; /&gt; &lt;br/&gt; 1.4.2 标签选择器 语法：tagName&#123;样式列表&#125; 作用范围：对当前网页中所有tagName标签都有效 示例： 123456789&lt;style type=&quot;text/css&quot;&gt; /* 2、标签选择器 (对当前网页中所有的img标签都有效) */ img&#123;border: 5px pink solid;&#125;&lt;/style&gt;&lt;img src=&quot;imgs/img01.png&quot; /&gt; &lt;br/&gt;&lt;img src=&quot;imgs/img02.png&quot; /&gt; &lt;br/&gt;&lt;img src=&quot;imgs/img03.png&quot; /&gt; &lt;br/&gt;&lt;div class=&quot;borderStyle&quot;&gt;This is DIV Tag&lt;/div&gt; 1.4.3 class选择器 语法：.classAttrValue&#123;样式列表&#125; 作用范围：对当前网页中所有的class属性值为classAttrValue 示例： 123456789&lt;style type=&quot;text/css&quot;&gt; /* 3、CLASS选择器 (对当前网页中 class=&quot;borderStyle&quot;的标签有效) */ .borderStyle&#123;border: 5px blue solid; border-radius: 50%;&#125;&lt;/style&gt;&lt;img class=&quot;borderStyle&quot; src=&quot;imgs/img01.png&quot; /&gt; &lt;br/&gt;&lt;img src=&quot;imgs/img02.png&quot; /&gt; &lt;br/&gt;&lt;img class=&quot;borderStyle&quot; src=&quot;imgs/img03.png&quot; /&gt; &lt;br/&gt;&lt;div class=&quot;borderStyle&quot;&gt;This is DIV Tag&lt;/div&gt; 1.5 css文件 在一个HTML文件中如果有多个HTML标签需要使用相同的样式，可以将公用的样式定义在当前网页的style标签中，但是如果多个网页的HTML标签需要使用相同的样式，我们该如何处理呢？ —— 将多个网页需要使用的共同的样式单独定义在一个后缀名为.css的文件中（CSS文件），然后在需要使用css文件中的样式的网页文件中，通过link标签引用此样式文件即可 在项目中创建css目录，在css目录中创建css文件,在css文件中定义公用样式表 12345678/* 样式定义在CSS文件中，无需使用style标签 */.btnStyle&#123; width: 200px; height: 35px; border: none; background-color: pink; border-radius: 5px;&#125; 在需要使用css文件中定义的样式的网页文件，通过link标签引用css样式文件 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Page03&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;button class=&quot;btnStyle&quot;&gt;按钮1-1&lt;/button&gt; &lt;button class=&quot;btnStyle&quot;&gt;按钮1-2&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 在一个网页文件中可以通过link标签引用多个css文件，同时还可添加style标签，定义当前网页的专属样式表 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Page03&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt; &lt;style type=&quot;text/css&quot;&gt; /* css样式表 */ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 二、CSS常用样式设置 CSS可以用于设置HTML标签的显示效果，那么HTML标签可以设置哪些显示效果呢 ？ 2.1 CSS盒子模型 基于HTML标签的嵌套、并列关系，我们可以形象的用盒子的嵌套、并列堆放关系来理解常见的CSS样式审定的模型。 2.2 尺寸样式 属性名 说明 示例 with 设置宽度 width: 200px; height 设置高度 height: 200px; CSS样式中设置尺寸，值需要带上单位 px像素，HTML标签属性值不能带px 如果同时设置图片的宽度和高度，可能会导致比例发生变化，建议设置其中之一，另一个会等比缩放 2.3 边框样式 属性名 说明 示例 border-color 边框颜色：值可以是颜色名（blue）、色号(#00ff00)、rgb(255,0,0)、rgba(255,0,0,0.3) border-color:#ff0000 border-style 边框样式：实线solid、点状虚线（dotted）、段状虚线（dashed）、 双实线(double) border-style:double border-width 边框宽度：单位像素，对于双边框，宽度必须&gt;&#x3D;3px border-width:3px border 同时设置边框颜色、样式、宽度 （三个值空格分隔，顺序不限） border: #0000FF double 3px; border-top 设置上边框border-top-style 单独设置上边框的样式border-top-color 单独设置上边框的颜色border-top-width 单独设置上边框的宽度 border-top:#0000FF double 3px; boder-bottom 设置下边框 border-bottom: #FF0000 SOLID 3px; border-left 设置左边框 … border-right 设置右边框 … 任何一个HTML组件，边框分为上、下、左、右四个边框，我们可以单独设置； 组件的上下左右边框也可以单独设置 样式、颜色及宽度。 2.4 边框圆角及阴影 属性名 说明 示例 border-radius 设置边框圆角：样式属性值可以是具体的像素（10px）,也可以是百分比(20%) border-radius:20pxborder-radius:20% box-shadow 设置阴影，四个参数：阴影颜色、X轴偏移、Y轴偏移、渲染 box-shadow: red 3px 3px 4px border-radius设置边框圆角有一下三种设置值的方式： border-radius:10px 同时设置四个圆角 border-radius:0px 10px 分别设置左上右下 、左下右上圆角 border-radius:0px 10px 20px 30px 分别设置左上、右上、右下、左下四个圆角 区域性显示的元素都可以设置阴影 2.5 背景样式 属性名 说明 示例 background-color 设置背景颜色 background-color: lightgreen; background-image 设置背景图片 background-image: url(imgs&#x2F;img02.png); background 设置背景颜色或者图片 background: lightgreen;background: url(imgs&#x2F;img03.png); background-position 当背景图片过大时设置偏移 background-position: -50px ;background-position: -50px -20px; background-repeat 当背景图片比较小时设置平铺方式 background-repeat: no-repeat; 不平铺 background-repeat: repeat-x; 横向平铺background-repeat: repeat-y; 纵向平铺 background-repeat: repeat; 双向平铺 当我们设置背景颜色的时候，区域的所有范围都是设定的颜色 当我们设置背景图片的时候，图片有可能太大也有可能太小 如果图片大于区域范围我们可以对图片进行偏移设置 如果图片小于区域范围我们可以设置图片的平铺方式 2.6 外边距样式 外边距指的是HTML标签与父容器边框、同级标签的距离 在容器中没有同级标签，外边距指的是当前HTML标签与父容器边框的距离 如果父容器中存在与当前HTML标签的同级标签，外边距指的就是当前HTML标签与同级元素的距离 属性名 说明 示例 margin-left 设置左外边距 margin-left: 100px; margin-top 设置上外边距 margin-top: 100px; margin-right 设置右外边距 margin-right: 100px; margin-bottom 设置下外边距 margin-bottom: 100px; margin 设置外边距，可以设置1个参数、2个参数、4个参数margin:100px; 同时设置四个方向的外边距 margin:50px 100px; 分别设置上下、左右外边距margin:0px 100px 50px 100px 分别设置上、右、下、左外边距 我们可以使用margin-left、margin-top等单独设置某一个方向的外边距，也可以直接使用margin设置多个方向的外边距 2.7 内边距样式 内边距，设置当前容器标签中的元素(文本&#x2F;图片等)距离当前容器边框的距离 可以通过 padding-left、padding-top、padding-right、padding-bottom分别设置容器四边的内边距，也可以通过padding来设置 属性名 说明 示例 padding-left 设置左内边距 padding-left: 100px; padding-top 设置上内边距 padding-top: 100px; padding-right 设置右内边距 padding-right: 100px; padding-bottom 设置下内边距 padding-bootom: 100px; padding padding:50px; 同时设置上下左右四个方向的内边距 padding: 50px 100px;分别设置上下、左右的内边距 padding: 0px 50px 100px 200px; 分别设置上、右、下、左四个方向的内边距 2.8 字体样式 设置网页显示的文本的字体样式 12345678910111213141516171819&lt;style&gt;/* 自定义字体： 1.下载字体文件(ttc、ttf、woff格式) 2.在项目中创建fonts目录，将字体文件粘贴进来 3.根据字体文件自定义字体 */ @font-face&#123; font-family: &#x27;华康娃娃体&#x27;; /* 声明自定义字体名称 */ src: url(fonts/华康娃娃体简W5.ttc); /* 链接到字体文件 */ &#125; /* 字体样式 */ .fontStyle&#123; font-size:30px; /* 设置字体大小 */ font-weight: bold; /* 设置字体加粗 */ color: #0000FF; /* 设置字体颜色 */ font-family: 华康娃娃体 ; /* 设置字体样式，需要当前系统支持的字体、或者使用自定义字体 */ &#125;&lt;/style&gt; 2.9 文本样式12345678&lt;style&gt;/* 文本样式 */ .textStyle&#123; text-align: center; /* 设置当前标签中的文本的水平对齐方式 left|center|right */ text-decoration: none ; /* 设置文本的装饰 none|underline|overline|line-through */ text-shadow: #FF0000 2px 2px 3px; /* 设置文本阴影 */ &#125;&lt;/style&gt; 2.10 列表样式 列表样式主要时针对有序列表、无序列表、自定义列表等标签的样式 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* 列表样式 */ .listStyle1&#123; list-style-type: circle; list-style-position: inside ; &#125; .listStyle2&#123; list-style-type: circle; /* 设置列表图标的样式，none表示不显示图标 */ list-style-position: outside ;/* 设置列表项图标的位置，inside/outside */ list-style-image: url(imgs/list_item.bmp); /* 设置自定义列表项图标 */ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=&quot;listStyle1&quot;&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;梨子&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;listStyle2&quot;&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;梨子&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 2.11 分列显示（瀑布模型） 将一个容器下的多个HTML元素分成多列显示，在容器中分成多列高度会保持基本一致——瀑布模型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;分列显示&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #container&#123; width: 1000px; height: 3000px; border: 1px #0000FF solid; margin: 100px auto; /* 设置DIV容器的外边距，上下100px，左右auto居中 */ column-count: 4; /* 设置容器分列的列数 */ column-rule: blue 1px dashed; /* 设置分列显示之后列与列之间的分割线样式 */ column-width: 230px; /* 设置分列之后的每列宽度（默认： 列宽=容器宽度/列数） */ column-gap: 0px; /* 设置列与列之间的空隙 */ &#125; img&#123; width: 200px; border-radius: 5px; margin-left: 25px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;img src=&quot;imgs/img01.png&quot; style=&quot;border:3px pink solid&quot;/&gt; &lt;img src=&quot;imgs/img02.png&quot; style=&quot;border:3px orange solid&quot;/&gt; &lt;img src=&quot;imgs/img03.png&quot;/&gt; &lt;img src=&quot;imgs/img01.png&quot;/&gt; &lt;img src=&quot;imgs/img02.png&quot;/&gt; &lt;img src=&quot;imgs/img03.png&quot;/&gt; &lt;img src=&quot;imgs/img01.png&quot;/&gt; &lt;img src=&quot;imgs/img02.png&quot;/&gt; &lt;img src=&quot;imgs/img03.png&quot;/&gt; &lt;img src=&quot;imgs/img01.png&quot;/&gt; &lt;img src=&quot;imgs/img02.png&quot;/&gt; &lt;img src=&quot;imgs/img03.png&quot;/&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2.12 超链接（伪类） 超链接伪类，用于设置超链接在不同状态时的样式 a:link 超链接初始状态(未激活) a:hover 设置鼠标悬停的样式 a:active 设置超链接鼠标点击下去时的样式 a:visited 设置激活后的超链接的样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /*超链接默认样式: 未激活的超链接是蓝色的， 超链接鼠标点击下去是红色， 激活后的超链接是紫色的 如何修改超链接不同状态下的样式呢 ？——使用超链接伪类 */ a&#123; text-decoration: none; /*color: gray;如果使用color设置超链颜色，则未激活、鼠标点下去、激活后颜色都是同一个颜色 */ &#125; /* a:link 超链接初始状态(未激活) */ a:link&#123; color: darkcyan; &#125; /* a:hover 设置鼠标悬停的样式 */ a:hover&#123; color:blue &#125; /* a:active 设置超链接鼠标点击下去时的样式*/ a:active&#123; color: orange; &#125; /* a:visited 设置激活后的超链接的样式 */ a:visited&#123; color:gray &#125; .btnStyle&#123; border: #008B8B 1px solid; border-radius: 3px; width: 180px; height: 30px; color: #008B8B; &#125; .btnStyle:hover&#123; background: #008B8B; color: white; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;http://www.qfedu.com&quot;&gt;千锋教育&lt;/a&gt; &lt;button class=&quot;btnStyle&quot;&gt;测试按钮&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 2.13 CSS布局 div层是一个HTML标签的容器，我们可以将HTML标签放到div容器中，通过CSS改变DIV的排列方式，即可以实现对HTML元素的布局，DIV+CSS布局： 绝对布局 相对布局 浮动布局 2.13.1 绝对布局使用position:absolute设置绝对布局 1、如果div标签直接写在body中，div的绝对布局位置是参考浏览器边框2、如果div写在父容器中，且父容器div没有设置position，则父容器里面的div的绝对布局不是参考父容器，而是参考浏览器边框3、如果div写在父容器中，其父容器div设置了position&#x3D;absolute|relative|fixed, 父容器里面的div的绝对布局就是参考父容器边框 使用position:fiexd设置绝对布局 任何时候，div的绝对布局都是参考浏览器边框 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* body标签在浏览器中默认是有边距，为了让body的元素可以紧挨着浏览器边缘， 我们通常对body进行padding和margin设置为0px，以消除边距 */ body&#123; padding: 0px; margin: 0px; &#125; img&#123; /* height: 200px; */ width: 200px; margin: 0px; &#125; /* div块级元素，高度默认和div中内容一样高；宽度默认和父容器一样宽 */ div&#123; border:1px solid green; width: 200px; padding: 0px; &#125; /* div+css布局：绝对布局 */ #div1&#123; position: fixed; /* 设置div的布局方式 absolute 绝对布局*/ left: 300px; top: 200px; &#125; #div2&#123; position: absolute; left: 450px; top: 400px; &#125; #div3&#123; position: absolute; left: 275px; top: 375px; &#125; #container&#123; width: 1000px; height: 800px; background: yellow; margin: 100px; position: fixed; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt;&lt;!-- 使用 position: absolute 设置div绝对布局：1、如果div标签直接写在body中，设置position: absolute; div的位置是参考浏览器边框2、如果父容器div没有设置position，则父容器里面的div的绝对布局不是参考父容器，而是参考浏览器边框3、如果父容器div设置了position=absolute|relative|fixed, 父容器里面的div的绝对布局就是参考父容器边框--&gt; &lt;!-- 我们也可以使用 position: fiexd 设置div绝对布局： 任何时候div的位置都是参考浏览器--&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;img src=&quot;imgs/img01.png&quot; /&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;img src=&quot;imgs/img02.png&quot; /&gt; &lt;/div&gt; &lt;div id=&quot;div3&quot;&gt; &lt;img src=&quot;imgs/img03.png&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2.13.2 相对布局 相对布局，就是设置HTML标签（div）相对于自己原来的位置的偏移量 div的 position样式属性值为relative,通过设置left、top、right、bottom来设置div的位置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* body标签在浏览器中默认是有边距，为了让body的元素可以紧挨着浏览器边缘， 我们通常对body进行padding和margin设置为0px，以消除边距 */ body&#123; padding: 0px; margin: 0px; &#125; img&#123; /* height: 200px; */ width: 200px; margin: 0px; &#125; /* div块级元素，高度默认和div中内容一样高；宽度默认和父容器一样宽 */ div&#123; border:1px solid green; width: 200px; padding: 0px; &#125; /* 相对布局：div有默认的位置 ，相对布局就是参考默认位置的偏移量 */ #div2&#123; position: relative; left: 300px; top: 200px; &#125; #div3&#123; position: relative; left: 150px; &#125; #container&#123; width: 1000px; height: 800px; background: yellow; margin: 100px; position: relative; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;img src=&quot;imgs/img01.png&quot; /&gt; &lt;/div&gt; &lt;div id=&quot;div2&quot;&gt; &lt;img src=&quot;imgs/img02.png&quot; /&gt; &lt;/div&gt; &lt;div id=&quot;div3&quot;&gt; &lt;img src=&quot;imgs/img03.png&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2.13.3 浮动布局 float样式属性，设置当前div在容器中浮动起来，浮动方式有两种（left|right） clear样式属性，可以终止浮动布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #container&#123; width: 1200px; height: 800px; border: 1px solid orange; margin: 0px auto; &#125; /* CSS复合选择器：id=container里面的div标签 */ #container div&#123;&#125; #div1&#123; width: 200px; height:250px; background: red; float: left; /* 浮动 */ &#125; #div2&#123; width: 500px; height: 200px; background: green; float: left; &#125; #div3&#123; width: 400px; height: 200px; background: blue; float: left; &#125; #div4&#123; width: 200px; height: 200px; background: purple; float: left; &#125; #div5&#123; width: 1200px; height: 100px; background: lightgray; clear: both; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt; &lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt; &lt;div id=&quot;div4&quot;&gt;div4&lt;/div&gt; &lt;div id=&quot;div5&quot;&gt;div5&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2.14 2D&amp;3D CSS3中提供一些关于HTML标签视图的2D(平面)及3D(立体)的视图转换 1.偏移 2.旋转 3.缩放 4.拉伸 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; border:1px blue solid; background: lemonchiffon; width: 300px; height: 200px; /* display: inline; 将块级元素转换成内联元素 */ &#125; /* transform样式属性用于对HTML标签进行2D和3D转换 样式属性值为函数，不同的函数实现不同的转换： 1、translate 偏移 transform: translate(200px,100px); 同时设置横向和纵向偏移 transform: translateX(250px); 设置横向偏移 transform: translateY(250px); 设置纵向偏移 */ #div1&#123; transform: translate(350px,100px); /* 相对布局 */ &#125; /* 2、rotate 旋转 函数参数为角度，单位deg transform: rotateZ(45deg); transform: rotate(45deg); 沿着Z轴（垂直于屏幕）旋转 transform: rotateX(45deg); 沿着X轴（垂直于屏幕）旋转 transform: rotateY(45deg); 沿着Y轴（垂直于屏幕）旋转 */ #div2&#123; transform: rotateY(45deg); &#125; /* 3、scale 缩放 transform: scale(0.5); 同时将原DIV宽度和高度变为原来的0.5倍 transform: scale(0.5,2); 设置宽度为原来0.5倍，高度为原来2倍 transform: scaleX(2); 单独设置宽度的缩放 transform: scaleY(2); 单独设置高度的缩放 */ #div3&#123; transform: scaleY(0.5); &#125; /* 4、skew拉伸 参数也是角度 transform: skewX(30deg); 沿着X轴拉伸 30deg transform: skewY(30deg); 沿着Y轴拉伸 30deg transform: skew(30deg,30deg); 沿着X和Y轴拉伸 30deg */ #div4&#123; transform: skew(30deg,30deg); 沿着X和Y轴拉伸 30deg &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt; &lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt; &lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt; &lt;div id=&quot;div4&quot;&gt;div4&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2.15 自定义动画 可以借助于CSS实现HTML元素的动画 2.15.1 过渡1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; img&#123; width: 200px; height: 200px; border-radius: 50%; transform: rotate(0deg); /* transition 样式过渡： 参数1：过渡的样式名（样式属性名） 参数2：过渡时间 参数3：过渡效果 ease(慢-快-慢) ease-in(慢-快) ease-out(快-慢) linear(匀速) 参数4：延迟时间 */ transition: transform 5s linear -2s; &#125; img:hover&#123; transform: rotate(360deg); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;imgs/img01.png&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 2.15.2 动画 动画，就是由一帧一帧的画面连续的播放形成的 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; /* 定义动画 */ @keyframes xuanZhuan&#123; /* 元素的原始状态 from 0% */ 0%&#123; transform: rotate(0deg); &#125; 50%&#123; transform: rotate(180deg); &#125; /* 元素的目标状态 to 100%*/ 25%,100%&#123; transform: rotate(360deg); &#125; &#125; #img2&#123; width: 200px; height: 200px; border-radius: 50%; /* animation 应用动画: 参数1：动画名称 参数2：完成动画的时间 参数3：动画的过渡效果 参数4：动画的循环次数（整数,infinite表示无限循环） */ animation: xuanZhuan 10s linear infinite; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=&quot;img2&quot; src=&quot;imgs/img02.png&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 三、用户界面设计 如果同一个网页用户通过不同的设备（手机、平板、PC等）打开网页，我们如何保证页面显示的完整性及美观呢？ 3.1 媒体查询 使用CSS设置网页根据不同的显示设备，动态的显示不同的CSS样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123;padding: 0px;margin: 0px;&#125; /* 当屏幕最小尺寸为1800像素时，显示如下样式 */ @media screen and (min-width:1800px) &#123; div&#123; width: 1800px; height: 800px; background: lightcyan; border: 1px solid #008B8B; margin: 20px auto; &#125; &#125; /* 当屏幕大于1200像素且小于1800像素时，显示如下样式 */ @media only screen and (min-width:1200px) and (max-width:1800px) &#123; div&#123; width: 1200px; height: 800px; background: lemonchiffon; border: 1px solid #008B8B; margin: 20px auto; &#125; &#125; /* 当屏幕大于600像素且小于1200像素时，显示如下样式 */ @media only screen and (min-width:600px) and (max-width:1200px) &#123; div&#123; width: 600px; height: 800px; background: deepskyblue; border: 1px solid #008B8B; margin: 20px auto; &#125; &#125; /* 当屏幕小于等于600像素时，显示如下样式 */ @media only screen and (max-width:600px)&#123; div&#123; width: 600px; height: 800px; background: deeppink; border: 1px solid #008B8B; margin: 20px auto; &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3.2 响应式布局 不设置每行显示几个图片，每行显示的图片个数可以随着父容器的宽度而动态变化 3.2.1 浮动布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123;padding: 0px;margin: 0px;&#125; /* 当屏幕最小尺寸为1800像素时，显示如下样式 */ @media screen and (min-width:1800px) &#123; #div1&#123; width: 1540px; height: 800px; background: lightcyan; border: 1px solid #008B8B; margin: 20px auto; &#125; &#125; /* 当屏幕大于1200像素且小于1800像素时，显示如下样式 */ @media only screen and (min-width:1200px) and (max-width:1800px) &#123; #div1&#123; width: 1100px; height: 800px; background: lemonchiffon; border: 1px solid #008B8B; margin: 20px auto; &#125; &#125; /* 当屏幕大于600像素且小于1200像素时，显示如下样式 */ @media only screen and (min-width:600px) and (max-width:1200px) &#123; #div1&#123; width: 440px; height: 800px; background: deepskyblue; border: 1px solid #008B8B; margin: 20px auto; &#125; &#125; /* 当屏幕小于等于600像素时，显示如下样式 */ @media only screen and (max-width:600px)&#123; #div1&#123; width: 220px; height: 800px; background: deeppink; border: 1px solid #008B8B; margin: 20px auto; &#125; &#125; #div1 div&#123; width: 210px; height: 280px; background: whitesmoke; margin: 5px; box-shadow: gray 2px 2px 3px; float: left; &#125; img&#123; width: 200px; margin: 5px; border-radius: 5px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot;&gt; &lt;div&gt;&lt;img src=&quot;imgs/img01.png&quot;/&gt;&lt;br/&gt;图片1&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img02.png&quot;/&gt;&lt;br/&gt;图片2&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img03.png&quot;/&gt;&lt;br/&gt;图片3&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img01.png&quot;/&gt;&lt;br/&gt;图片1&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img02.png&quot;/&gt;&lt;br/&gt;图片2&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img03.png&quot;/&gt;&lt;br/&gt;图片3&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img01.png&quot;/&gt;&lt;br/&gt;图片1&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img02.png&quot;/&gt;&lt;br/&gt;图片2&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img03.png&quot;/&gt;&lt;br/&gt;图片3&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img01.png&quot;/&gt;&lt;br/&gt;图片1&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img02.png&quot;/&gt;&lt;br/&gt;图片2&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img03.png&quot;/&gt;&lt;br/&gt;图片3&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img01.png&quot;/&gt;&lt;br/&gt;图片1&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img02.png&quot;/&gt;&lt;br/&gt;图片2&lt;/div&gt; &lt;div&gt;&lt;img src=&quot;imgs/img03.png&quot;/&gt;&lt;br/&gt;图片3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 3.2.2 弹性盒 父容器中的子标签不设置宽度&#x2F;高度的具体值，只设置在父容器占据的宽度&#x2F;高度的比例，当父容器宽度发生变化时，子标签宽度对对应发生变化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123;padding: 0px;margin: 0px;&#125; .row&#123; width: 1200px; height: 300px; background: lightcyan; border: 1px solid #008B8B; margin: 20px auto; display: flex; /* 将父容器的div设置为弹性盒,此容器相当于一个行，容器中的每个标签相当于行中的列 */ flex-direction: row; /* 设置弹性盒主轴方向row（左-右） row-reverse(右-左) column(上-下) column-reverse(下-上) */ &#125; .row div&#123; height: 280px; background: whitesmoke; margin: 5px; box-shadow: gray 2px 2px 3px; &#125; img&#123; width: 100%; border-radius: 5px; &#125; /* flex样式属性，用于设置 弹性盒 中的标签所占的位置的比例*/ #d1&#123;flex: 1;&#125; #d2&#123;flex: 2;&#125; #d3&#123;flex: 2;&#125; #d4&#123;flex: 2;&#125; #d5&#123;flex: 2;&#125; #d6&#123;flex: 1;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;row&quot;&gt; &lt;div id=&quot;d1&quot;&gt;&lt;img src=&quot;imgs/img01.png&quot;/&gt;&lt;br/&gt;图片1&lt;/div&gt; &lt;div id=&quot;d2&quot;&gt;&lt;img src=&quot;imgs/img02.png&quot;/&gt;&lt;br/&gt;图片2&lt;/div&gt; &lt;div id=&quot;d3&quot;&gt;&lt;img src=&quot;imgs/img03.png&quot;/&gt;&lt;br/&gt;图片3&lt;/div&gt; &lt;div id=&quot;d4&quot;&gt;&lt;img src=&quot;imgs/img01.png&quot;/&gt;&lt;br/&gt;图片1&lt;/div&gt; &lt;div id=&quot;d5&quot;&gt;&lt;img src=&quot;imgs/img02.png&quot;/&gt;&lt;br/&gt;图片2&lt;/div&gt; &lt;div id=&quot;d6&quot;&gt;&lt;img src=&quot;imgs/img03.png&quot;/&gt;&lt;br/&gt;图片3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 四、CSS案例 华为商城登录页面的CSS优化 4.1 style.css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* 消除边距 */*&#123; margin: 0px; padding: 0px;&#125;/* 标题样式 */.titleTextStyle&#123; /* 字体 */ font-family: 黑体; font-size: 18px; font-weight: bold; transform: translateY(-20px); display: inline;&#125;#logo&#123; transform: translateY(10px);&#125;/* 帐号密码输入框 */.inputStyle&#123; width: 320px; height: 30px; background: #eeeeee; border-radius: 4px; border:none; padding: 10px 20px;&#125;/* 超链接样式 */a&#123; text-decoration: none;&#125;/* 登录按钮样式 */.btnStyle&#123; width: 360px; height: 50px; border-radius: 5px; border:none; background: lightcoral; color: white; font-weight: bold; font-size: 20px;&#125;/* 设置登录按钮下三个超链接样式 */.linkStyle&#123; margin-left: 30px; padding: 15px;&#125; 4.2 hw_login.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;华为商城欢迎您&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;100%&quot; height=&quot;970&quot;&gt; &lt;tr height=&quot;50&quot; bgcolor=&quot;#eeeeee&quot;&gt; &lt;td width=&quot;355&quot;&lt;/td&gt; &lt;td&gt; &lt;img src=&quot;imgs/logo.jpg&quot; height=&quot;30&quot; id=&quot;logo&quot;/&gt; &lt;div class=&quot;titleTextStyle&quot;&gt;|&amp;nbsp;千锋商城&lt;/div&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td width=&quot;355&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;150&quot;&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot; valign=&quot;bottom&quot;&gt; &lt;label style=&quot;font-size: 30px;&quot;&gt;华为帐号登录&lt;/label&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;30%&quot;&gt; &lt;img src=&quot;imgs/qrcode.png&quot; width=&quot;200&quot; height=&quot;200&quot; /&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;label style=&quot;font-size: 10px; color: lightgray;&quot;&gt;若您使用华为手机，请进入“设置”&gt;“华为帐号”扫码登录。&lt;/label&gt; &lt;/td&gt; &lt;td width=&quot;30%&quot;&gt; &lt;table height=&quot;420&quot; width=&quot;360&quot;&gt; &lt;tr&gt; &lt;td &gt; &lt;input type=&quot;text&quot; class=&quot;inputStyle&quot; placeholder=&quot;手机号/邮箱地址/账号名&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td &gt; &lt;input type=&quot;password&quot; class=&quot;inputStyle&quot; placeholder=&quot;密码&quot;/&gt; &lt;div style=&quot;margin-top: 20px;&quot;&gt; &lt;a href=&quot;#&quot;&gt;短信验证码登录&lt;/a&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; class=&quot;btnStyle&quot; value=&quot;登录&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;80&quot;&gt; &lt;td align=&quot;center&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;linkStyle&quot;&gt;注册&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;linkStyle&quot;&gt;忘记密码&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;linkStyle&quot;&gt;遇到问题&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt; &lt;img src=&quot;imgs/qq.png&quot; /&gt; &lt;img src=&quot;imgs/zfb.png&quot; /&gt; &lt;img src=&quot;imgs/wx.png&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;150&quot;&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;100&quot; bgcolor=&quot;#eeeeee&quot;&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot; valign=&quot;middle&quot;&gt; &lt;a href=&quot;#&quot;&gt;华为帐号用户协议&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;关于华为帐号与隐私的声明&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;常见问题&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;Cookies&lt;/a&gt; &lt;br/&gt; 华为帐号 版权所有 © 2011-2021 &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"day01-JavaWebGuide","slug":"day01-JavaWebGuide","date":"2022-09-16T15:28:00.000Z","updated":"2022-10-05T06:35:48.777Z","comments":true,"path":"2022/09/16/day01-JavaWebGuide/","link":"","permalink":"http://example.com/2022/09/16/day01-JavaWebGuide/","excerpt":"","text":"一、Java web是什么？1.1 Java web概念 Java web指的是使用Java语言进行web互联网领域项目开发的技术栈——进行web项目开发所需的技术的集合： web前端——在浏览器中用户可以看到的网页 web后端——为前端提供数据的程序 1.2 Web项目 Java语言是可以进行多种类型的项目的开发 Java ME 嵌入式应用程序 （功能手机系统内置应用——俄罗斯方块、贪吃蛇） Java SE 窗体应用程序（下载—安装—双击打开） Android SDK 移动应用开发 HarmonyOS SDK 移动应用开发 Java EE 企业级项目开发（web项目） web项目 - 使用浏览器访问的软件系统 二、Java web学什么？2.1 web项目的结构 2.2 Java web技术体系 1.Java语言基础 Java基本语法：标识符、关键字、运算符、表达式、流程控制、数据类型 Java OOP： 类、属性、方法、对象，抽象继承封装多态 封装类：日期、Math、String、封装类 集合：List、Set、Iterator、Map JavaSE高级：IO、线程、网络 2.数据库 MySQL MySQL下载、安装、配置 SQL 结构化查询语言 添加、查询、修改、 删除 高级使用：存储过程、索引 数据库设计&#x2F;建模 数据库设计案例 3.数据库编程 JDBC 数据库编程介绍 JDBC步骤及实现 JDBCUtil工具类封装 DAO与DTO 4.web前端 网页设计 HTML 超文本标记语言 CSS 层叠样式表 JavaScript 脚本语言 AJAX 异步交互 BootStrap 样式框架 jQuery JS框架 5.Servlet&#x2F;JSP ​ 一种可以将网页数据提交到Java程序，并且将Java程序的数据显示到网页的技术 Tomcat、HTTP Servlet、JSP","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"JavaWebGuide","slug":"JavaWebGuide","permalink":"http://example.com/tags/JavaWebGuide/"}]},{"title":"day04-HTML","slug":"day04-HTML","date":"2022-09-13T16:50:10.000Z","updated":"2022-10-01T03:08:49.435Z","comments":true,"path":"2022/09/14/day04-HTML/","link":"","permalink":"http://example.com/2022/09/14/day04-HTML/","excerpt":"","text":"一、C&#x2F;S架构与B&#x2F;S架构 对于一个软件系统，用户是通过用户界面来完成与软件系统的交互的（用户是通过用户界面来使用软件系统的），根据软件不同的架构模式，软件系统界面设计的实现技术是不同的： C&#x2F;S架构 B&#x2F;S架构 1.1 C&#x2F;S架构 C&#x2F;S Client-Server 基于客户端和服务器的架构模式 1.2 B&#x2F;S架构 B&#x2F;S Browser-Server 基于浏览器和服务器的架构模式 1.3 不同架构的前端技术栈1.3.1 C&#x2F;S Java语言可以进行C&#x2F;S架构开发，JDK提供的AWT（abstract window toolkit）可以进行窗体开发 awt swing 1.3.2 B&#x2F;S Java语言主要应用于web系统的开发，web系统就是基于B&#x2F;S架构，其系统界面都是通过网页实现的 HTML 超文本标记语言 网页的结构 CSS 层叠样式表 网页的样式 JavaScript 网页脚本语言 网页的行为 1.3.3 移动应用 Java语言还可以用于进行Android和HarmonyOS应用开发 AndroidUI xml及组件 HarmonyOSUI xml及组件 二、HTML简介2.1 什么是网页？ 网页 —— 可以在网络中传输、通过浏览器解析并显示视图的页面 问题：一个文件通过网络传递给浏览器之后，浏览器是如何显示视图的呢？ 存储在服务器上的页面文件中编写的是浏览器可以识别的代码 当浏览器请求服务器时，服务器将这个写有浏览器可以识别的代码的页面文件通过网络传递给浏览器 浏览器接收到文件后，不会将代码显示出来，而是对代码进行解析，显示出对应的视图 网页设计：就是在网页文件中编写HTML代码(标签)，通过浏览器可以显示特定的用户界面 2.2 HTML是什么？ HTML （Hyper Text Markup Language）超文本标记语言。以特定的标签在浏览器中呈现不同的视图 标记（标签）：就是由&lt;&gt;和特定的单词组成的符号，可以被浏览器识别并显示对应的视图 超文本：使用文本标签显示图片、视频、声音等非文本数据 2.3 HTML书写规范 HTML标签需要写在一个网页文件中，网页文件的规则： 网页文件是一个后缀名为.html或者.htm的文件 网页文件有一个基本结构： 在网页文件第一行通过&lt;!DOCTYPE html&gt;声明当前文档遵循的HTML规范 在HTML规范声明之后，必须有一对根标签&lt;html&gt;&lt;/html&gt;（根标签：当前网页中其他的标签都在根标签的里面） 在根标签中，有两对子标签&lt;head&gt;&lt;/head&gt;和&lt;body&gt;&lt;/body&gt; head标签：用于定义当前网页文档的标题、字符集等属性信息 body标签：用于定义当前网页显示的主体内容 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;title&gt;我的第一个网页&lt;/title&gt; &lt;/head&gt; &lt;body bgcolor=&quot;red&quot;&gt; &lt;input type=&quot;password&quot;/&gt; &lt;/body&gt;&lt;/html&gt; 标签： 双标签（围堵标签） 单标签 标签属性：在双标签前一个标签中、单标签的标签名后可以添加键值对，用于设置当前标签的特性 HTML标签是不区分大小写的，为了便于可读，建议统一写成小写 HTML版本规范 前端规范— w3c HTML4 &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; XHTML 提出了基于HTML4更多的语法规则，让HTML编写规范更严谨 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot; http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; HTML5 &lt;!DOCTYPE html&gt; 2.4 前端开发工具 为了便于前端开发，有很多的前端开发工具，可以为我们进行网页设计提供代码自动补全、代码错误提示、项目文件管理等功能，常见的工具： webStorm vsCode subline HBuilder –HBuilderX HBuilderX的使用 下载：www.dcloud.io 解压：解压到存放软件的目录（免安装） 运行： 首次运行，需要对HBuilderX进行用户使用习惯设置（主题） 第一次关闭HBuilderX的时候，会提示创建桌面快捷方式 创建web项目 创建网页文件：选择项目—右键—新建—HTML文件 创建的HTML文件默认会给出规范的网页文件结构 运行网页文件： 三、HTML常用标签 网页就是使用HTML标签构成的文档，在浏览器显示视图页面。HTML什么样的标签表示什么样的是呢？ 网页界面：显示数据、输入数据 为用户提供一个界面，显示用户想要看到的数据（文本、图片、声音、视频） 为用户提供一个界面，可以输入数据（发表博客：输入文本、选择图片、点击按钮） 如何使用HTML标签在网页中显示数据和提供输入视图呢？ 根据HTML标签的作用，我们将HTML标签分为以下： 显示标签：就是将图片、文本、声音、视频通过网页呈现给用户 表单标签：就是给用户提供输入框、按钮、单选按钮、复选框、文本域等视图供其输入数据 布局标签：对网页中的内容进行布局&#x2F;排版 功能标签：能够提供特定用户功能的标签 框架标签：搭建页面框架（输入布局标签） 3.1 显示标签 将文本、图片、声音和视频显示到网页 3.1.1 文本12345678&lt;!--显示文本--&gt;&lt;!-- font标签：color属性设置颜色，fase属性设置字体，size属性设置大小 --&gt;&lt;font color=&quot;red&quot; face=&quot;华文行楷&quot; size=&quot;7&quot;&gt;千锋教育&lt;/font&gt;&lt;font color=&quot;blue&quot; face=&quot;微软雅黑&quot; size=&quot;4&quot;&gt;Java涛哥&lt;/font&gt;&lt;!-- H5不推荐使用font标签，显示文本推荐使用label标签 --&gt;&lt;!-- label标签没有字体属性，但是可以通过style属性值设置字体颜色、大小、样式 --&gt;&lt;label style=&quot;color:green;font-size:100px;font-family:楷体&quot;&gt;网页设计&lt;/label&gt; 3.1.2 图片123456789&lt;!-- 显示图片 --- img标签： src属性用于指定显示的图片的路径，可以是网络图片路径，也可以本地图片路径 (本地图片：先在项目中创建一个存放图片的目录imgs，再将要显示的图片拷贝进来 ) width、hegiht属性,设置图片的宽度、高度 ,如果两个属性同时设置可能会改变图片的比例 可以只设置其中一个属性，另一个属性会等比缩放 alt属性，用于指定图片无法加载时的替换文本--&gt;&lt;img src=&quot;http://www.qfedu.com/images/new_logo.png&quot;/&gt;&lt;img src=&quot;imgs/logo.jpg&quot; height=&quot;200&quot; alt=&quot;千锋LOGO&quot;/&gt; 3.1.3 声音和视频1234567891011121314&lt;!--audio标签 调用浏览器内置的音频播放器（默认是隐藏的） src属性指定音频的路径（网络路径、本地路径） controls属性表示显示播放器（此属性不需要属性值） autoplay属性表示音乐自动播放（考虑浏览器兼容性）--&gt;&lt;audio src=&quot;meida/麻雀.mp3&quot; controls autoplay&gt;&lt;/audio&gt;&lt;!--video标签 调用浏览器内置的视频播放器（默认是隐藏的） src属性指定视频的路径（网络路径、本地路径） controls属性表示显示播放器的控制条（此属性不需要属性值） autoplay属性表示视频自动播放（考虑浏览器兼容性） width、height属性设置视频播放器的尺寸--&gt;&lt;video src=&quot;meida/Java学科宣传片.mp4&quot; controls autoplay width=&quot;400&quot;&gt;&lt;/video&gt; 3.2 表单标签 用户提供输入视图供其输入数据： 3.2.1 input标签 input标签可以用来显示多种表单输入视图效果，input标签有一个type属性，不同的属性表示不同的视图 123456789101112131415161718192021- 文本输入框：&lt;input type=&quot;text&quot;/&gt;&lt;br/&gt;- 密码输入框：&lt;input type=&quot;password&quot;/&gt;&lt;br/&gt;- 单选按钮：&lt;input type=&quot;radio&quot;/&gt;&lt;br/&gt;- 复选框：&lt;input type=&quot;checkbox&quot;/&gt;&lt;br/&gt;- 文件选择框：&lt;input type=&quot;file&quot;/&gt;&lt;br/&gt;&lt;!-- 普通按钮默认是没有文本的，通过value属性指定按钮文本 --&gt;-普通按钮：&lt;input type=&quot;button&quot; value=&quot;点我呀！&quot;/&gt;&lt;br/&gt;-重置按钮：&lt;input type=&quot;reset&quot;/&gt;&lt;br/&gt;-提交按钮：&lt;input type=&quot;submit&quot;/&gt;&lt;br/&gt;&lt;!-- 图片按钮从功能讲和提交按钮一致，需要通过src属性指定按钮图片 --&gt;-图片按钮：&lt;input type=&quot;image&quot; src=&quot;imgs/btn.bmp&quot;/&gt;&lt;br/&gt;&lt;!-- 以下input的type是HTML5新增的 ,要考虑浏览器的兼容性（浏览器是否支持）--&gt;&lt;!-- type=number ，表示次输入框只能输入数字，min设置最小值，max设置最大值--&gt;- 数字输入框：&lt;input type=&quot;number&quot; min=&quot;10&quot; max=&quot;20&quot;/&gt;&lt;br/&gt;- 日期输入框：&lt;input type=&quot;date&quot;/&gt;&lt;br/&gt;- 颜色选择框：&lt;input type=&quot;color&quot;/&gt;&lt;br/&gt;- 邮箱输入框：&lt;input type=&quot;email&quot;/&gt;&lt;br/&gt;- 电话输入框：&lt;input type=&quot;tel&quot;/&gt;&lt;br/&gt;- 搜索输入框：&lt;input type=&quot;search&quot;/&gt;&lt;br/&gt; 单选按钮和复选框： 123456789101112131415&lt;hr/&gt;&lt;!-- 单选按钮使用注意事项：1.如果多个单选按钮是同一个主题的选项，则需要提供name属性，且那么属性值必须相同（排他性）2.单选按钮必须提供value属性，value属性值会在当前单选按钮被选中时提交3.单选按钮可以通过添加checked属性使其默认被选中，如果有多个单选按钮添加checked属性，则选中最后一个--&gt;性别：&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;M&quot; checked/&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;F&quot;/&gt;女&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;N&quot; /&gt;不详&lt;hr/&gt;&lt;!-- 复选框注意事项（与单选按钮一致） --&gt;爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;篮球&quot; checked/&gt;篮球&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;足球&quot;/&gt;足球&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;羽毛球&quot; checked/&gt;羽毛球&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;溜溜球&quot;/&gt;溜溜球 3.2.2 select标签 下拉菜单（省、市、区选择） 12345678910111213141516&lt;!-- select标签表示下拉菜单的容器1.添加multiple属性，设置此下拉菜单多选（ctrl）2.size属性，设置下拉列表中可见选项的数量option子标签表示下拉菜单的选项1.option标签中的标签文本用于指定选项显示的文字2.option标签需要提供value属性，当选择此菜单式提交到后台--&gt;&lt;select multiple size=&quot;3&quot;&gt; &lt;option value=&quot;BeiJing&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;ShangHai&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;GuangZhou&quot;&gt;广州&lt;/option&gt; &lt;option value=&quot;ShenZhen&quot;&gt;深圳&lt;/option&gt; &lt;option value=&quot;WuHan&quot;&gt;武汉&lt;/option&gt;&lt;/select&gt; 3.2.3 textarea标签 文本域、多行文本框 123456&lt;!-- 多行输入框 textarea标签：1、rows属性用于指定多行文本框显示的行数2、cols属性用于设置多行文本输入框每行显示的字符个数（考虑浏览器兼容性）3、输入框（文本输入框、密码输入框）是通过value属性来设置默认值的，textarea通过标签文本设置默认值--&gt;&lt;textarea rows=&quot;5&quot; cols=&quot;30&quot;&gt;这是文本域的默认值&lt;/textarea&gt; 3.2.4 表单标签共有属性 对于表单标签，他们有一些共有属性 id属性，不仅是表单标签共有的属性，几乎所有的HTML标签都可以有这个属性，它表示此标签在当前网页文件中的唯一表示，便于我们定位标签进行操作；在一个网页中标签的ID属性值要保持唯一性。 name属性，用于将数据提交（同步提交）到后端时，在后端接收数据。 required属性，设置此输入框必须输入数据，否则不能提交。 1234&lt;form&gt; &lt;input type=&quot;text&quot; required=&quot;required&quot;/&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; placeholder属性，用于设置输入框空值提示信息。 readonly属性，表示设置此输入框，只能显示数据，不能点击输入。 disabled属性，设置输入组件禁用（输入框不能输入、按钮不能点击、下拉菜单不能选择）。 value属性，表示当前输入框的值、下拉菜单选中的选项的值。 3.2.5 form标签 form标签，在页面中没有显示效果，它用于将用户在输入视图中输入的数据提交到后台 123456789101112131415161718&lt;!-- form标签：用于提交数据的表单 作用：当点击form标签中的提交按钮时，可以将form标签中输入视图中的数据提交到action属性指定的url注意：1.提交form表单的按钮必须是提交按钮（type=submit，type=image） 2.form表单中的输入标签需要提供name属性，否则输入标签中的值不会被提交 3.form标签的method属性，指定表单提交数据的方式（get显式提交 post隐藏提交；其他区别暂不关注） method属性默认值是get，也就是说如果不写method属性，则get方式提交 4.enctype属性，用于设置表单提交时数据的编码方式重置按钮： 必须在form表单中使用，用于重置表单中输入框的值（让输入框的值回到默认状态 ≠ 清空）提交按钮： 必须用在form表单中，用于提交表单 --&gt;&lt;form action=&quot;https://www.baidu.com&quot; method=&quot;post&quot; enctype=&quot;&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入帐号&quot; name=&quot;userName&quot; value=&quot;123&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; name=&quot;userPwd&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;reset&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;&lt;/form&gt; 在HTML5规范中，提交按钮也可以写在form外面,但是要通过form属性指定表单id 12345678&lt;form id=&quot;form1&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入帐号&quot; name=&quot;userName&quot; value=&quot;123&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; name=&quot;userPwd&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;reset&quot; /&gt;&lt;br/&gt;&lt;/form&gt;&lt;!--对于同一个form，可以使用不同的提交按钮，提交到不同的URL--&gt;&lt;input type=&quot;submit&quot; value=&quot;登录1&quot; form=&quot;form1&quot; formaction=&quot;https://www.baidu.com&quot; formmethod=&quot;get&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;登录2&quot; form=&quot;form1&quot; formaction=&quot;http://www.qfedu.com&quot; formmethod=&quot;post&quot;/&gt;&lt;br/&gt; 3.3 布局标签 用于对网页中的视图组件进行排版 3.3.1 标题 h标签提供了默认的标题样式,HTML中提供了 h1~h6 用于表示6级标题 123456&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt; 3.3.2 段落 p标签： HTML可以将文档分割成多个段落 hr标签： 水平分割线 br标签：换行 1234567891011121314151617&lt;hr/&gt;&lt;p&gt; 枫桥夜泊&lt;br/&gt; 张继&lt;br/&gt; 月落乌啼霜满天，&lt;br/&gt; 江枫渔火对愁眠；&lt;br/&gt; 姑苏城外寒山寺，&lt;br/&gt; 夜半钟声到客船。&lt;br/&gt;&lt;/p&gt;&lt;p&gt; 静夜思&lt;br/&gt; 李白&lt;br/&gt; 床前明月光，&lt;br/&gt; 疑是地上霜；&lt;br/&gt; 举头望明月，&lt;br/&gt; 低头思故乡。&lt;br/&gt;&lt;/p&gt; 3.3.3 列表 将相关联的多行文本以列表的形式进行展示 1.有序列表 12345678910水龙头接水的步骤：&lt;!-- ol标签表示有序列表，li子标签表示列表项 --&gt;&lt;!-- type属性用于指定序号的类型 1 A a I i--&gt;&lt;ol type=&quot;i&quot;&gt; &lt;li&gt;放置水桶&lt;/li&gt; &lt;li&gt;打开水龙头&lt;/li&gt; &lt;li&gt;等待放水&lt;/li&gt; &lt;li&gt;关闭水龙头&lt;/li&gt; &lt;li&gt;提走水桶&lt;/li&gt;&lt;/ol&gt; 2.无序列表 12345678910水果列表&lt;!-- ul标签表示无序列表，li子标签表示列表项 --&gt;&lt;!-- type属性用于指定图标的类型 disc实心圆 circle空心圆 square方形实心 --&gt;&lt;ul type=&quot;square&quot;&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;菠萝&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;li&gt;火龙果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt;&lt;/ul&gt; 3.自定义列表 123456789自定义列表&lt;dl&gt; &lt;dt&gt;分组1&lt;/dt&gt; &lt;dd&gt;1-1&lt;/dd&gt; &lt;dd&gt;1-2&lt;/dd&gt; &lt;dt&gt;分组2&lt;/dt&gt; &lt;dd&gt;2-1&lt;/dd&gt; &lt;dd&gt;2-2&lt;/dd&gt;&lt;/dl&gt; 3.3.4 表格 在网页中显示一个表格，通过将页面的HTML元素存放在表格的不同单元格，以达到设置元素布局的效果 123456789101112131415161718192021222324252627282930313233343536&lt;!-- table标签：用于在网页中定义一个表格 ，表格是由若干行组成，行被分割成多个单元格--&gt;&lt;!-- 表格（table）:table中的属性设置的是整个表格的属性 border属性：设置表格的边框宽度（同时设置表格外边框，以及每个单元格的边框） cellspacing属性：设置单元格空隙 cellpadding属性：设置当前表格中单元格的内边距 width、height属性：设置当前表格的宽度、高度 align属性：设置当前表格在网页中的水平位置（left|center|right） bgcolor属性：设置表格的背景颜色 background属性：设置当前表格的背景图片行（tr）：用在table标签里面，一对tr标签就表示表格中的一行 ，tr的属性设置影响当前行 height属性：设置当前行的高度，如果不设置行高，则平均分配 bgcolor属性：设置当前行的背景颜色单元格（td）：写在tr标签，一对td标签就表示当前行中的一个单元格 ,每一行的对应列都会自动对齐 width属性：设置当前单元格的宽度，设置某一行的单元格宽度，其他行对应单元格宽度同步修改 bgcolor属性：设置当前单元格的背景颜色 valign属性：设置当前单元格中的内容在当前单元格中的垂直位置（middle、top、bottom） align属性：设置当前单元格中的内容在当前单元格中的水平位置（left、center、right） colspan属性：横向合并单元格（设置当前单元格占用几个单元格的宽度） rowspan属性：纵向合并单元格（设置当前单元格占用几行的高度）--&gt;&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;300&quot; height=&quot;300&quot; align=&quot;center&quot; bgcolor=&quot;orange&quot;&gt; &lt;tr height=&quot;50&quot; bgcolor=&quot;aqua&quot;&gt; &lt;td colspan=&quot;2&quot;&gt;1-1&lt;/td&gt; &lt;td width=&quot;50&quot; rowspan=&quot;2&quot;&gt;1-3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;50&quot; rowspan=&quot;2&quot;&gt;2-1&lt;/td&gt; &lt;td valign=&quot;bottom&quot; align=&quot;right&quot;&gt;2-2&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;50&quot;&gt; &lt;td colspan=&quot;2&quot;&gt;3-2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 3.3.5 div层 区块元素（标签），在浏览器中进行显示的时候，通常会有换行 （例如：段落p、表格table…） 内联元素（标签），在浏览器中进行显示的时候，不会进行换行（例如：label img） 1234567891011121314151617181920&lt;!-- div标签：层，一个HTML标签的容器 1.如果不设置宽度，则默认宽度为父容器的宽度（如下：body就是div的父容器）2.如果不设置高度，则DIV的高度默认与其中存放的元素高度相同3.div中可以包含HTML标签，我通过对DIV标签的设置可以实现HTML标签的层叠--&gt;&lt;!-- &lt;img src=&quot;imgs/img01.png&quot; height=&quot;100&quot;/&gt;&lt;img src=&quot;imgs/img02.png&quot; height=&quot;100&quot;/&gt;&lt;img src=&quot;imgs/img03.png&quot; height=&quot;100&quot;/&gt; --&gt;&lt;div style=&quot; width: 83px; height: 100px; border: 1px solid red; position: absolute; left: 0px; top:0px&quot;&gt; &lt;img src=&quot;imgs/img01.png&quot; height=&quot;100&quot;/&gt;&lt;/div&gt;&lt;div style=&quot; width: 83px; height: 100px; border: 1px solid green; position: absolute; left: 50px; top:50px&quot;&gt; &lt;img src=&quot;imgs/img02.png&quot; height=&quot;100&quot;/&gt;&lt;/div&gt;&lt;div style=&quot; width: 83px; height: 100px; border: 1px solid blue; position: absolute;left: 100px; top: 100px;&quot;&gt; &lt;img src=&quot;imgs/img03.png&quot; height=&quot;100&quot;/&gt;&lt;/div&gt; 3.3.6 fieldset字段集1234567&lt;!-- fieldset标签：网页中的模块，也是一个容器，默认带有边框,有内边距 --&gt;&lt;!-- legend子标签：用于设置当前模块区域的标题 --&gt;&lt;fieldset style=&quot;width: 300px; height: 100px;&quot;&gt; &lt;legend&gt;🏀管理员登录&lt;/legend&gt; &lt;p&gt;帐号：&lt;input type=&quot;text&quot;/&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot;/&gt;&lt;/p&gt;&lt;/fieldset&gt; 3.4 功能标签 功能标签，在网页中没有对应的视图效果，但是可以实现特定的功能 form表单，用于提交用户输入数据的 a超链接 3.4.1 form表单参考3.2.5 3.4.2 a 标签超链接 激活文本可点击，当点击这个特定的文本之后，链接到对应的地址 1234&lt;!-- a标签（超链接）：激活文本/图片连接href 属性指定当前文本/图片链接的地址--&gt;学Java开发就来&lt;a href=&quot;http://www.qfedu.com&quot;&gt;千锋教育&lt;/a&gt; &lt;br/&gt;&lt;a href=&quot;https://www.baidu.com/s?wd=张韶涵&quot;&gt;&lt;img src=&quot;imgs/img01.png&quot; height=&quot;50&quot;/&gt;&lt;/a&gt; 锚点 用于当前页面不同位置的跳转 123456789101112131415161718&lt;hr/&gt;&lt;a href=&quot;#aaa&quot;&gt;div1&lt;/a&gt;&lt;!-- 跳转到锚点 --&gt;&lt;a href=&quot;#bbb&quot;&gt;div2&lt;/a&gt;&lt;a href=&quot;#ccc&quot;&gt;div3&lt;/a&gt;&lt;a href=&quot;#ddd&quot;&gt;div4&lt;/a&gt;&lt;hr/&gt;&lt;a id=&quot;aaa&quot;&gt;&lt;/a&gt;&lt;!-- 定义锚点 --&gt;&lt;div style=&quot;height: 1000px; background-color: aquamarine;&quot;&gt;div1&lt;/div&gt;&lt;a id=&quot;bbb&quot;&gt;&lt;/a&gt;&lt;!-- 定义锚点 --&gt;&lt;div style=&quot;height: 1000px; background-color: lawngreen;&quot;&gt;div2&lt;/div&gt;&lt;a id=&quot;ccc&quot;&gt;&lt;/a&gt;&lt;!-- 定义锚点 --&gt;&lt;div style=&quot;height: 1000px; background-color: palevioletred;&quot;&gt;div3&lt;/div&gt;&lt;a id=&quot;ddd&quot;&gt;&lt;/a&gt;&lt;!-- 定义锚点 --&gt;&lt;div style=&quot;height: 1000px; background-color: peru;&quot;&gt;div4&lt;/div&gt; 3.5 框架标签-iframe 框架标签，实现页面的模块化 frameset frame 不建议使用 iframe 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table width=&quot;100%&quot; height=&quot;880&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; &gt; &lt;tr height=&quot;80&quot; bgcolor=&quot;lightblue&quot;&gt; &lt;td align=&quot;center&quot;&gt; &lt;label style=&quot;font-size: 40px;&quot;&gt;QQMail&lt;/label&gt; &lt;/td&gt; &lt;td align=&quot;right&quot; valign=&quot;top&quot;&gt; 二狗，欢迎你！[&lt;a href=&quot;#&quot;&gt;退出&lt;/a&gt;] &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;200&quot; bgcolor=&quot;lightgray&quot; valign=&quot;top&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;page02-表单标签.html&quot; target=&quot;mainFrame&quot;&gt;新邮件&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.taobao.com&quot; target=&quot;mainFrame&quot;&gt;淘宝&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://www.qfedu.com&quot; target=&quot;mainFrame&quot;&gt;千锋&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;td&gt; &lt;!-- iframe标签，表示一个页面的容器,通过name属性可以设置点击超链接以后，将页面显示到当前容器 1.给iframe标签设置name属性 2.给超链接a标签设置target等于iframe的name属性值 --&gt; &lt;iframe name=&quot;mainFrame&quot; width=&quot;100%&quot; height=&quot;800&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 3.6 其他标签3.6.1 文本修饰123456789101112&lt;b&gt;粗体&lt;/b&gt;&lt;i&gt;斜体&lt;/i&gt;&lt;u&gt;下划线&lt;/u&gt;&lt;del&gt;删除线&lt;/del&gt;&lt;strong&gt;加重语气&lt;/strong&gt;&lt;em&gt;强调&lt;/em&gt;&lt;small&gt;小号文本&lt;/small&gt;10&lt;sup&gt;上标&lt;/sup&gt;4&lt;sub&gt;下标&lt;/sub&gt; 3.6.2 计算机输出相关12345&lt;!-- 计算机输出标签，除了字体有所改变之外，更多的是语义上的设定 --&gt;&lt;code&gt;System.out.println(&quot;计算机代码!&quot;);&lt;/code&gt;&lt;kbd&gt;Ctrl+L&lt;/kbd&gt;&lt;var&gt;程序变量&lt;/var&gt;&lt;pre&gt;预定义&lt;/pre&gt; 3.6.3 引用标签1234&lt;address&gt;湖北省武汉市江夏区&lt;/address&gt;跟着涛哥一起学习&lt;abbr title=&quot;Java DataBase Conectivity&quot;&gt;JDBC&lt;/abbr&gt;技术&lt;bdo dir=&quot;rtl&quot;&gt;定义文字方向&lt;/bdo&gt;毛泽东同志说：&lt;blockquote&gt;生的伟大，死的光荣！&lt;/blockquote&gt; 四、HTML页面设计案例 案例：使用HTML标签，完成华为商城的登录页面的设计 4.1 模仿页面分析 4.2 按照分析进行网页设计12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;华为商城欢迎您&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;100%&quot; height=&quot;960&quot;&gt; &lt;tr height=&quot;40&quot; bgcolor=&quot;#eeeeee&quot;&gt; &lt;td width=&quot;355&quot;&lt;/td&gt; &lt;td&gt; &lt;img src=&quot;imgs/logo.jpg&quot; height=&quot;30&quot;/&gt;|千锋商城 &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td width=&quot;355&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;150&quot;&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;label style=&quot;font-size: 30px;&quot;&gt;华为帐号登录&lt;/label&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; width=&quot;30%&quot;&gt; &lt;img src=&quot;imgs/qrcode.png&quot; width=&quot;200&quot; height=&quot;200&quot; /&gt; &lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;label style=&quot;font-size: 10px; color: lightgray;&quot;&gt;若您使用华为手机，请进入“设置”&gt;“华为帐号”扫码登录。&lt;/label&gt; &lt;/td&gt; &lt;td width=&quot;30%&quot;&gt; &lt;table height=&quot;320&quot; width=&quot;400&quot;&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt;&lt;input type=&quot;text&quot; placeholder=&quot;手机号/邮箱地址/账号名&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt; &lt;input type=&quot;password&quot; placeholder=&quot;密码&quot;/&gt; &lt;br/&gt; &lt;a href=&quot;#&quot;&gt;短信验证码登录&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt; &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;忘记密码&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;遇到问题&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=&quot;center&quot;&gt; &lt;img src=&quot;imgs/qq.png&quot; /&gt; &lt;img src=&quot;imgs/zfb.png&quot; /&gt; &lt;img src=&quot;imgs/wx.png&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;150&quot;&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;100&quot; bgcolor=&quot;#eeeeee&quot;&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot; valign=&quot;middle&quot;&gt; &lt;a href=&quot;#&quot;&gt;华为帐号用户协议&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;关于华为帐号与隐私的声明&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;常见问题&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;Cookies&lt;/a&gt; &lt;br/&gt; 华为帐号 版权所有 © 2011-2021 &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 案例运行效果图","categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-09-03T02:44:45.202Z","updated":"2022-09-13T16:28:03.568Z","comments":true,"path":"2022/09/03/hello-world/","link":"","permalink":"http://example.com/2022/09/03/hello-world/","excerpt":"","text":"First,my name is bitezhang,you can call me 杰哥. Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 1，生成新的文章代码： 12hexo new &quot;page&quot;（代码中标点符号都为英文）文件会生成在source/_posts之下_ 2，本地预览指令： 1hexo s 3，上传指令： 123先 hexo g 再 hexo d或hexo g -d （这两个指令执行之后，网页就会自动更新） 4，新建页面 1hexo new page &quot;页面名&quot;","categories":[{"name":"HelloWorld","slug":"HelloWorld","permalink":"http://example.com/categories/HelloWorld/"}],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/tags/Hello-World/"}]}],"categories":[{"name":"JavaWeb(1)","slug":"JavaWeb-1","permalink":"http://example.com/categories/JavaWeb-1/"},{"name":"HelloWorld","slug":"HelloWorld","permalink":"http://example.com/categories/HelloWorld/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://example.com/tags/JDBC/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"},{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"},{"name":"JSP","slug":"JSP","permalink":"http://example.com/tags/JSP/"},{"name":"Servlet","slug":"Servlet","permalink":"http://example.com/tags/Servlet/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"JavaWebGuide","slug":"JavaWebGuide","permalink":"http://example.com/tags/JavaWebGuide/"},{"name":"HTML","slug":"HTML","permalink":"http://example.com/tags/HTML/"},{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/tags/Hello-World/"}]}